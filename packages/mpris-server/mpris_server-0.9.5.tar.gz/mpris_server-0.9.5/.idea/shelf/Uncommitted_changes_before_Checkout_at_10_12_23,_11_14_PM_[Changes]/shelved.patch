Index: mpris_server/interfaces/player.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import annotations\n\nimport logging\nfrom enum import StrEnum\nfrom typing import ClassVar, Final, Optional\n\nfrom gi.repository.GLib import Variant\nfrom pydbus.generic import signal\n\nfrom .interface import MprisInterface, log_trace\nfrom ..base import BEGINNING, DbusTypes, MAX_RATE, MAX_VOL, MIN_RATE, MUTE_VOL, PAUSE_RATE, \\\n  PlayState, Position, ROOT_INTERFACE, Rate, Track, Volume\nfrom ..enums import Access, Arg, Direction, Method, Property, Signal\nfrom ..mpris.metadata import DEFAULT_METADATA, DbusMetadata, Metadata, get_dbus_metadata\n\n\nclass LoopStatus(StrEnum):\n  NONE: str = 'None'\n  TRACK: str = 'Track'\n  PLAYLIST: str = 'Playlist'\n\n\nclass Player(MprisInterface):\n  INTERFACE: ClassVar[str] = f\"{ROOT_INTERFACE}.Player\"\n\n  __doc__ = f\"\"\"\n  <node>\n    <interface name=\"{INTERFACE}\">\n      <method name=\"{Method.Next}\"/>\n      <method name=\"{Method.Pause}\"/>\n      <method name=\"{Method.PlayPause}\"/>\n      <method name=\"{Method.Play}\"/>\n      <method name=\"{Method.Previous}\"/>\n      <method name=\"{Method.Stop}\"/>\n      <method name=\"{Method.OpenUri}\">\n        <arg name=\"{Arg.Uri}\" type=\"{DbusTypes.STRING}\" direction=\"{Direction.In}\"/>\n      </method>\n        <method name=\"{Method.Seek}\">\n        <arg name=\"{Arg.Offset}\" type=\"{DbusTypes.INT64}\" direction=\"{Direction.In}\"/>\n      </method>\n      <method name=\"{Method.SetPosition}\">\n        <arg name=\"{Arg.TrackId}\" type=\"{DbusTypes.OBJ}\" direction=\"{Direction.In}\"/>\n        <arg name=\"{Arg.Position}\" type=\"{DbusTypes.INT64}\" direction=\"{Direction.In}\"/>\n      </method>\n\n      <property name=\"{Property.CanControl}\" type=\"{DbusTypes.BOOLEAN}\" access=\"{Access.read}\"/>\n      <property name=\"{Property.CanGoNext}\" type=\"{DbusTypes.BOOLEAN}\" access=\"{Access.read}\"/>\n      <property name=\"{Property.CanGoPrevious}\" type=\"{DbusTypes.BOOLEAN}\" access=\"{Access.read}\"/>\n      <property name=\"{Property.CanPause}\" type=\"{DbusTypes.BOOLEAN}\" access=\"{Access.read}\"/>\n      <property name=\"{Property.CanPlay}\" type=\"{DbusTypes.BOOLEAN}\" access=\"{Access.read}\"/>\n      <property name=\"{Property.CanSeek}\" type=\"{DbusTypes.BOOLEAN}\" access=\"{Access.read}\"/>\n      <property name=\"{Property.LoopStatus}\" type=\"{DbusTypes.STRING}\" access=\"{Access.readwrite}\"/>\n      <property name=\"{Property.MaximumRate}\" type=\"{DbusTypes.DOUBLE}\" access=\"{Access.read}\"/>\n      <property name=\"{Property.Metadata}\" type=\"{DbusTypes.METADATA}\" access=\"{Access.read}\"/>\n      <property name=\"{Property.MinimumRate}\" type=\"{DbusTypes.DOUBLE}\" access=\"{Access.read}\"/>\n      <property name=\"{Property.PlaybackStatus}\" type=\"{DbusTypes.STRING}\" access=\"{Access.read}\"/>\n      <property name=\"{Property.Position}\" type=\"{DbusTypes.INT64}\" access=\"{Access.read}\"/>\n      <property name=\"{Property.Rate}\" type=\"{DbusTypes.DOUBLE}\" access=\"{Access.readwrite}\"/>\n      <property name=\"{Property.Shuffle}\" type=\"{DbusTypes.BOOLEAN}\" access=\"{Access.readwrite}\"/>\n      <property name=\"{Property.Volume}\" type=\"{DbusTypes.DOUBLE}\" access=\"{Access.readwrite}\"/>\n\n      <signal name=\"{Signal.Seeked}\">\n        <arg name=\"{Arg.Position}\" type=\"{DbusTypes.INT64}\"/>\n      </signal>\n    </interface>\n  </node>\n  \"\"\"\n\n  Seeked: Final[signal] = signal()\n\n  def _dbus_metadata(self) -> Optional[DbusMetadata]:\n    if metadata := self.adapter.metadata():\n      return get_dbus_metadata(metadata)\n\n    return None\n\n  def _get_art_url(self, track: 'Track') -> str:\n    return self.adapter.get_art_url(track)\n\n  @property\n  @log_trace\n  def CanControl(self) -> bool:\n    return self.adapter.can_control()\n\n  @property\n  @log_trace\n  def CanGoNext(self) -> bool:\n    # if not self.CanControl:\n    # return False\n\n    return self.adapter.can_go_next()\n\n  @property\n  @log_trace\n  def CanGoPrevious(self) -> bool:\n    # if not self.CanControl:\n    # return False\n\n    return self.adapter.can_go_previous()\n\n  @property\n  @log_trace\n  def CanPause(self) -> bool:\n    return self.adapter.can_pause()\n    # if not self.CanControl:\n    # return False\n\n    # return True\n\n  @property\n  @log_trace\n  def CanPlay(self) -> bool:\n    # if not self.CanControl:\n    # return False\n\n    return self.adapter.can_play()\n\n  @property\n  @log_trace\n  def CanSeek(self) -> bool:\n    return self.adapter.can_seek()\n    # if not self.CanControl:\n    # return False\n\n    # return True\n\n  @property\n  @log_trace\n  def LoopStatus(self) -> str:\n    if not self.adapter.is_repeating():\n      return LoopStatus.NONE\n\n    elif not self.adapter.is_playlist():\n      return LoopStatus.TRACK\n\n    else:\n      return LoopStatus.PLAYLIST\n\n  @LoopStatus.setter\n  @log_trace\n  def LoopStatus(self, value: str):\n    if not self.CanControl:\n      logging.debug(f\"Setting {self.INTERFACE}.LoopStatus not allowed\")\n      return\n\n    logging.debug(f\"Setting {self.INTERFACE}.LoopStatus to {value}\")\n\n    self.adapter.set_loop_status(value)\n    # if value == \"None\":\n    # self.core.tracklist.set_repeat(False)\n    # self.core.tracklist.set_single(False)\n    # elif value == \"Track\":\n    # self.core.tracklist.set_repeat(True)\n    # self.core.tracklist.set_single(True)\n    # elif value == \"Playlist\":\n    # self.core.tracklist.set_repeat(True)\n    # self.core.tracklist.set_single(False)\n\n  @property\n  @log_trace\n  def MaximumRate(self) -> Rate:\n    rate = self.adapter.get_minimum_rate()\n\n    if rate is None:\n      return MAX_RATE\n\n    return rate\n\n  @property\n  @log_trace\n  def MinimumRate(self) -> Rate:\n    rate = self.adapter.get_minimum_rate()\n\n    if rate is None:\n      return MIN_RATE\n\n    return rate\n\n  @property\n  @log_trace\n  def Metadata(self) -> Metadata:\n    # prefer adapter's metadata to building our own\n    metadata: DbusMetadata = self._dbus_metadata()\n\n    if metadata:\n      return metadata\n\n    # build metadata if no metadata supplied by adapter\n    logging.debug(f\"Building {self.INTERFACE}.Metadata\")\n\n    track = self.adapter.get_current_track()\n    stream_title = self.adapter.get_stream_title()\n\n    if track is None:\n      return DEFAULT_METADATA\n\n    track_id = track.track_id\n    metadata = {\"mpris:trackid\": Variant(\"o\", track_id)}\n\n    if track.length:\n      metadata[\"mpris:length\"] = Variant(\"x\", track.length)\n\n    if track.uri:\n      metadata[\"xesam:url\"] = Variant(\"s\", track.uri)\n\n    if stream_title or track.name:\n      metadata[\"xesam:title\"] = Variant(\"s\", stream_title or track.name)\n\n    if track.artists:\n      artists = list(track.artists)\n      artists.sort(key=lambda a: a.name or \"\")\n      metadata[\"xesam:artist\"] = Variant(\"as\", [a.name for a in artists if a.name])\n\n    if track.album and track.album.name:\n      metadata[\"xesam:album\"] = Variant(\"s\", track.album.name)\n\n    if track.album and track.album.artists:\n      artists = list(track.album.artists)\n      artists.sort(key=lambda a: a.name or \"\")\n      metadata[\"xesam:albumArtist\"] = Variant(\n        \"as\", [a.name for a in artists if a.name]\n      )\n\n    art_url = self._get_art_url(track)\n\n    if art_url:\n      metadata[\"mpris:artUrl\"] = Variant(\"s\", art_url)\n\n    if track.disc_no:\n      metadata[\"xesam:discNumber\"] = Variant(\"i\", track.disc_no)\n\n    if track.track_no:\n      metadata[\"xesam:trackNumber\"] = Variant(\"i\", track.track_no)\n\n    return metadata\n\n  @property\n  @log_trace\n  def PlaybackStatus(self) -> str:\n    state = self.adapter.get_playstate()\n    return state.value.title()\n\n  @property\n  @log_trace\n  def Position(self) -> Position:\n    return self.adapter.get_current_position()\n\n  @property\n  @log_trace\n  def Rate(self) -> Rate:\n    return self.adapter.get_rate()\n\n  @Rate.setter\n  @log_trace\n  def Rate(self, value: Rate):\n    if not self.CanControl:\n      logging.debug(f\"Setting {self.INTERFACE}.Rate not allowed\")\n      return\n\n    self.adapter.set_rate(value)\n\n    if value == PAUSE_RATE:\n      self.Pause()\n\n  @property\n  @log_trace\n  def Shuffle(self) -> bool:\n    return self.adapter.get_shuffle()\n\n  @Shuffle.setter\n  @log_trace\n  def Shuffle(self, value: bool):\n    if not self.CanControl:\n      logging.debug(f\"Setting {self.INTERFACE}.Shuffle not allowed\")\n      return\n\n    logging.debug(f\"Setting {self.INTERFACE}.Shuffle to {value}\")\n    self.adapter.set_shuffle(value)\n\n  @property\n  @log_trace\n  def Volume(self) -> Volume:\n    mute = self.adapter.is_mute()\n    volume = self.adapter.get_volume()\n\n    if volume is None or mute is True:\n      return MUTE_VOL\n\n    return volume\n\n  @Volume.setter\n  @log_trace\n  def Volume(self, value: Volume):\n    if not self.CanControl:\n      logging.debug(f\"Setting {self.INTERFACE}.Volume not allowed\")\n      return\n\n    if value is None:\n      return\n\n    if value < MUTE_VOL:\n      value = MUTE_VOL\n\n    elif value > MAX_VOL:\n      value = MAX_VOL\n\n    self.adapter.set_volume(value)\n\n    if value > MUTE_VOL:\n      self.adapter.set_mute(False)\n\n    elif value == MUTE_VOL:\n      self.adapter.set_mute(True)\n\n  @log_trace\n  def Next(self):\n    if not self.CanGoNext:\n      logging.debug(f\"{self.INTERFACE}.Next not allowed\")\n      return\n\n    self.adapter.next()\n\n  @log_trace\n  def OpenUri(self, uri: str):\n    if not self.CanControl:\n      logging.debug(f\"{self.INTERFACE}.OpenUri not allowed\")\n      return\n\n    # NOTE Check if URI has MIME type known to the backend, if MIME support\n    # is added to the backend.\n    self.adapter.open_uri(uri)\n\n  @log_trace\n  def Previous(self):\n    if not self.CanGoPrevious:\n      logging.debug(f\"{self.INTERFACE}.Previous not allowed\")\n      return\n\n    self.adapter.previous()\n\n  @log_trace\n  def Pause(self):\n    if not self.CanPause:\n      logging.debug(f\"{self.INTERFACE}.Pause not allowed\")\n      return\n\n    self.adapter.pause()\n\n  @log_trace\n  def Play(self):\n    if not self.CanPlay:\n      logging.debug(f\"{self.INTERFACE}.Play not allowed\")\n      return\n\n    state = self.adapter.get_playstate()\n\n    if state is PlayState.PAUSED:\n      self.adapter.resume()\n\n    else:\n      self.adapter.play()\n\n  @log_trace\n  def PlayPause(self):\n    if not self.CanPause:\n      logging.debug(f\"{self.INTERFACE}.PlayPause not allowed\")\n      return\n\n    state = self.adapter.get_playstate()\n\n    if state is PlayState.PLAYING:\n      self.adapter.pause()\n\n    elif state is PlayState.PAUSED:\n      self.adapter.resume()\n\n    elif state is PlayState.STOPPED:\n      self.adapter.play()\n\n  @log_trace\n  def Seek(self, offset: Position):\n    if not self.CanSeek:\n      logging.debug(f\"{self.INTERFACE}.Seek not allowed\")\n      return\n\n    current_position = self.adapter.get_current_position()\n    new_position = current_position + offset\n\n    if new_position < BEGINNING:\n      new_position = BEGINNING\n\n    self.adapter.seek(new_position)\n\n  @log_trace\n  def SetPosition(self, track_id: str, position: Position):\n    if not self.CanSeek:\n      logging.debug(f\"{self.INTERFACE}.SetPosition not allowed\")\n      return\n\n    self.adapter.seek(position, track_id=track_id)\n\n    # metadata = self.adapter.metadata()\n    # current_track: Optional[Track] = None\n\n    ##use metadata from adapter if available\n    # if metadata \\\n    # and 'mpris:trackid' in metadata \\\n    # and 'mpris:length' in metadata:\n    # current_track = Track(\n    # track_id=metadata['mpris:trackid'],\n    # length=metadata['mpris:length']\n    # )\n\n    ##if no metadata, build metadata from Track interface\n    # else:\n    # current_track = self.adapter.get_current_track()\n\n    # if current_track is None:\n    # return\n\n    # if track_id != current_track.track_id:\n    # return\n\n    # if position < BEGINNING:\n    # return\n\n    # if current_track.length < position:\n    # return\n\n    # self.adapter.seek(position, track_id=track_id)\n\n  @log_trace\n  def Stop(self):\n    if not self.CanControl:\n      logging.debug(f\"{self.INTERFACE}.Stop not allowed\")\n      return\n\n    self.adapter.stop()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mpris_server/interfaces/player.py b/mpris_server/interfaces/player.py
--- a/mpris_server/interfaces/player.py	
+++ b/mpris_server/interfaces/player.py	
@@ -11,7 +11,7 @@
 from ..base import BEGINNING, DbusTypes, MAX_RATE, MAX_VOL, MIN_RATE, MUTE_VOL, PAUSE_RATE, \
   PlayState, Position, ROOT_INTERFACE, Rate, Track, Volume
 from ..enums import Access, Arg, Direction, Method, Property, Signal
-from ..mpris.metadata import DEFAULT_METADATA, DbusMetadata, Metadata, get_dbus_metadata
+from ..mpris.metadata import DEFAULT_METADATA, DbusMetadata, Metadata, MetadataEntries, get_dbus_metadata
 
 
 class LoopStatus(StrEnum):
@@ -180,9 +180,7 @@
   @log_trace
   def Metadata(self) -> Metadata:
     # prefer adapter's metadata to building our own
-    metadata: DbusMetadata = self._dbus_metadata()
-
-    if metadata:
+    if metadata := self._dbus_metadata():
       return metadata
 
     # build metadata if no metadata supplied by adapter
@@ -194,43 +192,74 @@
     if track is None:
       return DEFAULT_METADATA
 
-    track_id = track.track_id
-    metadata = {"mpris:trackid": Variant("o", track_id)}
+    metadata: dict[MetadataEntries, Variant] = {
+      MetadataEntries.TRACK_ID: Variant(
+        DbusTypes.OBJ,
+        track.track_id,
+      )
+    }
 
     if track.length:
-      metadata["mpris:length"] = Variant("x", track.length)
+      metadata[MetadataEntries.LENGTH] = Variant(
+        DbusTypes.INT64,
+        track.length,
+      )
 
     if track.uri:
-      metadata["xesam:url"] = Variant("s", track.uri)
+      metadata[MetadataEntries.URL] = Variant(
+        DbusTypes.STRING,
+        track.uri,
+      )
 
     if stream_title or track.name:
-      metadata["xesam:title"] = Variant("s", stream_title or track.name)
+      metadata[MetadataEntries.TITLE] = Variant(
+        DbusTypes.STRING,
+        stream_title or track.name,
+      )
 
     if track.artists:
       artists = list(track.artists)
-      artists.sort(key=lambda a: a.name or "")
-      metadata["xesam:artist"] = Variant("as", [a.name for a in artists if a.name])
+      artists.sort(key=sort_names)
+
+      metadata[MetadataEntries.ARTISTS] = Variant(
+        DbusTypes.STRING_ARRAY,
+        [a.name for a in artists if a.name],
+      )
 
     if track.album and track.album.name:
-      metadata["xesam:album"] = Variant("s", track.album.name)
+      metadata[MetadataEntries.ALBUM] = Variant(
+        DbusTypes.STRING,
+        track.album.name,
+      )
 
     if track.album and track.album.artists:
       artists = list(track.album.artists)
-      artists.sort(key=lambda a: a.name or "")
-      metadata["xesam:albumArtist"] = Variant(
-        "as", [a.name for a in artists if a.name]
+      artists.sort(key=sort_names)
+
+      metadata[MetadataEntries.ALBUM_ARTISTS] = Variant(
+        DbusTypes.STRING_ARRAY,
+        [a.name for a in artists if a.name],
       )
 
     art_url = self._get_art_url(track)
 
     if art_url:
-      metadata["mpris:artUrl"] = Variant("s", art_url)
+      metadata[MetadataEntries.ART_URL] = Variant(
+        DbusTypes.STRING,
+        art_url,
+      )
 
     if track.disc_no:
-      metadata["xesam:discNumber"] = Variant("i", track.disc_no)
+      metadata[MetadataEntries.DISC_NUMBER] = Variant(
+        DbusTypes.INT32,
+        track.disc_no,
+      )
 
     if track.track_no:
-      metadata["xesam:trackNumber"] = Variant("i", track.track_no)
+      metadata[MetadataEntries.TRACK_NUMBER] = Variant(
+        DbusTypes.INT32,
+        track.track_no,
+      )
 
     return metadata
 
