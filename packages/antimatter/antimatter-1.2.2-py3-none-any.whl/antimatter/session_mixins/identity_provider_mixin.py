from typing import Any, Callable, Dict, List, Optional, Union

import antimatter_api as openapi_client
from antimatter.constants.identity_provider import PrincipalType, ProviderType
from antimatter.session_mixins.serializers.identity_details import (
    serialize_identity_principal_details_dict,
    serialize_identity_provider_info_dict,
)

from antimatter.converters import CapabilityConverter
from antimatter.session_mixins.base import BaseMixin


class OverrideDomainIdentityPrincipalDetails(openapi_client.DomainIdentityPrincipalDetails):
    """
    This override provides a local way to pass domain identity principal details
    to the openapi generated client that mitigates the pydantic serializing error
    it produces due to a bug in the generator.

    The code that the generator currently produces looks like:
    .. code-block:: python

        one_of_schemas: List[str] = Literal["APIKeyDomainIdentityProviderDetails", "GoogleOAuthDomainIdentityProviderDetails"]

    that will produce the error:

    .. code-block:: text

        /Users/daniel/.pyenv/versions/pycapsule-3.11/lib/python3.11/site-packages/pydantic/main.py:308: UserWarning: Pydantic serializer warnings:
        Expected `list[str]` but got `_LiteralGenericAlias` - serialized value may not be as expected
        return self.__pydantic_serializer__.to_python(

    """

    one_of_schemas: List[str] = [
        "DomainIdentityAPIKeyPrincipalParams",
        "DomainIdentityEmailPrincipalParams",
        "DomainIdentityHostedDomainPrincipalParams",
    ]


class IdentityProviderMixin(BaseMixin):
    """
    Session mixin defining identity provider CRUD functionality.
    """

    def upsert_identity_provider(
        self,
        provider_name: str,
        provider_type: Union[str, ProviderType] = ProviderType.ApiKey,
        client_id: Optional[str] = None,
    ) -> Dict[str, Any]:
        """
        Create or update an identity provider.

        :param provider_name: The name of a new or existing identity provider
        :param provider_type: The provider type for identity management
        :param client_id: If the provider type is 'GoogleOAuth', a client ID must be provided
        :return: The identity provider summary
        """
        provider_type = ProviderType(provider_type)
        provider_params = None
        if ProviderType(provider_type) is ProviderType.GoogleOAuth:
            provider_params = openapi_client.GoogleOAuthDomainIdentityProviderDetails(
                type=ProviderType.GoogleOAuth.value,
                client_id=client_id,
            )
        elif ProviderType(provider_type) is ProviderType.ApiKey:
            provider_params = openapi_client.APIKeyDomainIdentityProviderDetails(
                type=ProviderType.ApiKey.value,
            )
        # Disable warnings because of a bug in DomainIdentityProviderDetails autogenerated code
        res = (
            openapi_client.AuthenticationApi(self.authz.get_client())
            .domain_upsert_identity_provider(
                domain_id=self.domain_id,
                identity_provider_name=provider_name,
                domain_identity_provider_details=openapi_client.DomainIdentityProviderDetails(
                    provider_params
                ),
            )
            .model_dump(warnings=False)
        )
        return serialize_identity_provider_info_dict(res)

    def insert_identity_provider_principal(
        self,
        provider_name: str,
        capabilities: List[Union[str, Dict[str, Any]]],
        principal_type: Union[str, PrincipalType],
        principal_value: Optional[str] = None,
        comment: Optional[str] = None,
    ) -> Dict[str, str]:
        """
        Creates a new principal for the provider. Note that the provider_name
        must refer to an existing identity provider. The principal_value is
        optional if the type is APIKey.

        :param provider_name: The name of an existing identity provider
        :param capabilities: The capabilities to attach to the principal. These can be in one of the following forms:
                - A list of unary capabilities, like ['admin', 'read_only']
                - A list of key-value pairs, like ["admin=True", "read_only=False"]
                - A list of dictionaries, like [{"admin": "True"}, {"read_only": "False"}]
                - A list of dictionaries as a name/value pair, like [{"name": "admin", "value": "True"}, {"name": "read_only", "value": "False"}]
                - Any combination of the above
        :param principal_type: The type of principal to create. One of 'APIKey', 'Email', or 'HostedDomain'
        :param principal_value: The appropriate identifying value for the principal, depending on type
        :param comment: An optional comment for the identity provider principal
        :return: The ID of the inserted principal and any additional metadata
        """
        capabilities = CapabilityConverter.convert_capabilities(capabilities)
        principal_type = PrincipalType(principal_type)
        inner_params = None
        if PrincipalType(principal_type) is PrincipalType.ApiKey:
            inner_params = openapi_client.DomainIdentityAPIKeyPrincipalParams(
                type=principal_type.value,
                api_key_id=principal_value,
                comment=comment,
            )
        elif PrincipalType(principal_type) is PrincipalType.Email:
            inner_params = openapi_client.DomainIdentityEmailPrincipalParams(
                type=principal_type.value,
                email=principal_value,
                comment=comment,
            )
        elif PrincipalType(principal_type) is PrincipalType.HostedDomain:
            inner_params = openapi_client.DomainIdentityHostedDomainPrincipalParams(
                type=principal_type.value,
                hosted_domain=principal_value,
                comment=comment,
            )
        return (
            openapi_client.AuthenticationApi(self.authz.get_client())
            .domain_insert_identity_provider_principal(
                domain_id=self.domain_id,
                identity_provider_name=provider_name,
                domain_identity_provider_principal_params=openapi_client.DomainIdentityProviderPrincipalParams(
                    capabilities=[
                        openapi_client.Capability(name=k, value=v) for k, v in capabilities.items()
                    ],
                    details=OverrideDomainIdentityPrincipalDetails(inner_params),
                ),
            )
            .model_dump(exclude_none=True)
        )

    def update_identity_provider_principal(
        self,
        provider_name: str,
        principal_id: str,
        capabilities: List[Union[str, Dict[str, Any]]],
    ) -> None:
        """
        Update the capabilities for an identity provider principal.

        :param provider_name: The name of an existing identity provider
        :param principal_id: The ID of the principal
        :param capabilities: The capabilities to attach to the principal. These can be in one of the following forms:
                - A list of unary capabilities, like ['admin', 'read_only']
                - A list of key-value pairs, like ["admin=True", "read_only=False"]
                - A list of dictionaries, like [{"admin": "True"}, {"read_only": "False"}]
                - A list of dictionaries as a name/value pair, like [{"name": "admin", "value": "True"}, {"name": "read_only", "value": "False"}]
                - Any combination of the above
        """
        capabilities = CapabilityConverter.convert_capabilities(capabilities)
        openapi_client.AuthenticationApi(self.authz.get_client()).domain_update_identity_provider_principal(
            domain_id=self.domain_id,
            identity_provider_name=provider_name,
            principal_id=principal_id,
            capability_list=openapi_client.CapabilityList(
                capabilities=[openapi_client.Capability(name=k, value=v) for k, v in capabilities.items()]
            ),
        )

    def get_identity_provider(self, provider_name: str) -> Dict[str, Any]:
        """
        Retrieve detailed information and configuration of an identity provider

        :param provider_name: The name of an existing identity provider
        :return: The identity provider details
        """
        res = (
            openapi_client.AuthenticationApi(self.authz.get_client())
            .domain_get_identity_provider(
                domain_id=self.domain_id,
                identity_provider_name=provider_name,
            )
            .model_dump(warnings=False)
        )
        return serialize_identity_provider_info_dict(res)

    def list_identity_providers(self) -> List[Dict[str, Any]]:
        """
        Retrieve the domain's identity providers and a brief overview of their
        configuration.
        """
        res = openapi_client.AuthenticationApi(self.authz.get_client()).domain_list_identity_providers(
            domain_id=self.domain_id
        )
        if not res.identity_providers:
            return []

        # Disable warnings because of a bug in DomainIdentityProviderDetails autogenerated code
        return [
            serialize_identity_provider_info_dict(prov.model_dump(warnings=False))
            for prov in res.identity_providers
        ]

    def get_identity_provider_principal(
        self,
        provider_name: str,
        principal_id: Optional[str] = None,
    ) -> Union[List[Dict[str, Any]], Dict[str, Any]]:
        """
        Get either a summary of all the principals for an identity provider, or
        detailed information about a single principal if a principal_id is
        provided

        :param provider_name: The name of an existing identity provider
        :param principal_id: The ID of the principal; None to get all principals
        :return: The principal information
        """
        if principal_id is None:
            res = openapi_client.AuthenticationApi(
                self.authz.get_client()
            ).domain_get_identity_provider_principals(
                domain_id=self.domain_id,
                identity_provider_name=provider_name,
            )
            principals = []
            for principal in res.principals:
                principal = principal.model_dump()
                if t := principal.get("principal_type"):
                    principal["principal_type"] = t.value
                principals.append(principal)
            return principals
        else:
            res = openapi_client.AuthenticationApi(
                self.authz.get_client()
            ).domain_get_identity_provider_principal(
                domain_id=self.domain_id,
                identity_provider_name=provider_name,
                principal_id=principal_id,
            )
            return serialize_identity_principal_details_dict(res.model_dump(warnings=False))

    def delete_identity_provider(self, provider_name: str) -> None:
        """
        Delete an identity provider. All domain tokens created using this
        identity provider will be invalidated. Take care not to remove the
        identity provider that is providing you admin access to your domain, as
        you may lock yourself out.

        :param provider_name: The name of the identity provider to fully delete
        """
        openapi_client.AuthenticationApi(self.authz.get_client()).domain_delete_identity_provider(
            domain_id=self.domain_id, identity_provider_name=provider_name
        )

    def delete_identity_provider_principal(
        self,
        provider_name: str,
        principal_id: str,
    ) -> None:
        """
        Delete an identity provider principal.

        :param provider_name: The name of the identity provider to delete a principal from
        :param principal_id: The ID of the principal to delete
        """
        openapi_client.AuthenticationApi(self.authz.get_client()).domain_delete_identity_provider_principal(
            domain_id=self.domain_id,
            identity_provider_name=provider_name,
            principal_id=principal_id,
        )
