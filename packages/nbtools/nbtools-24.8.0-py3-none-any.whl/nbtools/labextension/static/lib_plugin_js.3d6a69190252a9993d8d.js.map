{"version":3,"file":"lib_plugin_js.3d6a69190252a9993d8d.js","mappings":";;;;;;;;;;;;;;;;;;;AAAsD;AACN;AACL;AACI;AACxC,0BAA0B,mDAAM;AACvC;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAW;AACrC,0BAA0B,+CAAS;AACnC;AACA;AACA;AACA;AACA;AACO,uBAAuB,mDAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oDAAc;AACtB;AACA;AACA;AACA;AACA,qCAAqC;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,6CAA6C;AAC7C,aAAa,yDAAyD;AACtE,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ,8FAA8F;AAChI;AACA,0BAA0B,YAAY,UAAU,oGAAoG,IAAI,qFAAqF,IAAI;AACjP;AACA;AACA;AACA,qBAAqB,oDAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,6EAA6E,OAAO,IAAI,IAAI;AAC5F,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,gDAAgD;AAChD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,KAAK;AACzD;AACA,kBAAkB;AAClB;AACA,gDAAgD,KAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,WAAW;AAC1E;AACA,kBAAkB;AAClB;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0CAA0C,SAAS,WAAW;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4BAA4B,oDAAc;AAC1C;AACA,QAAQ,6CAAO,qDAAqD,qDAAa,SAAS,UAAU,qDAAa,WAAW;AAC5H;AACA;AACA;AACA,4BAA4B,oDAAc;AAC1C;AACA,gDAAgD,MAAM;AACtD,QAAQ,6CAAO,qDAAqD,qDAAa,SAAS,YAAY,qDAAa,aAAa,WAAW,MAAM;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8CAAM;AACd;AACA;;;;;;;;;;;;;;;;;;;;;ACrM2C;AACD;AACqB;AACxD,0BAA0B,oDAAK;AAC/B;AACP,SAAS,eAAe,YAAY;AACpC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,oCAAoC;AACpC,qCAAqC;AACrC;AACA,aAAa,oDAAc;AAC3B,YAAY,oDAAc;AAC1B,QAAQ,oDAAc;AACtB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sIAAsI;AACrJ;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wCAAwC;AACzD;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAc;AAC7B;AACA;AACO;AACP;AACA;AACA;AACA,uCAAuC,yDAAiB;AACxD,oCAAoC,yDAAiB;AACrD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7M+D;AACA;AACP;AACX;AACE;AACE;AACA;AACA;AACR;AACgB;AACN;AACkB;AACb;AACb;AACkB;AAC7D,mEAAmE,EAAE,wCAAY,GAAG,sCAAgB,GAAG,uCAAiB;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAa,EAAE,yDAAa;AAC3C,eAAe,yEAAsB,EAAE,yEAAgB;AACvD,eAAe,2DAAS,EAAE,qEAAe,EAAE,+DAAS,EAAE,mEAAgB;AACtE;AACA;AACA;AACA,iEAAe,cAAc,EAAC;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAY;AAC1C,8BAA8B,wDAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iDAAW;AACzB,iBAAiB,oDAAc;AAC/B;AACA,KAAK;AACL;AACA,IAAI,sDAAa;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,IAAI,qDAAc;AAClB,IAAI,qDAAc;AAClB,IAAI,qDAAc;AAClB,4BAA4B,qDAAc,EAAE;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAS;AACrB;AACA;AACA;AACA,gBAAgB,6CAAO;AACvB;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,6BAA6B,kDAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA,6BAA6B,iDAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sCAAsC,mBAAmB,IAAI,wBAAwB;AACrF","sources":["webpack://@g2nb/nbtools/./lib/databank.js","webpack://@g2nb/nbtools/./lib/dataregistry.js","webpack://@g2nb/nbtools/./lib/plugin.js"],"sourcesContent":["import { PanelLayout, Widget } from '@lumino/widgets';\nimport { escape_quotes, toggle } from \"./utils\";\nimport { ContextManager } from \"./context\";\nimport { SearchBox, Toolbox } from \"./toolbox\";\nexport class DataBrowser extends Widget {\n    constructor() {\n        super();\n        this.search = null;\n        this.databank = null;\n        this.addClass('nbtools-data-browser');\n        this.layout = new PanelLayout();\n        this.search = new SearchBox('#nbtools-data-browser > .nbtools-databank');\n        this.databank = new Databank(this.search);\n        this.layout.addWidget(this.search);\n        this.layout.addWidget(this.databank);\n    }\n}\nexport class Databank extends Widget {\n    constructor(associated_search) {\n        super();\n        this.last_update = 0;\n        this.update_waiting = false;\n        this.search = associated_search;\n        this.addClass('nbtools-databank');\n        this.addClass('nbtools-wrapper');\n        // Update the databank when the data registry changes\n        ContextManager.data_registry.on_update(() => {\n            // If the last update was more than 3 seconds ago, update the databank\n            if (this.update_stale())\n                this.fill_databank();\n            else\n                this.queue_update(); // Otherwise, queue an update if not already waiting for one\n        });\n        // Fill the databank with the registered data\n        this.fill_databank();\n    }\n    update_stale() {\n        return this.last_update + (3 * 1000) < Date.now();\n    }\n    queue_update() {\n        // If no update is waiting, queue an update\n        if (!this.update_waiting) {\n            setTimeout(() => {\n                this.fill_databank(); // Fill the databank\n                this.update_waiting = false; // And mark as no update queued\n            }, Math.abs(this.last_update + (3 * 1000) - Date.now())); // Queue for 3 seconds since last update\n            this.update_waiting = true; // And mark as queued\n        }\n    }\n    fill_databank() {\n        this.last_update = Date.now();\n        // Gather collapsed origins and groups\n        const collapsed_origins = Array.from(this.node.querySelectorAll('header.nbtools-origin > span.nbtools-collapsed'))\n            .map((n) => { var _a; return (_a = n.parentElement) === null || _a === void 0 ? void 0 : _a.getAttribute('title'); });\n        const collapsed_groups = Array.from(this.node.querySelectorAll('div.nbtools-group > span.nbtools-collapsed'))\n            .map((n) => { var _a, _b; return `${(_a = n.closest('ul.nbtools-origin')) === null || _a === void 0 ? void 0 : _a.getAttribute('title')}||${(_b = n.parentElement) === null || _b === void 0 ? void 0 : _b.getAttribute('title')}`; });\n        // First empty the databank\n        this.empty_databank();\n        // Get the list of data\n        const data = ContextManager.data_registry.list();\n        // Organize by origin and sort\n        const origins = Object.keys(data);\n        origins.sort((a, b) => {\n            const a_name = a.toLowerCase();\n            const b_name = b.toLowerCase();\n            return (a_name < b_name) ? -1 : (a_name > b_name) ? 1 : 0;\n        });\n        // Add each origin\n        origins.forEach((origin) => {\n            const origin_box = this.add_origin(origin);\n            if (collapsed_origins.includes(origin))\n                this.toggle_collapse(origin_box); // Retain collapsed origins\n            const groups = this.origin_groups(data[origin]);\n            Object.keys(groups).reverse().forEach((key) => {\n                this.add_group(origin_box, key, collapsed_groups.includes(`${origin}||${key}`), groups[key].reverse());\n            });\n        });\n        // Apply search filter after refresh\n        this.search.filter(this.search.node.querySelector('input.nbtools-search'));\n    }\n    origin_groups(origin) {\n        const organized = {};\n        // Organize data by group\n        Object.keys(origin).forEach((uri) => {\n            const data = origin[uri][0];\n            if (data.group in organized)\n                organized[data.group].push(data); // Add data to group\n            else\n                organized[data.group] = [data]; // Lazily create group\n        });\n        // Return the organized set of groups\n        return organized;\n    }\n    empty_databank() {\n        this.node.innerHTML = '';\n    }\n    add_origin(name) {\n        // Create the HTML DOM element\n        const origin_wrapper = document.createElement('div');\n        origin_wrapper.innerHTML = `\n            <header class=\"nbtools-origin\" title=\"${name}\">\n                <span class=\"nbtools-expanded nbtools-collapse jp-Icon jp-Icon-16 jp-ToolbarButtonComponent-icon\"></span>\n                ${name}\n            </header>\n            <ul class=\"nbtools-origin\" title=\"${name}\"></ul>`;\n        // Attach the expand / collapse functionality\n        const collapse = origin_wrapper.querySelector('span.nbtools-collapse');\n        collapse.addEventListener(\"click\", () => this.toggle_collapse(origin_wrapper));\n        // Add to the databank\n        this.node.append(origin_wrapper);\n        return origin_wrapper;\n    }\n    add_group(origin, group_name, collapsed, group_data) {\n        const list = origin.querySelector('ul');\n        if (!list)\n            return;\n        const group_wrapper = document.createElement('li');\n        group_wrapper.classList.add('nbtools-tool');\n        group_wrapper.setAttribute('title', 'Click to add to notebook');\n        group_wrapper.innerHTML = `\n            <div class=\"nbtools-add\">+</div>\n            <div class=\"nbtools-header nbtools-group\" title=\"${group_name}\">\n                <span class=\"nbtools-expanded nbtools-collapse jp-Icon jp-Icon-16 jp-ToolbarButtonComponent-icon\"></span>\n                ${group_name}\n            </div>\n            <ul class=\"nbtools-group\"></ul>`;\n        if (collapsed)\n            this.toggle_collapse(group_wrapper); // Retain collapsed groups\n        for (const data of group_data)\n            this.add_data(group_wrapper, data);\n        // Attach the expand / collapse functionality\n        const collapse = group_wrapper.querySelector('span.nbtools-collapse');\n        collapse.addEventListener(\"click\", (event) => {\n            this.toggle_collapse(group_wrapper);\n            event.stopPropagation();\n            return false;\n        });\n        list.append(group_wrapper);\n        // Add the click event\n        group_wrapper.addEventListener(\"click\", () => {\n            Databank.add_group_cell(list.getAttribute('title'), group_name, group_data);\n        });\n        return group_wrapper;\n    }\n    add_data(origin, data) {\n        const group_wrapper = origin.querySelector('ul.nbtools-group');\n        if (!group_wrapper)\n            return;\n        const data_wrapper = document.createElement('a');\n        data_wrapper.setAttribute('href', data.uri);\n        data_wrapper.setAttribute('title', 'Drag to add parameter or cell');\n        data_wrapper.classList.add('nbtools-data');\n        data_wrapper.innerHTML = `<i class=\"${data.icon ? data.icon : 'far fa-bookmark'}\"></i> ${data.label}`;\n        group_wrapper.append(data_wrapper);\n        // Add the click event\n        data_wrapper.addEventListener(\"click\", event => {\n            if (data.widget)\n                Databank.add_data_cell(data.origin, data.uri);\n            event.preventDefault();\n            event.stopPropagation();\n            return false;\n        });\n        // Add the drag event\n        data_wrapper.addEventListener(\"dragstart\", event => {\n            event.dataTransfer.setData(\"text/plain\", data.uri);\n        });\n    }\n    static add_data_cell(origin, data_uri) {\n        // Check to see if nbtools needs to be imported\n        const import_line = ContextManager.tool_registry.needs_import() ? 'import nbtools\\n\\n' : '';\n        // Add and run a code cell with the generated tool code\n        Toolbox.add_code_cell(import_line + `nbtools.data(origin='${escape_quotes(origin)}', uri='${escape_quotes(data_uri)}')`);\n    }\n    static add_group_cell(origin, group_name, group_data) {\n        // Check to see if nbtools needs to be imported\n        const import_line = ContextManager.tool_registry.needs_import() ? 'import nbtools\\n\\n' : '';\n        // Add and run a code cell with the generated tool code\n        const files = group_data.map((d) => `'${d.uri}'`).join(\", \");\n        Toolbox.add_code_cell(import_line + `nbtools.data(origin='${escape_quotes(origin)}', group='${escape_quotes(group_name)}', uris=[${files}])`);\n    }\n    // TODO: Move to utils.ts and refactor so both this and toolbox.ts calls the function?\n    toggle_collapse(origin_wrapper) {\n        const list = origin_wrapper.querySelector(\"ul.nbtools-origin, ul.nbtools-group\");\n        const collapsed = list.classList.contains('nbtools-hidden');\n        // Toggle the collapse button\n        const collapse = origin_wrapper.querySelector('span.nbtools-collapse');\n        if (collapsed) {\n            collapse.classList.add('nbtools-expanded');\n            collapse.classList.remove('nbtools-collapsed');\n        }\n        else {\n            collapse.classList.remove('nbtools-expanded');\n            collapse.classList.add('nbtools-collapsed');\n        }\n        // Hide or show widget body\n        toggle(list);\n    }\n}\n","import { ContextManager } from \"./context\";\nimport { Token } from \"@lumino/coreutils\";\nimport { extract_file_name, extract_file_type } from \"./utils\";\nexport const IDataRegistry = new Token(\"nbtools:IDataRegistry\");\nexport class DataRegistry {\n    // { 'kernel_id': { 'origin': { 'identifier': data } } }\n    /**\n     * Initialize the DataRegistry and connect event handlers\n     */\n    constructor() {\n        this.current = null; // Reference to the currently selected notebook or other widget\n        this.update_callbacks = []; // Callbacks to execute when the cache is updated\n        this.kernel_data_cache = {}; // Keep a cache of kernels to registered data\n        // Lazily assign the data registry to the context\n        if (!ContextManager.data_registry)\n            ContextManager.data_registry = this;\n        ContextManager.context().notebook_focus((current_widget) => {\n            // Current notebook hasn't changed, no need to do anything, return\n            if (this.current === current_widget)\n                return;\n            // Otherwise, update the current notebook reference\n            this.current = current_widget;\n        });\n    }\n    /**\n     * Register all data objects in the provided list\n     *\n     * @param data_list\n     */\n    register_all(data_list) {\n        let all_good = true;\n        for (const data of data_list) {\n            data.skip_callbacks = true;\n            all_good = this.register(data) && all_good;\n        }\n        this.execute_callbacks();\n        return all_good;\n    }\n    /**\n     * Register data for the sent to/come from menus\n     * Return whether registration was successful or not\n     *\n     * @param origin\n     * @param uri\n     * @param label\n     * @param kind\n     * @param group\n     * @param icon\n     * @param data\n     * @param widget\n     * @param skip_callbacks\n     */\n    register({ origin = null, uri = null, label = null, kind = null, group = null, icon = null, data = null, widget = false, skip_callbacks = false }) {\n        // Use origin, identifier, label and kind to initialize data, if needed\n        if (!data)\n            data = new Data(origin, uri, label, kind, group, widget, icon);\n        const kernel_id = this.current_kernel_id();\n        if (!kernel_id)\n            return false; // If no kernel, do nothing\n        // Lazily initialize dict for kernel cache\n        let cache = this.kernel_data_cache[kernel_id];\n        if (!cache)\n            cache = this.kernel_data_cache[kernel_id] = {};\n        // Lazily initialize dict for origin\n        let origin_data = cache[data.origin];\n        if (!origin_data)\n            origin_data = cache[data.origin] = {};\n        // Add to cache, execute callbacks and return\n        if (!origin_data[data.uri])\n            origin_data[data.uri] = [];\n        origin_data[data.uri].unshift(data);\n        if (!skip_callbacks)\n            this.execute_callbacks();\n        return true;\n    }\n    /**\n     * Unregister data with the given origin and identifier\n     * Return the unregistered data object\n     * Return null if un-registration was unsuccessful\n     *\n     * @param origin\n     * @param identifier\n     * @param data\n     */\n    unregister({ origin = null, uri = null, data = null }) {\n        // Use origin, identifier and kind to initialize data, if needed\n        if (!data)\n            data = new Data(origin, uri);\n        const kernel_id = this.current_kernel_id();\n        if (!kernel_id)\n            return null; // If no kernel, do nothing\n        // If unable to retrieve cache, return null\n        const cache = this.kernel_data_cache[kernel_id];\n        if (!cache)\n            return null;\n        // If unable to retrieve origin, return null\n        const origin_data = cache[data.origin];\n        if (!origin_data)\n            return null;\n        // If unable to find identifier, return null;\n        let found = origin_data[data.uri];\n        if (!found || !found.length)\n            return null;\n        // Remove from the registry, execute callbacks and return\n        found = origin_data[data.uri].shift();\n        if (!origin_data[data.uri].length)\n            delete origin_data[data.uri];\n        this.execute_callbacks();\n        return found;\n    }\n    /**\n     * Execute all registered update callbacks\n     */\n    execute_callbacks() {\n        for (const c of this.update_callbacks)\n            c();\n    }\n    /**\n     * Attach a callback that gets executed every time the data in the registry is updated\n     *\n     * @param callback\n     */\n    on_update(callback) {\n        this.update_callbacks.push(callback);\n    }\n    /**\n     * Update the data cache for the current kernel\n     *\n     * @param message\n     */\n    update_data(message) {\n        const kernel_id = this.current_kernel_id();\n        if (!kernel_id)\n            return; // Do nothing if no kernel\n        // Parse the message\n        const data_list = message['data'];\n        // Update the cache\n        this.kernel_data_cache[kernel_id] = {};\n        this.register_all(data_list);\n    }\n    /**\n     * List all data currently in the registry\n     */\n    list() {\n        // If no kernel, return empty map\n        const kernel_id = this.current_kernel_id();\n        if (!kernel_id)\n            return {};\n        // If unable to retrieve cache, return empty map\n        const cache = this.kernel_data_cache[kernel_id];\n        if (!cache)\n            return {};\n        // FORMAT: { 'origin': { 'identifier': [data] } }\n        return cache;\n    }\n    /**\n     * Get all data that matches one of the specified kinds or origins\n     * If kinds or origins is null or empty, accept all kinds or origins, respectively\n     *\n     * @param kinds\n     * @param origins\n     */\n    get_data({ kinds = null, origins = null }) {\n        const kernel_id = this.current_kernel_id();\n        if (!kernel_id)\n            return {}; // If no kernel, return empty\n        // If unable to retrieve cache, return empty\n        const cache = this.kernel_data_cache[kernel_id];\n        if (!cache)\n            return {};\n        // Compile map of data with a matching origin and kind\n        const matching = {};\n        for (let origin of Object.keys(cache)) {\n            if (origins === null || origins.length === 0 || origins.includes(origin)) {\n                const hits = {};\n                for (let data of Object.values(cache[origin])) {\n                    if (data[0].kind === 'error')\n                        continue;\n                    if (kinds === null || kinds.length === 0 || kinds.includes(data[0].kind))\n                        hits[data[0].label] = data[0].uri;\n                }\n                if (Object.keys(hits).length > 0)\n                    matching[origin] = hits;\n            }\n        }\n        return matching;\n    }\n    /**\n     * Retrieve the kernel ID from the currently selected notebook\n     * Return null if no kernel or no notebook selected\n     */\n    current_kernel_id() {\n        return ContextManager.context().kernel_id(this.current);\n    }\n}\nexport class Data {\n    constructor(origin, uri, label = null, kind = null, group = null, widget = false, icon = null) {\n        this.origin = origin;\n        this.uri = uri;\n        this.label = !!label ? label : extract_file_name(uri);\n        this.kind = !!kind ? kind : extract_file_type(uri);\n        this.group = group;\n        this.widget = widget;\n        this.icon = icon;\n    }\n}\n","import { IJupyterWidgetRegistry } from '@jupyter-widgets/base';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { MODULE_NAME, MODULE_VERSION } from './version';\nimport * as base_exports from './basewidget';\nimport * as uioutput_exports from './uioutput';\nimport * as uibuilder_exports from './uibuilder';\nimport { IMainMenu } from '@jupyterlab/mainmenu';\nimport { ToolBrowser, Toolbox } from \"./toolbox\";\nimport { DataBrowser } from \"./databank\";\nimport { IToolRegistry, ToolRegistry } from \"./registry\";\nimport { pulse_red, usage_tracker } from \"./utils\";\nimport { ILabShell, ILayoutRestorer } from \"@jupyterlab/application\";\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { ContextManager } from \"./context\";\nimport { DataRegistry, IDataRegistry } from \"./dataregistry\";\nconst module_exports = Object.assign(Object.assign(Object.assign({}, base_exports), uioutput_exports), uibuilder_exports);\nconst EXTENSION_ID = '@g2nb/nbtools:plugin';\nconst NAMESPACE = 'nbtools';\n/**\n * The nbtools plugin.\n */\nconst nbtools_plugin = {\n    id: EXTENSION_ID,\n    provides: [IToolRegistry, IDataRegistry],\n    requires: [IJupyterWidgetRegistry, ISettingRegistry],\n    optional: [IMainMenu, ILayoutRestorer, ILabShell, INotebookTracker],\n    activate: activate_widget_extension,\n    autoStart: true\n};\nexport default nbtools_plugin;\n/**\n * Activate the widget extension.\n */\nasync function activate_widget_extension(app, widget_registry, settings, mainmenu, restorer, shell, notebook_tracker) {\n    // Initialize the ContextManager\n    init_context(app, notebook_tracker);\n    // Initialize settings\n    const setting_dict = await init_settings(settings);\n    // Create the tool and data registries\n    const tool_registry = new ToolRegistry(setting_dict);\n    const data_registry = new DataRegistry();\n    // Add items to the help menu\n    add_help_links(app, mainmenu);\n    // Add keyboard shortcuts\n    add_keyboard_shortcuts(app, tool_registry);\n    // Add the toolbox\n    add_tool_browser(app, restorer);\n    // Add the databank\n    add_data_browser(app, restorer);\n    // Register the nbtools widgets with the widget registry\n    widget_registry.registerWidget({\n        name: MODULE_NAME,\n        version: MODULE_VERSION,\n        exports: module_exports,\n    });\n    // Register the plugin as loaded\n    usage_tracker('labextension_load', location.protocol + '//' + location.host + location.pathname);\n    // Return the tool registry so that it is provided to other extensions\n    return [tool_registry, data_registry];\n}\nasync function init_settings(settings) {\n    let setting = null;\n    try {\n        setting = await settings.load(EXTENSION_ID);\n    }\n    catch (_a) {\n        console.log('Unable to load nbtools settings');\n    }\n    return { force_render: setting ? setting.get('force_render').composite : true };\n}\nfunction init_context(app, notebook_tracker) {\n    ContextManager.jupyter_app = app;\n    ContextManager.notebook_tracker = notebook_tracker;\n    ContextManager.context();\n    window.ContextManager = ContextManager; // Left in for development purposes\n}\nfunction add_keyboard_shortcuts(app, tool_registry) {\n    app.commands.addCommand(\"nbtools:insert-tool\", {\n        label: 'Insert Notebook Tool',\n        execute: () => {\n            // Open the tool manager, if necessary\n            app.shell.activateById('nbtools-browser');\n            pulse_red(document.getElementById('nbtools-browser'));\n            // If only one tool is available, add it\n            const tools = tool_registry.list();\n            if (tools.length === 1)\n                Toolbox.add_tool_cell(tools[0]);\n            // Otherwise give the search box focus\n            else\n                document.querySelector('.nbtools-search').focus();\n        },\n    });\n}\nfunction add_data_browser(app, restorer) {\n    const data_browser = new DataBrowser();\n    data_browser.title.iconClass = 'nbtools-icon fas fa-database jp-SideBar-tabIcon';\n    data_browser.title.caption = 'Databank';\n    data_browser.id = 'nbtools-data-browser';\n    // Add the data browser widget to the application restorer\n    if (restorer)\n        restorer.add(data_browser, NAMESPACE);\n    app.shell.add(data_browser, 'left', { rank: 103 });\n}\nfunction add_tool_browser(app, restorer) {\n    const tool_browser = new ToolBrowser();\n    tool_browser.title.iconClass = 'nbtools-icon fa fa-th jp-SideBar-tabIcon';\n    tool_browser.title.caption = 'Toolbox';\n    tool_browser.id = 'nbtools-browser';\n    // Add the tool browser widget to the application restorer\n    if (restorer)\n        restorer.add(tool_browser, NAMESPACE);\n    app.shell.add(tool_browser, 'left', { rank: 102 });\n}\n/**\n * Add the nbtools documentation and feedback links to the help menu\n *\n * @param {Application<Widget>} app\n * @param {IMainMenu} mainmenu\n */\nfunction add_help_links(app, mainmenu) {\n    const feedback = 'nbtools:feedback';\n    const documentation = 'nbtools:documentation';\n    // Add feedback command to the command palette\n    app.commands.addCommand(feedback, {\n        label: 'g2nb Help Forum',\n        caption: 'Open the g2nb help forum',\n        isEnabled: () => !!app.shell,\n        execute: () => {\n            const url = 'https://community.mesirovlab.org/c/g2nb/';\n            let element = document.createElement('a');\n            element.href = url;\n            element.target = '_blank';\n            document.body.appendChild(element);\n            element.click();\n            document.body.removeChild(element);\n            return void 0;\n        }\n    });\n    // Add documentation command to the command palette\n    app.commands.addCommand(documentation, {\n        label: 'nbtools Documentation',\n        caption: 'Open documentation for nbtools',\n        isEnabled: () => !!app.shell,\n        execute: () => {\n            const url = 'https://github.com/g2nb/nbtools#nbtools';\n            let element = document.createElement('a');\n            element.href = url;\n            element.target = '_blank';\n            document.body.appendChild(element);\n            element.click();\n            document.body.removeChild(element);\n            return void 0;\n        }\n    });\n    // Add documentation link to the help menu\n    if (mainmenu)\n        mainmenu.helpMenu.addGroup([{ command: feedback }, { command: documentation }], 2);\n}\n"],"names":[],"sourceRoot":""}