- feature: MultiIndex
  schema: >
    User(id)(username) {
      id: Number
      username: String
    }
  tests:
    - test: disallow non-unique multi indexes
      data:
        User:
          - id: 0
            username: a
          - id: 1
            username: b # User 1 and 2 have the same username
          - id: 2
            username: b
      errors:
        - err: NonUniqueSubIndex
          col: username
          row: [1, 2]
- feature: Composite Index
  schema: >
    Date(id)(year, month, day) {
      id: Number
      year: Number
      month: Number
      day: Number
    }
  tests:
    - test: allow unique composite indexes
      data:
        Date:
          - id: 1
            year: 2000
            month: 1
            day: 1
          - id: 1
            year: 2001 # different year
            month: 1
            day: 1
          - id: 1
            year: 2000
            month: 2   # different month
            day: 1
          - id: 1
            year: 2000
            month: 1  
            day: 2     # different day
          - id: 2
            year: 2010
            month: 1
            day: 1
          - id: 3      # duplicate date
            year: 2010
            month: 1
            day: 1
          - id: 4     # nothing wrong with duplicate
            year: 2020
            month: 1
            day: 1
          - id: 4     # nothing wrong with duplicate
            year: 2020
            month: 1
            day: 1
      errors:
        - err: NonUniqueSubIndex
          col: id
          row: [0, 1, 2, 3]
        - err: NonUniqueSubIndex
          col: [year, month, day]
          row: [4, 5]
- feature: Conflicting index detection
  schema: >
    Employee(id1)(id2)(other) {
      id1: Number
      id2: Number
      other: String
    }
  tests:
    - test: dont allow ambiguous index values
      data:
        Employee:
          - id1: 0
            id2: 1000
            other: a
          - id1: 1000   # could get confused with id2 of first row
            id2: 1001
            other: b
          - id1: 2      # allow conflicts if they are not ambiguous
            id2: 2
            other: c
      errors:
        - err: IndexConflict
          col: [id1, id2]
          row: [0, 1]
- feature: Conflicting composite index detection
  schema: >
    Foo(ax,ay)(bx,by) {
      ax: Number
      ay: Number
      bx: Number
      by: Number
    }
  tests:
    - test: dont allow ambiguous index values
      data:
        Foo:
          - ax: 10
            ay: 11
            bx: 20
            by: 21
          - ax: 12
            ay: 13
            bx: 10 # bx/by conflicts with ax/ay of first row 
            by: 11
          - ax: 30 # allow conflicts if they are not ambiguous
            ay: 31
            bx: 30
            by: 31
      errors:
        - err: IndexConflict
          col: [ax, ay, bx, by]
          row: [0, 1]