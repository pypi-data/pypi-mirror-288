from .exceptions import *
import asyncio
import logging
import threading
from .connection_settings import CONNECTION_SETTINGS as CONNECTION_SETTINGS
from .licensing_manager import LucitLicensingManager as LucitLicensingManager, NoValidatedLucitLicense as NoValidatedLucitLicense
from .restclient import BybitWebSocketApiRestclient as BybitWebSocketApiRestclient
from .sockets import BybitWebSocketApiSocket as BybitWebSocketApiSocket
from _typeshed import Incomplete
from typing import Callable, List, Optional, Set, Union
from typing_extensions import Literal

__app_name__: str
__logger__: logging.getLogger
logger = __logger__

class BybitWebSocketApiManager(threading.Thread):
    name: Incomplete
    version: Incomplete
    stop_manager_request: bool
    auto_data_cleanup_stopped_streams: Incomplete
    debug: Incomplete
    lucit_api_secret: Incomplete
    lucit_license_ini: Incomplete
    lucit_license_profile: Incomplete
    lucit_license_token: Incomplete
    llm: Incomplete
    disable_colorama: Incomplete
    specific_process_asyncio_queue: Incomplete
    specific_process_stream_data: Incomplete
    specific_process_stream_data_async: Incomplete
    process_asyncio_queue: Incomplete
    process_stream_data: Incomplete
    process_stream_data_async: Incomplete
    process_stream_signals: Incomplete
    enable_stream_signal_buffer: Incomplete
    exchange: Incomplete
    stream_list: Incomplete
    stream_list_lock: Incomplete
    websocket_base_uri: Incomplete
    api_version: Incomplete
    args_limit: Incomplete
    max_subscriptions_per_stream_spot: Incomplete
    max_subscriptions_per_stream_linear: Incomplete
    max_subscriptions_per_stream_inverse: Incomplete
    max_subscriptions_per_stream_option: Incomplete
    socks5_proxy_server: Incomplete
    socks5_proxy_address: Incomplete
    socks5_proxy_user: Incomplete
    socks5_proxy_pass: Incomplete
    socks5_proxy_port: Incomplete
    socks5_proxy_ssl_verification: Incomplete
    websocket_ssl_context: Incomplete
    asyncio_queue: Incomplete
    all_subscriptions_number: int
    bybit_api_status: Incomplete
    event_loops: Incomplete
    frequent_checks_list: Incomplete
    frequent_checks_list_lock: Incomplete
    receiving_speed_average: int
    receiving_speed_peak: Incomplete
    high_performance: Incomplete
    keep_max_received_last_second_entries: int
    keepalive_streams_list: Incomplete
    last_entry_added_to_stream_buffer: int
    last_monitoring_check: Incomplete
    last_update_check_github: Incomplete
    last_update_check_github_check_command: Incomplete
    listen_key_refresh_interval: Incomplete
    max_send_messages_per_second: int
    max_send_messages_per_second_reserve: int
    most_receives_per_second: int
    monitoring_api_server: Incomplete
    monitoring_total_received_bytes: int
    monitoring_total_receives: int
    output_default: Incomplete
    process_response: Incomplete
    process_response_lock: Incomplete
    reconnects: int
    reconnects_lock: Incomplete
    request_id: int
    request_id_lock: Incomplete
    restart_timeout: Incomplete
    return_response: Incomplete
    return_response_lock: Incomplete
    ringbuffer_error: Incomplete
    ringbuffer_error_max_size: int
    ringbuffer_result: Incomplete
    ringbuffer_result_max_size: int
    show_secrets_in_logs: Incomplete
    start_time: Incomplete
    stream_buffer_maxlen: Incomplete
    stream_buffer: Incomplete
    stream_buffer_lock: Incomplete
    stream_buffer_locks: Incomplete
    stream_buffers: Incomplete
    stream_signal_buffer: Incomplete
    stream_signal_buffer_lock: Incomplete
    socket_is_ready: Incomplete
    sockets: Incomplete
    stream_threads: Incomplete
    total_received_bytes: int
    total_received_bytes_lock: Incomplete
    total_receives: int
    total_receives_lock: Incomplete
    total_transmitted: int
    total_transmitted_lock: Incomplete
    close_timeout_default: Incomplete
    ping_interval_default: Incomplete
    ping_timeout_default: Incomplete
    replacement_text: str
    warn_on_update: Incomplete
    restclient: Incomplete
    def __init__(self, process_stream_data: Optional[Callable] = ..., process_stream_data_async: Optional[Callable] = ..., process_asyncio_queue: Optional[Callable] = ..., exchange: str = ..., warn_on_update: bool = ..., restart_timeout: int = ..., show_secrets_in_logs: bool = ..., output_default: Optional[Literal['dict', 'raw_data']] = ..., enable_stream_signal_buffer: bool = ..., disable_colorama: bool = ..., stream_buffer_maxlen: Optional[int] = ..., process_stream_signals: Incomplete | None = ..., close_timeout_default: int = ..., ping_interval_default: int = ..., ping_timeout_default: int = ..., high_performance: bool = ..., debug: bool = ..., restful_base_uri: str = ..., websocket_base_uri: str = ..., max_subscriptions_per_stream_spot: Optional[int] = ..., max_subscriptions_per_stream_linear: Optional[int] = ..., max_subscriptions_per_stream_inverse: Optional[int] = ..., max_subscriptions_per_stream_option: Optional[int] = ..., socks5_proxy_server: str = ..., socks5_proxy_user: str = ..., socks5_proxy_pass: str = ..., socks5_proxy_ssl_verification: bool = ..., auto_data_cleanup_stopped_streams: bool = ..., lucit_api_secret: str = ..., lucit_license_ini: str = ..., lucit_license_profile: str = ..., lucit_license_token: str = ...) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_value, error_traceback) -> None: ...
    async def get_stream_data_from_asyncio_queue(self, stream_id: Incomplete | None = ...): ...
    def asyncio_queue_task_done(self, stream_id: Incomplete | None = ...) -> bool: ...
    def send_stream_signal(self, signal_type: Incomplete | None = ..., stream_id: Incomplete | None = ..., data_record: Incomplete | None = ..., error_msg: Incomplete | None = ...) -> bool: ...
    def send_with_stream(self, stream_id: str = ..., payload: Union[dict, str] = ..., timeout: float = ...) -> bool: ...
    def generate_signature(self, api_secret: Incomplete | None = ..., data: Incomplete | None = ...): ...
    @staticmethod
    def order_params(data): ...
    def add_payload_to_stream(self, stream_id: Incomplete | None = ..., payload: dict = ...): ...
    def add_to_ringbuffer_error(self, error): ...
    def add_to_ringbuffer_result(self, result): ...
    def add_to_stream_buffer(self, stream_data, stream_buffer_name: Union[Literal[False], str] = ...): ...
    def add_to_stream_signal_buffer(self, signal_type: Incomplete | None = ..., stream_id: Incomplete | None = ..., data_record: Incomplete | None = ..., error_msg: Incomplete | None = ...): ...
    def add_total_received_bytes(self, size) -> None: ...
    def clear_asyncio_queue(self, stream_id: str = ...) -> bool: ...
    def clear_stream_buffer(self, stream_buffer_name: Union[Literal[False], str] = ...): ...
    def create_payload(self, stream_id, method, channels: Incomplete | None = ..., markets: Incomplete | None = ...): ...
    def create_stream(self, channels: Union[str, List[str], Set[str], None] = ..., endpoint: str = ..., markets: Union[str, List[str], Set[str], None] = ..., stream_label: str = ..., stream_buffer_name: Union[Literal[False], str] = ..., api_key: str = ..., api_secret: str = ..., output: Optional[Literal['dict', 'raw_data']] = ..., ping_interval: int = ..., ping_timeout: int = ..., close_timeout: int = ..., stream_buffer_maxlen: int = ..., process_stream_data: Optional[Callable] = ..., process_stream_data_async: Optional[Callable] = ..., process_asyncio_queue: Optional[Callable] = ...): ...
    def create_websocket_uri(self, channels: Incomplete | None = ..., endpoint: Incomplete | None = ..., markets: Incomplete | None = ..., stream_id: Incomplete | None = ...) -> str: ...
    def delete_listen_key_by_stream_id(self, stream_id) -> bool: ...
    def delete_stream_from_stream_list(self, stream_id, timeout: float = ...) -> bool: ...
    def remove_all_data_of_stream_id(self, stream_id, timeout: float = ...) -> bool: ...
    @staticmethod
    def fill_up_space_left(demand_of_chars, string, filling: str = ...): ...
    @staticmethod
    def fill_up_space_centered(demand_of_chars, string, filling: str = ...): ...
    @staticmethod
    def fill_up_space_right(demand_of_chars, string, filling: str = ...): ...
    def get_active_stream_list(self): ...
    def get_all_receives_last_second(self): ...
    def get_bybit_api_status(self): ...
    def get_debug_log(self): ...
    @staticmethod
    def get_timestamp() -> int: ...
    @staticmethod
    def get_timestamp_unix() -> float: ...
    def get_used_weight(self): ...
    def get_current_receiving_speed(self, stream_id): ...
    def get_current_receiving_speed_global(self): ...
    @staticmethod
    def get_date_of_timestamp(timestamp): ...
    def get_errors_from_endpoints(self): ...
    def get_event_loop_by_stream_id(self, stream_id: Optional[Union[str, bool]] = ...) -> Optional[asyncio.AbstractEventLoop]: ...
    def get_exchange(self): ...
    @staticmethod
    def get_human_bytesize(amount_bytes, suffix: str = ...): ...
    @staticmethod
    def get_human_uptime(uptime): ...
    @staticmethod
    def get_latest_release_info(): ...
    @staticmethod
    def get_latest_release_info_check_command(): ...
    def get_latest_version(self) -> Optional[str]: ...
    def get_latest_version_check_command(self) -> Optional[str]: ...
    def get_limit_of_subscriptions_per_stream(self): ...
    def get_number_of_all_subscriptions(self): ...
    def get_most_receives_per_second(self): ...
    def get_number_of_streams_in_stream_list(self): ...
    def get_number_of_subscriptions(self, stream_id): ...
    def get_keep_max_received_last_second_entries(self): ...
    @staticmethod
    def get_new_uuid_id() -> str: ...
    def get_process_usage_memory(self): ...
    @staticmethod
    def get_process_usage_cpu(): ...
    @staticmethod
    def get_process_usage_threads(): ...
    def get_reconnects(self): ...
    def get_request_id(self): ...
    def get_result_by_request_id(self, request_id: Incomplete | None = ..., timeout: int = ...): ...
    def get_results_from_endpoints(self): ...
    def get_ringbuffer_error_max_size(self): ...
    def get_ringbuffer_result_max_size(self): ...
    def get_start_time(self): ...
    def get_stream_buffer_byte_size(self): ...
    def get_stream_buffer_length(self, stream_buffer_name: Union[Literal[False], str] = ...): ...
    def get_stream_id_by_label(self, stream_label: str = ...) -> Optional[str]: ...
    def get_stream_info(self, stream_id): ...
    def get_stream_label(self, stream_id: Incomplete | None = ...): ...
    def get_stream_subscriptions(self, stream_id, request_id: Incomplete | None = ...): ...
    def get_stream_list(self): ...
    def get_stream_buffer_maxlen(self, stream_buffer_name: Union[Literal[False], str] = ...): ...
    def get_stream_receives_last_second(self, stream_id): ...
    def get_stream_statistic(self, stream_id): ...
    def get_the_one_active_websocket_api(self) -> Optional[str]: ...
    def get_total_received_bytes(self): ...
    def get_total_receives(self): ...
    def get_user_agent(self): ...
    def get_version(self): ...
    @staticmethod
    def help() -> None: ...
    def increase_received_bytes_per_second(self, stream_id, size) -> None: ...
    def increase_processed_receives_statistic(self, stream_id): ...
    def increase_reconnect_counter(self, stream_id: Incomplete | None = ...) -> None: ...
    def increase_transmitted_counter(self, stream_id) -> None: ...
    def is_manager_stopping(self): ...
    def is_crash_request(self, stream_id) -> bool: ...
    def is_stop_request(self, stream_id) -> bool: ...
    def is_stream_signal_buffer_enabled(self): ...
    def is_update_available(self): ...
    def is_update_available_check_command(self, check_command_version: Incomplete | None = ...): ...
    def pop_stream_data_from_stream_buffer(self, stream_buffer_name: Union[Literal[False], str] = ..., mode: str = ...): ...
    def pop_stream_signal_from_stream_signal_buffer(self): ...
    def print_stream_info(self, stream_id: str = ..., add_string: str = ..., footer: str = ..., title: str = ...): ...
    def print_summary(self, add_string: str = ..., disable_print: bool = ..., footer: str = ..., title: str = ...): ...
    def print_summary_to_png(self, print_summary_export_path, height_per_row: float = ..., add_string: str = ..., footer: str = ..., title: str = ...): ...
    @staticmethod
    def remove_ansi_escape_codes(text): ...
    def replace_stream(self, stream_id, new_channels, new_markets, new_stream_label: Incomplete | None = ..., new_stream_buffer_name: Union[Literal[False], str] = ..., new_api_key: Incomplete | None = ..., new_api_secret: Incomplete | None = ..., new_symbols: Incomplete | None = ..., new_output: Optional[Literal['dict', 'raw_data']] = ..., new_ping_interval: int = ..., new_ping_timeout: int = ..., new_close_timeout: int = ..., new_stream_buffer_maxlen: Incomplete | None = ...): ...
    def run(self) -> None: ...
    def set_heartbeat(self, stream_id) -> None: ...
    def set_stop_request(self, stream_id: Incomplete | None = ...): ...
    def set_ringbuffer_error_max_size(self, max_size) -> None: ...
    def set_ringbuffer_result_max_size(self, max_size) -> None: ...
    def is_socket_ready(self, stream_id: str = ...) -> bool: ...
    def set_socket_is_not_ready(self, stream_id: str) -> bool: ...
    def set_socket_is_ready(self, stream_id: str) -> bool: ...
    def set_stream_label(self, stream_id, stream_label: Incomplete | None = ...) -> bool: ...
    def set_keep_max_received_last_second_entries(self, number_of_max_entries) -> None: ...
    def split_payload(self, params, method, max_items_per_request: int = ...): ...
    def stop_manager(self, close_api_session: bool = ...): ...
    def stop_manager_with_all_streams(self, close_api_session: bool = ...): ...
    def stop_monitoring_api(self) -> bool: ...
    def stop_stream(self, stream_id, delete_listen_key: bool = ...): ...
    def subscribe_to_stream(self, stream_id: str = ..., channels: Incomplete | None = ..., markets: Incomplete | None = ...) -> bool: ...
    def unsubscribe_from_stream(self, stream_id: str = ..., channels: Incomplete | None = ..., markets: Incomplete | None = ...) -> bool: ...
    def wait_till_stream_has_started(self, stream_id, timeout: float = ...) -> bool: ...
    def wait_till_stream_has_stopped(self, stream_id: str = ..., timeout: float = ...) -> bool: ...
