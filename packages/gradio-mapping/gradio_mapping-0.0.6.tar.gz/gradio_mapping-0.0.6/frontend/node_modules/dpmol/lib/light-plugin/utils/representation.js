"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMeasurementProps = exports.removeElementIdsInRepresentation = exports.overlapRepresentationByElementIds = exports.isCellItemIntersectCellItem = exports.isRepresentationIntersectElementIds = void 0;
var loci_1 = require("../../mol-model/structure/structure/element/loci");
var types_1 = require("../types");
var loci_2 = require("./loci");
var structure_1 = require("./structure");
var representation_1 = require("../representation");
var index_1 = require("../index");
// export const isRepresentationIntersectElementIds = (
//   representation: Representation<any>,
//   elementIds: number[]
// ) => {
//   const lociA = transformLociToElementLoci(representation.getLoci())
//   if (!lociA) return []
//   const lociB = getLoci(lociA?.structure, elementIds)
//   if (
//     (elementIds.length && !lociB.elements.length) || // 当前representation中不包含对应的elementIds
//     !ElementLoci.areIntersecting(lociA, lociB)
//   ) {
//     return Intersection.Not
//   }
//   if (
//     ElementLoci.areEqual(lociA, lociB) ||
//     ElementLoci.isSubset(lociA, lociB)
//   ) {
//     return Intersection.Include
//   }
//   if (ElementLoci.isSubset(lociB, lociA)) {
//     return Intersection.BeIncluded
//   }
//   return Intersection.Cross
// }
var isRepresentationIntersectElementIds = function (representation, elementIds) {
    var _a, _b, _c;
    var lociA = (0, loci_2.transformLociToElementLoci)(representation.getLoci());
    if (!lociA || !((_c = (_b = (_a = lociA === null || lociA === void 0 ? void 0 : lociA.elements) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.unit) === null || _c === void 0 ? void 0 : _c.elements))
        return types_1.Intersection.Not;
    var reprElementIdSet = new Set((0, loci_2.getElementIdsByLoci)(lociA));
    var matched = 0;
    elementIds.forEach(function (elementId) {
        if (reprElementIdSet.has(elementId))
            matched++;
    });
    if (!matched)
        return types_1.Intersection.Not;
    if (matched === elementIds.length)
        return types_1.Intersection.Include;
    if (matched === reprElementIdSet.size)
        return types_1.Intersection.BeIncluded;
    return types_1.Intersection.Cross;
};
exports.isRepresentationIntersectElementIds = isRepresentationIntersectElementIds;
var isCellItemIntersectCellItem = function (itemA, itemB) {
    var _a, _b;
    if (itemA.ref !== itemB.ref)
        return false;
    if (!((_a = itemA.elementIds) === null || _a === void 0 ? void 0 : _a.length) || !((_b = itemB.elementIds) === null || _b === void 0 ? void 0 : _b.length))
        return true;
    var elementSet = new Set(itemB.elementIds);
    return itemA.elementIds.some(function (elementId) { return elementSet.has(elementId); });
};
exports.isCellItemIntersectCellItem = isCellItemIntersectCellItem;
// 当前Representation与elementId重合的部分
var overlapRepresentationByElementIds = function (representation, elementIds) {
    var lociA = (0, loci_2.transformLociToElementLoci)(representation.getLoci());
    if (!lociA)
        return [];
    var lociB = (0, loci_2.getLoci)(lociA === null || lociA === void 0 ? void 0 : lociA.structure, elementIds);
    var intersectLoci = loci_1.Loci.intersect(lociA, lociB);
    return (0, loci_2.getElementIdsByLoci)(intersectLoci);
};
exports.overlapRepresentationByElementIds = overlapRepresentationByElementIds;
var removeElementIdsInRepresentation = function (representation, elementIds, type, getNewTheme, getTransparency) {
    var sourceStructure = (0, structure_1.getStructureFromRepresentation)(representation);
    if (!sourceStructure) {
        console.warn('removeElementIdsInRepresentation');
        return;
    }
    var structure = (0, structure_1.removeStructureByElementIds)(sourceStructure, elementIds);
    representation_1.MolecularRepresentation[type].update(representation, structure, index_1.lightPlugin.managers.representation.ctx, getNewTheme ? getNewTheme(structure) : representation.theme);
    if (getTransparency) {
        representation.setState({
            transparency: getTransparency(structure)
        });
    }
    return representation;
};
exports.removeElementIdsInRepresentation = removeElementIdsInRepresentation;
// 大部分参数目前没有开放，暂时不存
var MeasurementReprPropKeys = (_a = {},
    // 'customText', 'textColor', 'textSize', 'borderWidth', 'borderColor', 'background', 'backgroundColor', 'alpha', 'attachment'
    _a[types_1.RepresentationType.Label] = ['customText', 'textColor', 'textSize'],
    // 'alpha', 'lineColor', 'linesSize', 'dashLength', 'unitLabel', 'customText'
    _a[types_1.RepresentationType.Distance] = ['linesColor', 'textSize', 'textColor'],
    // 'color', 'arcScale', 'sectorOpacity', 'linesSize', 'dashLength', 'customText'
    _a[types_1.RepresentationType.Angle] = ['color', 'textSize', 'textColor'],
    // 'color', 'arcScale', 'sectorOpacity', 'linesSize', 'dashLength', 'customText'
    _a[types_1.RepresentationType.Dihedral] = ['color', 'textSize', 'textColor'],
    _a);
var getMeasurementProps = function (reprType, repr) {
    if (!types_1.MeasurementType.has(reprType)) {
        return;
    }
    var res = {};
    MeasurementReprPropKeys[reprType].forEach(function (key) { res[key] = repr.props[key]; });
    return res;
};
exports.getMeasurementProps = getMeasurementProps;
//# sourceMappingURL=representation.js.map