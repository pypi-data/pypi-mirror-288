"use strict";
/**
 * Copyright (c) 2018-2022 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author Aliaksei Chareshneu <chareshneu.tech@gmail.com>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuiltInVolumeFormats = exports.Ccp4Provider = exports.VolumeFormatCategory = void 0;
var tslib_1 = require("tslib");
var transforms_1 = require("../transforms");
var provider_1 = require("./provider");
var volume_1 = require("../../mol-model/volume");
var volume_representation_params_1 = require("../helpers/volume-representation-params");
var property_1 = require("../../mol-model-formats/volume/property");
var util_1 = require("../../mol-plugin/behavior/dynamic/volume-streaming/util");
var mol_task_1 = require("../../mol-task");
exports.VolumeFormatCategory = 'Volume';
function tryObtainRecommendedIsoValue(plugin, volume) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var entryId;
        var _this = this;
        return (0, tslib_1.__generator)(this, function (_a) {
            if (!volume)
                return [2 /*return*/];
            entryId = volume.entryId;
            if (!entryId || !entryId.toLowerCase().startsWith('emd'))
                return [2 /*return*/];
            return [2 /*return*/, plugin.runTask(mol_task_1.Task.create('Try Set Recommended IsoValue', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                    var absIsoLevel, e_1;
                    return (0, tslib_1.__generator)(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                _a.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, (0, util_1.getContourLevelEmdb)(plugin, ctx, entryId)];
                            case 1:
                                absIsoLevel = _a.sent();
                                property_1.RecommendedIsoValue.Provider.set(volume, volume_1.Volume.IsoValue.absolute(absIsoLevel));
                                return [3 /*break*/, 3];
                            case 2:
                                e_1 = _a.sent();
                                console.warn(e_1);
                                return [3 /*break*/, 3];
                            case 3: return [2 /*return*/];
                        }
                    });
                }); }))];
        });
    });
}
function tryGetRecomendedIsoValue(volume) {
    var recommendedIsoValue = property_1.RecommendedIsoValue.Provider.get(volume);
    if (!recommendedIsoValue)
        return;
    if (recommendedIsoValue.kind === 'relative')
        return recommendedIsoValue;
    return volume_1.Volume.adjustedIsoValue(volume, recommendedIsoValue.absoluteValue, 'absolute');
}
function defaultVisuals(plugin, data) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var typeParams, isoValue, visual;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    typeParams = {};
                    isoValue = data.volume.data && tryGetRecomendedIsoValue(data.volume.data);
                    if (isoValue)
                        typeParams.isoValue = isoValue;
                    visual = plugin.build().to(data.volume).apply(transforms_1.StateTransforms.Representation.VolumeRepresentation3D, (0, volume_representation_params_1.createVolumeRepresentationParams)(plugin, data.volume.data, {
                        type: 'isosurface',
                        typeParams: typeParams,
                    }));
                    return [4 /*yield*/, visual.commit()];
                case 1: return [2 /*return*/, [_a.sent()]];
            }
        });
    });
}
exports.Ccp4Provider = (0, provider_1.DataFormatProvider)({
    label: 'CCP4/MRC/MAP',
    description: 'CCP4/MRC/MAP',
    category: exports.VolumeFormatCategory,
    binaryExtensions: ['ccp4', 'mrc', 'map'],
    parse: function (plugin, data, params) { return (0, tslib_1.__awaiter)(void 0, void 0, void 0, function () {
        var format, volume;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    format = plugin.build()
                        .to(data)
                        .apply(transforms_1.StateTransforms.Data.ParseCcp4, {}, { state: { isGhost: true } });
                    volume = format.apply(transforms_1.StateTransforms.Volume.VolumeFromCcp4, { entryId: params === null || params === void 0 ? void 0 : params.entryId });
                    return [4 /*yield*/, format.commit({ revertOnError: true })];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, tryObtainRecommendedIsoValue(plugin, volume.selector.data)];
                case 2:
                    _a.sent();
                    return [2 /*return*/, { format: format.selector, volume: volume.selector }];
            }
        });
    }); },
    visuals: defaultVisuals
});
// export const Dsn6Provider = DataFormatProvider({
//     label: 'DSN6/BRIX',
//     description: 'DSN6/BRIX',
//     category: VolumeFormatCategory,
//     binaryExtensions: ['dsn6', 'brix'],
//     parse: async (plugin, data, params?: Params) => {
//         const format = plugin.build()
//             .to(data)
//             .apply(StateTransforms.Data.ParseDsn6, {}, { state: { isGhost: true } });
//         const volume = format.apply(StateTransforms.Volume.VolumeFromDsn6, { entryId: params?.entryId });
//         await format.commit({ revertOnError: true });
//         await tryObtainRecommendedIsoValue(plugin, volume.selector.data);
//         return { format: format.selector, volume: volume.selector };
//     },
//     visuals: defaultVisuals
// });
// export const DxProvider = DataFormatProvider({
//     label: 'DX',
//     description: 'DX',
//     category: VolumeFormatCategory,
//     stringExtensions: ['dx'],
//     binaryExtensions: ['dxbin'],
//     parse: async (plugin, data, params?: Params) => {
//         const format = plugin.build()
//             .to(data)
//             .apply(StateTransforms.Data.ParseDx, {}, { state: { isGhost: true } });
//         const volume = format.apply(StateTransforms.Volume.VolumeFromDx, { entryId: params?.entryId });
//         await volume.commit({ revertOnError: true });
//         await tryObtainRecommendedIsoValue(plugin, volume.selector.data);
//         return { volume: volume.selector };
//     },
//     visuals: defaultVisuals
// });
// export const CubeProvider = DataFormatProvider({
//     label: 'Cube',
//     description: 'Cube',
//     category: VolumeFormatCategory,
//     stringExtensions: ['cub', 'cube'],
//     parse: async (plugin, data, params?: Params) => {
//         const format = plugin.build()
//             .to(data)
//             .apply(StateTransforms.Data.ParseCube, {}, { state: { isGhost: true } });
//         const volume = format.apply(StateTransforms.Volume.VolumeFromCube, { entryId: params?.entryId });
//         const structure = format
//             .apply(StateTransforms.Model.TrajectoryFromCube, void 0, { state: { isGhost: true } })
//             .apply(StateTransforms.Model.ModelFromTrajectory)
//             .apply(StateTransforms.Model.StructureFromModel);
//         await format.commit({ revertOnError: true });
//         await tryObtainRecommendedIsoValue(plugin, volume.selector.data);
//         return { format: format.selector, volume: volume.selector, structure: structure.selector };
//     },
//     visuals: async (plugin: PluginContext, data: { volume: StateObjectSelector<PluginStateObject.Volume.Data>, structure: StateObjectSelector<PluginStateObject.Molecule.Structure> }) => {
//         const surfaces = plugin.build();
//         const volumeReprs: StateObjectSelector<PluginStateObject.Volume.Representation3D>[] = [];
//         const volumeData = data.volume.cell?.obj?.data;
//         if (volumeData && Volume.isOrbitals(volumeData)) {
//             const volumePos = surfaces.to(data.volume).apply(StateTransforms.Representation.VolumeRepresentation3D, createVolumeRepresentationParams(plugin, volumeData, {
//                 type: 'isosurface',
//                 typeParams: { isoValue: Volume.IsoValue.relative(1), alpha: 0.4 },
//                 color: 'uniform',
//                 colorParams: { value: ColorNames.blue }
//             }));
//             const volumeNeg = surfaces.to(data.volume).apply(StateTransforms.Representation.VolumeRepresentation3D, createVolumeRepresentationParams(plugin, volumeData, {
//                 type: 'isosurface',
//                 typeParams: { isoValue: Volume.IsoValue.relative(-1), alpha: 0.4 },
//                 color: 'uniform',
//                 colorParams: { value: ColorNames.red }
//             }));
//             volumeReprs.push(volumePos.selector, volumeNeg.selector);
//         } else {
//             const volume = surfaces.to(data.volume).apply(StateTransforms.Representation.VolumeRepresentation3D, createVolumeRepresentationParams(plugin, volumeData, {
//                 type: 'isosurface',
//                 typeParams: { isoValue: Volume.IsoValue.relative(2), alpha: 0.4 },
//                 color: 'uniform',
//                 colorParams: { value: ColorNames.grey }
//             }));
//             volumeReprs.push(volume.selector);
//         }
//         const structure = await plugin.builders.structure.representation.applyPreset(data.structure, 'auto');
//         await surfaces.commit();
//         const structureReprs: StateObjectSelector<PluginStateObject.Molecule.Structure.Representation3D>[] = [];
//         objectForEach(structure?.representations as any, (r: any) => {
//             if (r) structureReprs.push(r);
//         });
//         return [...volumeReprs, ...structureReprs];
//     }
// });
// type DsCifParams = { entryId?: string | string[] };
// export const DscifProvider = DataFormatProvider({
//     label: 'DensityServer CIF',
//     description: 'DensityServer CIF',
//     category: VolumeFormatCategory,
//     stringExtensions: ['cif'],
//     binaryExtensions: ['bcif'],
//     isApplicable: (info, data) => {
//         return guessCifVariant(info, data) === 'dscif' ? true : false;
//     },
//     parse: async (plugin, data, params?: DsCifParams) => {
//         const cifCell = await plugin.build().to(data).apply(StateTransforms.Data.ParseCif).commit();
//         const b = plugin.build().to(cifCell);
//         const blocks = cifCell.obj!.data.blocks;
//         if (blocks.length === 0) throw new Error('no data blocks');
//         const volumes: StateObjectSelector<PluginStateObject.Volume.Data>[] = [];
//         let i = 0;
//         for (const block of blocks) {
//             // Skip "server" data block.
//             if (block.header.toUpperCase() === 'SERVER') continue;
//             const entryId = Array.isArray(params?.entryId) ? params?.entryId[i] : params?.entryId;
//             if (block.categories['volume_data_3d_info']?.rowCount > 0) {
//                 volumes.push(b.apply(StateTransforms.Volume.VolumeFromDensityServerCif, { blockHeader: block.header, entryId }).selector);
//                 i++;
//             }
//         }
//         await b.commit();
//         for (const v of volumes) await tryObtainRecommendedIsoValue(plugin, v.data);
//         return { volumes };
//     },
//     visuals: async (plugin, data: { volumes: StateObjectSelector<PluginStateObject.Volume.Data>[] }) => {
//         const { volumes } = data;
//         const tree = plugin.build();
//         const visuals: StateObjectSelector<PluginStateObject.Volume.Representation3D>[] = [];
//         if (volumes.length > 0) {
//             const isoValue = (volumes[0].data && tryGetRecomendedIsoValue(volumes[0].data)) || Volume.IsoValue.relative(1.5);
//             visuals[0] = tree
//                 .to(volumes[0])
//                 .apply(StateTransforms.Representation.VolumeRepresentation3D, VolumeRepresentation3DHelpers.getDefaultParamsStatic(plugin, 'isosurface', { isoValue, alpha: 1 }, 'uniform', { value: ColorNames.teal }))
//                 .selector;
//         }
//         if (volumes.length > 1) {
//             const posParams = VolumeRepresentation3DHelpers.getDefaultParamsStatic(plugin, 'isosurface', { isoValue: Volume.IsoValue.relative(3), alpha: 0.3 }, 'uniform', { value: ColorNames.green });
//             const negParams = VolumeRepresentation3DHelpers.getDefaultParamsStatic(plugin, 'isosurface', { isoValue: Volume.IsoValue.relative(-3), alpha: 0.3 }, 'uniform', { value: ColorNames.red });
//             visuals[visuals.length] = tree.to(volumes[1]).apply(StateTransforms.Representation.VolumeRepresentation3D, posParams).selector;
//             visuals[visuals.length] = tree.to(volumes[1]).apply(StateTransforms.Representation.VolumeRepresentation3D, negParams).selector;
//         }
//         await tree.commit();
//         return visuals;
//     }
// });
exports.BuiltInVolumeFormats = [
    ['ccp4', exports.Ccp4Provider],
    // ['dsn6', Dsn6Provider] as const,
    // ['cube', CubeProvider] as const,
    // ['dx', DxProvider] as const,
    // ['dscif', DscifProvider] as const,
];
//# sourceMappingURL=volume.js.map