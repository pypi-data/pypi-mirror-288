"use strict";
/**
 * Copyright (c) 2019-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author Fred Ludlow <Fred.Ludlow@astx.com>
 *
 * based in part on NGL (https://github.com/arose/ngl)
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WeakHydrogenBondsProvider = exports.HydrogenBondsProvider = exports.HydrogenAcceptorProvider = exports.WeakHydrogenDonorProvider = exports.HydrogenDonorProvider = exports.DefaultWeakHydrogenBondsParams = exports.DefaultHydrogenBondsParams = void 0;
var tslib_1 = require("tslib");
var param_definition_1 = require("../../../mol-util/param-definition");
var geometry_1 = require("../chemistry/geometry");
var features_1 = require("./features");
var util_1 = require("../chemistry/util");
var valence_model_1 = require("../valence-model");
var misc_1 = require("../../../mol-math/misc");
var common_1 = require("./common");
var types_1 = require("../../../mol-model/structure/model/types");
var GeometryParams = {
    distanceMax: param_definition_1.ParamDefinition.Numeric(2.8, { min: 1, max: 5, step: 0.1 }),
    backbone: param_definition_1.ParamDefinition.Boolean(true, {
        description: 'Include backbone-to-backbone hydrogen bonds'
    }),
    accAngleDevMax: param_definition_1.ParamDefinition.Numeric(90, { min: 0, max: 180, step: 1 }, { description: 'Max deviation from ideal acceptor angle' }),
    donAngleDevMax: param_definition_1.ParamDefinition.Numeric(120, { min: 0, max: 180, step: 1 }, { description: 'Max deviation from ideal donor angle' }),
    accOutOfPlaneAngleMax: param_definition_1.ParamDefinition.Numeric(90, { min: 0, max: 180, step: 1 }),
    donOutOfPlaneAngleMax: param_definition_1.ParamDefinition.Numeric(45, { min: 0, max: 180, step: 1 })
};
var HydrogenBondsParams = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, GeometryParams), { water: param_definition_1.ParamDefinition.Boolean(false, {
        description: 'Include water-to-water hydrogen bonds'
    }), sulfurDistanceMax: param_definition_1.ParamDefinition.Numeric(3.4, { min: 1, max: 5, step: 0.1 }) });
exports.DefaultHydrogenBondsParams = param_definition_1.ParamDefinition.getDefaultValues(HydrogenBondsParams);
var WeakHydrogenBondsParams = (0, tslib_1.__assign)({}, GeometryParams);
exports.DefaultWeakHydrogenBondsParams = param_definition_1.ParamDefinition.getDefaultValues(WeakHydrogenBondsParams);
//
// Geometric characteristics of hydrogen bonds involving sulfur atoms in proteins
// https://doi.org/10.1002/prot.22327
// Satisfying Hydrogen Bonding Potential in Proteins (HBPLUS)
// https://doi.org/10.1006/jmbi.1994.1334
// http://www.csb.yale.edu/userguides/datamanip/hbplus/hbplus_descrip.html
function getUnitValenceModel(structure, unit) {
    var valenceModel = valence_model_1.ValenceModelProvider.get(structure).value;
    if (!valenceModel)
        throw Error('expected valence model to be available');
    var unitValenceModel = valenceModel.get(unit.id);
    if (!unitValenceModel)
        throw Error('expected valence model for unit to be available');
    return unitValenceModel;
}
/**
 * Potential hydrogen donor
 */
function addUnitHydrogenDonors(structure, unit, builder) {
    var elements = unit.elements;
    var _a = unit.model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;
    var _loop_1 = function (i, il) {
        var element = (0, util_1.typeSymbol)(unit, i);
        var isAdd = false;
        if (element === "H" /* H */) {
            (0, util_1.eachIntraBondedAtom)(unit, i, function (unit, index) {
                var bondedAtomElement = (0, util_1.typeSymbol)(unit, index);
                if (bondedAtomElement === "N" /* N */ ||
                    bondedAtomElement === "O" /* O */ ||
                    bondedAtomElement === "S" /* S */) {
                    isAdd = true;
                }
            });
            if (isAdd) {
                builder.add(4 /* HydrogenDonor */, 0 /* None */, x[elements[i]], y[elements[i]], z[elements[i]], i);
            }
        }
    };
    for (var i = 0, il = elements.length; i < il; ++i) {
        _loop_1(i, il);
    }
}
/**
 * Weak hydrogen donor.
 */
function addUnitWeakHydrogenDonors(structure, unit, builder) {
    var elements = unit.elements;
    var _a = unit.model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;
    var _loop_2 = function (i, il) {
        var element = (0, util_1.typeSymbol)(unit, i);
        var isAdd = false;
        if (element === "H" /* H */) {
            var carbonIndex_1 = [];
            (0, util_1.eachIntraBondedAtom)(unit, i, function (unit, index) {
                var bondedAtomElement = (0, util_1.typeSymbol)(unit, index);
                if (bondedAtomElement === "C" /* C */) {
                    if (inAromaticRingElement(unit, index)) {
                        isAdd = true;
                    }
                    else {
                        carbonIndex_1.push(index);
                    }
                }
            });
            if (!isAdd && carbonIndex_1.length === 1) {
                var numOfFluorine_1 = 0;
                (0, util_1.eachIntraBondedAtom)(unit, carbonIndex_1[0], function (unit, index) {
                    var connectedElement = (0, util_1.typeSymbol)(unit, index);
                    if (connectedElement === "F" /* F */) {
                        numOfFluorine_1++;
                    }
                });
                if (numOfFluorine_1 === 2) {
                    isAdd = true;
                }
            }
            if (isAdd) {
                builder.add(9 /* WeakHydrogenDonor */, 0 /* None */, x[elements[i]], y[elements[i]], z[elements[i]], i);
            }
        }
    };
    for (var i = 0, il = elements.length; i < il; ++i) {
        _loop_2(i, il);
    }
}
function inAromaticRingElement(unit, index) {
    var elementAromaticRingIndices = unit.rings.elementAromaticRingIndices;
    var ringIndices = elementAromaticRingIndices.get(index);
    if (ringIndices === undefined)
        return false;
    return true;
}
/**
 * Potential hydrogen acceptor
 */
function addUnitHydrogenAcceptors(structure, unit, builder) {
    var _a = getUnitValenceModel(structure, unit), charge = _a.charge, implicitH = _a.implicitH, idealGeometry = _a.idealGeometry;
    var elements = unit.elements;
    var _b = unit.model.atomicConformation, x = _b.x, y = _b.y, z = _b.z;
    var add = function (i) {
        builder.add(5 /* HydrogenAcceptor */, 0 /* None */, x[elements[i]], y[elements[i]], z[elements[i]], i);
    };
    for (var i = 0, il = elements.length; i < il; ++i) {
        var element = (0, util_1.typeSymbol)(unit, i);
        if (element === "O" /* O */) {
            // Basically assume all oxygen atoms are acceptors!
            add(i);
        }
        else if (element === "N" /* N */) {
            if (charge[i] < 1) {
                // Neutral nitrogen might be an acceptor
                // It must have at least one lone pair not conjugated
                var totalBonds = (0, util_1.bondCount)(structure, unit, i) + implicitH[i];
                var ig = idealGeometry[i];
                if ((ig === 4 /* Tetrahedral */ && totalBonds < 4) ||
                    (ig === 3 /* Trigonal */ && totalBonds < 3) ||
                    (ig === 2 /* Linear */ && totalBonds < 2)) {
                    add(i);
                }
            }
        }
        else if (element === "S" /* S */) {
            if ((0, util_1.formalCharge)(unit, i) === -1) {
                add(i);
            }
        }
        else if (element === "F" /* F */) {
            add(i);
        }
    }
}
function isWater(unit, index) {
    return (unit.model.atomicHierarchy.derived.residue.moleculeType[unit.residueIndex[unit.elements[index]]] === 2 /* Water */);
}
function isBackbone(unit, index) {
    return types_1.ProteinBackboneAtoms.has((0, util_1.atomId)(unit, index));
}
// function isRing(unit: Unit.Atomic, index: StructureElement.UnitIndex) {
//   return unit.rings.elementRingIndices.has(index)
// }
// function isHistidineNitrogen(
//   unit: Unit.Atomic,
//   index: StructureElement.UnitIndex
// ) {
//   return (
//     compId(unit, index) === 'HIS' &&
//     typeSymbol(unit, index) === Elements.N &&
//     isRing(unit, index)
//   )
// }
function isBackboneHydrogenBond(unitA, indexA, unitB, indexB) {
    return isBackbone(unitA, indexA) && isBackbone(unitB, indexB);
}
function isWaterHydrogenBond(unitA, indexA, unitB, indexB) {
    return isWater(unitA, indexA) && isWater(unitB, indexB);
}
function isHydrogenBond(ti, tj) {
    return ((ti === 5 /* HydrogenAcceptor */ && tj === 4 /* HydrogenDonor */) ||
        (ti === 4 /* HydrogenDonor */ && tj === 5 /* HydrogenAcceptor */));
}
function isWeakHydrogenBond(ti, tj) {
    return ((ti === 9 /* WeakHydrogenDonor */ &&
        tj === 5 /* HydrogenAcceptor */) ||
        (ti === 5 /* HydrogenAcceptor */ &&
            tj === 9 /* WeakHydrogenDonor */));
}
function getGeometryOptions(props) {
    return {
        includeBackbone: props.backbone,
        maxAccAngleDev: (0, misc_1.degToRad)(props.accAngleDevMax),
        maxDonAngleDev: (0, misc_1.degToRad)(props.donAngleDevMax),
        maxAccOutOfPlaneAngle: (0, misc_1.degToRad)(props.accOutOfPlaneAngleMax),
        maxDonOutOfPlaneAngle: (0, misc_1.degToRad)(props.donOutOfPlaneAngleMax)
    };
}
function getHydrogenBondsOptions(props) {
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, getGeometryOptions(props)), { includeWater: props.water, maxSulfurDistSq: props.sulfurDistanceMax * props.sulfurDistanceMax, maxDistSq: props.distanceMax * props.distanceMax });
}
// const deg120InRad = degToRad(120)
function checkGeometry(structure, don, acc, opts) {
    var donIndex = don.members[don.offsets[don.feature]];
    var accIndex = acc.members[acc.offsets[acc.feature]];
    if (!opts.includeBackbone &&
        isBackboneHydrogenBond(don.unit, donIndex, acc.unit, accIndex))
        return;
    // const donAngles = calcAngles(
    //   structure,
    //   don.unit,
    //   donIndex,
    //   acc.unit,
    //   accIndex
    // )
    // const idealDonAngle =
    //   AtomGeometryAngles.get(don.idealGeometry[donIndex]) || deg120InRad
    // if (
    //   donAngles.some(
    //     (donAngle) => Math.abs(idealDonAngle - donAngle) > opts.maxDonAngleDev
    //   )
    // )
    //   return
    // if (don.idealGeometry[donIndex] === AtomGeometry.Trigonal) {
    //   const outOfPlane = calcPlaneAngle(
    //     structure,
    //     don.unit,
    //     donIndex,
    //     acc.unit,
    //     accIndex
    //   )
    //   if (outOfPlane !== undefined && outOfPlane > opts.maxDonOutOfPlaneAngle)
    //     return
    // }
    // const accAngles = calcAngles(
    //   structure,
    //   acc.unit,
    //   accIndex,
    //   don.unit,
    //   donIndex
    // )
    // const idealAccAngle =
    //   AtomGeometryAngles.get(acc.idealGeometry[accIndex]) || deg120InRad
    // // Do not limit large acceptor angles
    // if (
    //   accAngles.some((accAngle) => idealAccAngle - accAngle > opts.maxAccAngleDev)
    // )
    //   return
    // if (acc.idealGeometry[accIndex] === AtomGeometry.Trigonal) {
    //   const outOfPlane = calcPlaneAngle(
    //     structure,
    //     acc.unit,
    //     accIndex,
    //     don.unit,
    //     donIndex
    //   )
    //   if (outOfPlane !== undefined && outOfPlane > opts.maxAccOutOfPlaneAngle)
    //     return
    // }
    var angle = (0, geometry_1.calcAngles)(structure, don.unit, donIndex, acc.unit, accIndex);
    if (!((0, misc_1.radToDeg)(angle[0]) >= 120 && (0, misc_1.radToDeg)(angle[0]) <= 180)) {
        return;
    }
    // const angle = calcAnglesNew(
    //   structure,
    //   acc.unit,
    //   accIndex,
    //   don.unit,
    //   donIndex,
    // )
    return true;
}
function testHydrogenBond(structure, infoA, infoB, distanceSq, opts) {
    var typeA = infoA.types[infoA.feature];
    var typeB = infoB.types[infoB.feature];
    if (!isHydrogenBond(typeA, typeB))
        return;
    var _a = typeB === 5 /* HydrogenAcceptor */ ? [infoA, infoB] : [infoB, infoA], don = _a[0], acc = _a[1];
    var donIndex = don.members[don.offsets[don.feature]];
    var accIndex = acc.members[acc.offsets[acc.feature]];
    // check if distance is ok depending on non-sulfur-containing hbond
    var maxDistSq = (0, util_1.typeSymbol)(don.unit, donIndex) === "S" /* S */ ||
        (0, util_1.typeSymbol)(acc.unit, accIndex) === "S" /* S */
        ? opts.maxSulfurDistSq
        : opts.maxDistSq;
    if (distanceSq > maxDistSq)
        return;
    if (!opts.includeWater &&
        isWaterHydrogenBond(don.unit, donIndex, acc.unit, accIndex))
        return;
    if (!checkGeometry(structure, don, acc, opts))
        return;
    return common_1.InteractionType.HydrogenBond;
}
function testWeakHydrogenBond(structure, infoA, infoB, distanceSq, opts) {
    var typeA = infoA.types[infoA.feature];
    var typeB = infoB.types[infoB.feature];
    if (!isWeakHydrogenBond(typeA, typeB))
        return;
    var _a = typeB === 5 /* HydrogenAcceptor */ ? [infoA, infoB] : [infoB, infoA], don = _a[0], acc = _a[1];
    if (!checkGeometry(structure, don, acc, opts))
        return;
    return common_1.InteractionType.WeakHydrogenBond;
}
//
exports.HydrogenDonorProvider = features_1.Features.Provider([4 /* HydrogenDonor */], addUnitHydrogenDonors);
exports.WeakHydrogenDonorProvider = features_1.Features.Provider([9 /* WeakHydrogenDonor */], addUnitWeakHydrogenDonors);
exports.HydrogenAcceptorProvider = features_1.Features.Provider([5 /* HydrogenAcceptor */], addUnitHydrogenAcceptors);
exports.HydrogenBondsProvider = {
    name: 'hydrogen-bonds',
    params: HydrogenBondsParams,
    createTester: function (props) {
        var maxDistance = Math.max(props.distanceMax, props.sulfurDistanceMax);
        var opts = getHydrogenBondsOptions(props);
        return {
            maxDistance: maxDistance,
            requiredFeatures: new Set([
                4 /* HydrogenDonor */,
                5 /* HydrogenAcceptor */
            ]),
            getType: function (structure, infoA, infoB, distanceSq) {
                return testHydrogenBond(structure, infoA, infoB, distanceSq, opts);
            }
        };
    }
};
exports.WeakHydrogenBondsProvider = {
    name: 'weak-hydrogen-bonds',
    params: WeakHydrogenBondsParams,
    createTester: function (props) {
        var opts = getGeometryOptions(props);
        return {
            maxDistance: props.distanceMax,
            requiredFeatures: new Set([
                9 /* WeakHydrogenDonor */,
                5 /* HydrogenAcceptor */
            ]),
            getType: function (structure, infoA, infoB, distanceSq) {
                return testWeakHydrogenBond(structure, infoA, infoB, distanceSq, opts);
            }
        };
    }
};
//# sourceMappingURL=hydrogen-bonds.js.map