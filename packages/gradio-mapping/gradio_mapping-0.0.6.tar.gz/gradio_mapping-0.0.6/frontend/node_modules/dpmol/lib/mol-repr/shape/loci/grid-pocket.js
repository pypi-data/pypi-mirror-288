"use strict";
/**
 * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GridPocketRepresentation = exports.getGridPocketData = exports.GridPocketParams = void 0;
var tslib_1 = require("tslib");
var representation_1 = require("../representation");
var shape_1 = require("../../../mol-model/shape");
var names_1 = require("../../../mol-util/color/names");
var param_definition_1 = require("../../../mol-util/param-definition");
var mesh_1 = require("../../../mol-geo/geometry/mesh/mesh");
var mesh_builder_1 = require("../../../mol-geo/geometry/mesh/mesh-builder");
var box_1 = require("../../../mol-geo/primitive/box");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var cage_1 = require("../../../mol-geo/primitive/cage");
var geometry_1 = require("../../../mol-math/geometry");
var sphere_1 = require("../../../mol-geo/geometry/mesh/builder/sphere");
var cylinder_1 = require("../../../mol-geo/geometry/mesh/builder/cylinder");
var representation_2 = require("../../representation");
var translate05 = linear_algebra_1.Mat4.fromTranslation((0, linear_algebra_1.Mat4)(), linear_algebra_1.Vec3.create(0.5, 0.5, 0.5));
var unitCage = (0, cage_1.transformCage)((0, cage_1.cloneCage)((0, box_1.BoxCage)()), translate05);
var tmpRef = (0, linear_algebra_1.Vec3)();
var tmpTranslate = (0, linear_algebra_1.Mat4)();
var AxesParams = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, mesh_1.Mesh.Params), { alpha: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, mesh_1.Mesh.Params.alpha), { defaultValue: 0.51 }), ignoreLight: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, mesh_1.Mesh.Params.ignoreLight), { defaultValue: true }), colorX: param_definition_1.ParamDefinition.Color(names_1.ColorNames.red, { isEssential: true }), colorY: param_definition_1.ParamDefinition.Color(names_1.ColorNames.green, { isEssential: true }), colorZ: param_definition_1.ParamDefinition.Color(names_1.ColorNames.blue, { isEssential: true }), scale: param_definition_1.ParamDefinition.Numeric(2, { min: 0.1, max: 5, step: 0.1 }) });
var PocketParams = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, mesh_1.Mesh.Params), AxesParams), { pocketColor: param_definition_1.ParamDefinition.Color(names_1.ColorNames.red), pocketScale: param_definition_1.ParamDefinition.Numeric(4, { min: 0.1, max: 5, step: 0.1 }), x: param_definition_1.ParamDefinition.Numeric(10), y: param_definition_1.ParamDefinition.Numeric(10), z: param_definition_1.ParamDefinition.Numeric(10), center: param_definition_1.ParamDefinition.Vec3((0, linear_algebra_1.Vec3)()) });
exports.GridPocketParams = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, PocketParams), AxesParams);
var GridPocketVisuals = {
    axes: function (ctx, getParams) {
        return (0, representation_1.ShapeRepresentation)(getAxesShape, mesh_1.Mesh.Utils);
    },
    mesh: function (ctx, getParams) { return (0, representation_1.ShapeRepresentation)(getGridPocketShape, mesh_1.Mesh.Utils); }
};
function getGridPocketMesh(data, props, mesh) {
    var state = mesh_builder_1.MeshBuilder.createState(256, 128, mesh);
    var fromFractional = data.gridPocket.fromFractional;
    linear_algebra_1.Vec3.copy(tmpRef, data.ref);
    linear_algebra_1.Vec3.subScalar(tmpRef, tmpRef, 0.5);
    linear_algebra_1.Mat4.fromTranslation(tmpTranslate, tmpRef);
    var pocketCage = (0, cage_1.transformCage)((0, cage_1.cloneCage)(unitCage), tmpTranslate);
    var radius = (Math.cbrt(data.gridPocket.volume) / 300) * props.pocketScale;
    state.currentGroup = 1;
    mesh_builder_1.MeshBuilder.addCage(state, fromFractional, pocketCage, radius, 2, 20);
    var sphere = geometry_1.Sphere3D.fromDimensionsAndTransform((0, geometry_1.Sphere3D)(), linear_algebra_1.Vec3.unit, fromFractional);
    linear_algebra_1.Vec3.transformMat4(tmpRef, tmpRef, fromFractional);
    geometry_1.Sphere3D.translate(sphere, sphere, tmpRef);
    geometry_1.Sphere3D.expand(sphere, sphere, radius);
    var m = mesh_builder_1.MeshBuilder.getMesh(state);
    m.setBoundingSphere(sphere);
    return m;
}
function getGridPocketShape(ctx, data, props, shape) {
    var geo = getGridPocketMesh(data, props, shape && shape.geometry);
    var label = 'Grid Pocket Box';
    return shape_1.Shape.create(label, data, geo, function () { return props.pocketColor; }, function () { return 1; }, function () { return label; });
}
function getGridPocketData(x, y, z, center) {
    var ref = (0, linear_algebra_1.Vec3)();
    var mat4 = linear_algebra_1.Mat4.ofRows([
        [x, 0, 0, 0],
        [0, y, 0, 0],
        [0, 0, z, 0],
        [0, 0, 0, 1.0]
    ]);
    var toFractional = linear_algebra_1.Mat4.invert(linear_algebra_1.Mat4.zero(), mat4);
    var data = {
        ref: linear_algebra_1.Vec3.transformMat4(ref, center, toFractional),
        gridPocket: {
            fromFractional: mat4,
            toFractional: toFractional,
            x: x,
            y: y,
            z: z,
            center: center,
            volume: x * y * z,
        }
    };
    return data;
}
exports.getGridPocketData = getGridPocketData;
function createAxesMesh(scale, data, mesh) {
    var _a = data.gridPocket, x = _a.x, y = _a.y, z = _a.z, center = _a.center, volume = _a.volume;
    var state = mesh_builder_1.MeshBuilder.createState(512, 256, mesh);
    var radius = (Math.cbrt(volume) / 300) * scale;
    var centerX = center[0], centerY = center[1], centerZ = center[2];
    var size = Math.min(x, y, z);
    var X = linear_algebra_1.Vec3.create(centerX + size / 3, centerY, centerZ);
    var Y = linear_algebra_1.Vec3.create(centerX, centerY + size / 3, centerZ);
    var Z = linear_algebra_1.Vec3.create(centerX, centerY, centerZ + size / 3);
    var cylinderProps = { radiusTop: radius, radiusBottom: radius, radialSegments: 32 };
    state.currentGroup = 0 /* None */;
    (0, sphere_1.addSphere)(state, center, radius, 2);
    state.currentGroup = 1 /* X */;
    (0, sphere_1.addSphere)(state, X, radius, 2);
    (0, cylinder_1.addCylinder)(state, center, X, 1, cylinderProps);
    state.currentGroup = 2 /* Y */;
    (0, sphere_1.addSphere)(state, Y, radius, 2);
    (0, cylinder_1.addCylinder)(state, center, Y, 1, cylinderProps);
    state.currentGroup = 3 /* Z */;
    (0, sphere_1.addSphere)(state, Z, radius, 2);
    (0, cylinder_1.addCylinder)(state, center, Z, 1, cylinderProps);
    linear_algebra_1.Vec3.scale(X, X, 0.5);
    linear_algebra_1.Vec3.scale(Y, Y, 0.5);
    linear_algebra_1.Vec3.scale(Z, Z, 0.5);
    return mesh_builder_1.MeshBuilder.getMesh(state);
}
function getAxesShape(ctx, data, props, shape) {
    var scale = props.scale;
    var mesh = createAxesMesh(scale, data, shape === null || shape === void 0 ? void 0 : shape.geometry);
    mesh.setBoundingSphere(geometry_1.Sphere3D.create(linear_algebra_1.Vec3.create(scale / 2, scale / 2, scale / 2), scale + scale / 4));
    var getColor = function (groupId) {
        switch (groupId) {
            case 1: return props.colorX;
            case 2: return props.colorY;
            case 3: return props.colorZ;
            default: return names_1.ColorNames.grey;
        }
    };
    return shape_1.Shape.create('axes', {}, mesh, getColor, function () { return 1; }, function () { return ''; });
}
function GridPocketRepresentation(ctx, getParams) {
    return representation_2.Representation.createMulti('Grid Pocket', ctx, getParams, representation_2.Representation.StateBuilder, GridPocketVisuals);
}
exports.GridPocketRepresentation = GridPocketRepresentation;
//# sourceMappingURL=grid-pocket.js.map