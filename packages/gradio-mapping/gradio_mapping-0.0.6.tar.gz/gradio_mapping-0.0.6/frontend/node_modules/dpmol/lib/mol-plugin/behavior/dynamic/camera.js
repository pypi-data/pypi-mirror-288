"use strict";
/**
 * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraAxisHelper = exports.FocusLoci = void 0;
var tslib_1 = require("tslib");
var loci_1 = require("../../../mol-model/loci");
var param_definition_1 = require("../../../mol-util/param-definition");
var behavior_1 = require("../behavior");
var input_observer_1 = require("../../../mol-util/input/input-observer");
var binding_1 = require("../../../mol-util/binding");
var commands_1 = require("../../commands");
var camera_helper_1 = require("../../../mol-canvas3d/helper/camera-helper");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var B = input_observer_1.ButtonsType;
var M = input_observer_1.ModifiersKeys;
var Trigger = binding_1.Binding.Trigger;
var DefaultFocusLociBindings = {
    clickCenterFocus: (0, binding_1.Binding)([
        Trigger(1 /* Primary */, M.create()),
        Trigger(2 /* Secondary */, M.create()),
        Trigger(1 /* Primary */, M.create({ control: true }))
    ], 'Camera center and focus', 'Click element using ${triggers}'),
    clickCenterFocusSelectMode: (0, binding_1.Binding)([
        Trigger(2 /* Secondary */, M.create()),
        Trigger(1 /* Primary */, M.create({ control: true }))
    ], 'Camera center and focus', 'Click element using ${triggers}')
};
var FocusLociParams = {
    minRadius: param_definition_1.ParamDefinition.Numeric(8, { min: 1, max: 50, step: 1 }),
    extraRadius: param_definition_1.ParamDefinition.Numeric(4, { min: 1, max: 50, step: 1 }, { description: 'Value added to the bounding-sphere radius of the Loci' }),
    durationMs: param_definition_1.ParamDefinition.Numeric(250, { min: 0, max: 1000, step: 1 }, { description: 'Camera transition duration' }),
    bindings: param_definition_1.ParamDefinition.Value(DefaultFocusLociBindings, { isHidden: true })
};
exports.FocusLoci = behavior_1.PluginBehavior.create({
    name: 'camera-focus-loci',
    category: 'interaction',
    ctor: /** @class */ (function (_super) {
        (0, tslib_1.__extends)(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.register = function () {
            var _this = this;
            this.subscribeObservable(this.ctx.behaviors.interaction.click, function (_a) {
                var current = _a.current, button = _a.button, modifiers = _a.modifiers;
                if (!_this.ctx.canvas3d)
                    return;
                if (_this.ctx.isEditing && _this.ctx.disabledInteraction.includes('click'))
                    return;
                var binding = _this.ctx.selectionMode
                    ? _this.params.bindings.clickCenterFocusSelectMode
                    : _this.params.bindings.clickCenterFocus;
                if (binding_1.Binding.match(binding, button, modifiers)) {
                    if (loci_1.Loci.isEmpty(current.loci)) {
                        commands_1.PluginCommands.Camera.Reset(_this.ctx, {});
                        return;
                    }
                    var loci = loci_1.Loci.normalize(current.loci, _this.ctx.managers.interactivity.props.granularity);
                    _this.ctx.managers.camera.focusLoci(loci, _this.params);
                }
            });
        };
        return class_1;
    }(behavior_1.PluginBehavior.Handler)),
    params: function () { return FocusLociParams; },
    display: { name: 'Camera Focus Loci on Canvas' }
});
exports.CameraAxisHelper = behavior_1.PluginBehavior.create({
    name: 'camera-axis-helper',
    category: 'interaction',
    ctor: /** @class */ (function (_super) {
        (0, tslib_1.__extends)(class_2, _super);
        function class_2() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_2.prototype.register = function () {
            var _this = this;
            var lastPlane = camera_helper_1.CameraHelperAxis.None;
            var state = 0;
            this.subscribeObservable(this.ctx.behaviors.interaction.click, function (_a) {
                var current = _a.current;
                if (!_this.ctx.canvas3d || !(0, camera_helper_1.isCameraAxesLoci)(current.loci))
                    return;
                var axis = current.loci.elements[0].groupId;
                if (axis === camera_helper_1.CameraHelperAxis.None) {
                    lastPlane = camera_helper_1.CameraHelperAxis.None;
                    state = 0;
                    return;
                }
                var camera = _this.ctx.canvas3d.camera;
                var dir, up;
                if (axis >= camera_helper_1.CameraHelperAxis.X && axis <= camera_helper_1.CameraHelperAxis.Z) {
                    lastPlane = camera_helper_1.CameraHelperAxis.None;
                    state = 0;
                    var d = linear_algebra_1.Vec3.sub((0, linear_algebra_1.Vec3)(), camera.target, camera.position);
                    var c = linear_algebra_1.Vec3.cross((0, linear_algebra_1.Vec3)(), d, camera.up);
                    up = (0, linear_algebra_1.Vec3)();
                    up[axis - 1] = 1;
                    dir = linear_algebra_1.Vec3.cross((0, linear_algebra_1.Vec3)(), up, c);
                    if (linear_algebra_1.Vec3.magnitude(dir) === 0)
                        dir = d;
                }
                else {
                    if (lastPlane === axis) {
                        state = (state + 1) % 2;
                    }
                    else {
                        lastPlane = axis;
                        state = 0;
                    }
                    if (axis === camera_helper_1.CameraHelperAxis.XY) {
                        up = state ? linear_algebra_1.Vec3.unitX : linear_algebra_1.Vec3.unitY;
                        dir = linear_algebra_1.Vec3.negUnitZ;
                    }
                    else if (axis === camera_helper_1.CameraHelperAxis.XZ) {
                        up = state ? linear_algebra_1.Vec3.unitX : linear_algebra_1.Vec3.unitZ;
                        dir = linear_algebra_1.Vec3.negUnitY;
                    }
                    else {
                        up = state ? linear_algebra_1.Vec3.unitY : linear_algebra_1.Vec3.unitZ;
                        dir = linear_algebra_1.Vec3.negUnitX;
                    }
                }
                _this.ctx.canvas3d.requestCameraReset({
                    snapshot: function (scene, camera) {
                        return camera.getInvariantFocus(scene.boundingSphereVisible.center, scene.boundingSphereVisible.radius, up, dir);
                    }
                });
            });
        };
        return class_2;
    }(behavior_1.PluginBehavior.Handler)),
    params: function () { return ({}); },
    display: { name: 'Camera Axis Helper' }
});
//# sourceMappingURL=camera.js.map