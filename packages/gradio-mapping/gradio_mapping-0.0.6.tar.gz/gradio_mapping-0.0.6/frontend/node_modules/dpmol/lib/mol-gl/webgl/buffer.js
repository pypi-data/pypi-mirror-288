"use strict";
/**
 * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createElementsBuffer = exports.createAttributeBuffers = exports.createAttributeBuffer = exports.getAttribType = exports.getBufferType = exports.getDataType = exports.getUsageHint = void 0;
var tslib_1 = require("tslib");
var id_factory_1 = require("../../mol-util/id-factory");
var type_helpers_1 = require("../../mol-util/type-helpers");
var getNextBufferId = (0, id_factory_1.idFactory)();
function getUsageHint(gl, usageHint) {
    switch (usageHint) {
        case 'static':
            return gl.STATIC_DRAW;
        case 'dynamic':
            return gl.DYNAMIC_DRAW;
        case 'stream':
            return gl.STREAM_DRAW;
    }
}
exports.getUsageHint = getUsageHint;
function getDataType(gl, dataType) {
    switch (dataType) {
        case 'uint8':
            return gl.UNSIGNED_BYTE;
        case 'int8':
            return gl.BYTE;
        case 'uint16':
            return gl.UNSIGNED_SHORT;
        case 'int16':
            return gl.SHORT;
        case 'uint32':
            return gl.UNSIGNED_INT;
        case 'int32':
            return gl.INT;
        case 'float32':
            return gl.FLOAT;
    }
}
exports.getDataType = getDataType;
function dataTypeFromArray(gl, array) {
    if (array instanceof Uint8Array) {
        return gl.UNSIGNED_BYTE;
    }
    else if (array instanceof Int8Array) {
        return gl.BYTE;
    }
    else if (array instanceof Uint16Array) {
        return gl.UNSIGNED_SHORT;
    }
    else if (array instanceof Int16Array) {
        return gl.SHORT;
    }
    else if (array instanceof Uint32Array) {
        return gl.UNSIGNED_INT;
    }
    else if (array instanceof Int32Array) {
        return gl.INT;
    }
    else if (array instanceof Float32Array) {
        return gl.FLOAT;
    }
    (0, type_helpers_1.assertUnreachable)(array);
}
function getBufferType(gl, bufferType) {
    switch (bufferType) {
        case 'attribute':
            return gl.ARRAY_BUFFER;
        case 'elements':
            return gl.ELEMENT_ARRAY_BUFFER;
        case 'uniform':
            return gl.UNIFORM_BUFFER;
    }
}
exports.getBufferType = getBufferType;
function getBuffer(gl) {
    var buffer = gl.createBuffer();
    if (buffer === null) {
        throw new Error('Could not create WebGL buffer');
    }
    return buffer;
}
function createBuffer(gl, array, usageHint, bufferType) {
    var _buffer = getBuffer(gl);
    var _usageHint = getUsageHint(gl, usageHint);
    var _bufferType = getBufferType(gl, bufferType);
    var _dataType = dataTypeFromArray(gl, array);
    var _bpe = array.BYTES_PER_ELEMENT;
    var _length = array.length;
    function updateData(array) {
        gl.bindBuffer(_bufferType, _buffer);
        gl.bufferData(_bufferType, array, _usageHint);
    }
    updateData(array);
    var destroyed = false;
    return {
        id: getNextBufferId(),
        _usageHint: _usageHint,
        _bufferType: _bufferType,
        _dataType: _dataType,
        _bpe: _bpe,
        length: _length,
        getBuffer: function () { return _buffer; },
        updateData: updateData,
        updateSubData: function (array, offset, count) {
            gl.bindBuffer(_bufferType, _buffer);
            if (count - offset === array.length) {
                gl.bufferSubData(_bufferType, 0, array);
            }
            else {
                gl.bufferSubData(_bufferType, offset * _bpe, array.subarray(offset, offset + count));
            }
        },
        reset: function () {
            _buffer = getBuffer(gl);
            updateData(array);
        },
        destroy: function () {
            if (destroyed)
                return;
            gl.deleteBuffer(_buffer);
            destroyed = true;
        }
    };
}
function getAttribType(gl, kind, itemSize) {
    switch (kind) {
        case 'int32':
            switch (itemSize) {
                case 1:
                    return gl.INT;
                case 2:
                    return gl.INT_VEC2;
                case 3:
                    return gl.INT_VEC3;
                case 4:
                    return gl.INT_VEC4;
            }
            break;
        case 'float32':
            switch (itemSize) {
                case 1:
                    return gl.FLOAT;
                case 2:
                    return gl.FLOAT_VEC2;
                case 3:
                    return gl.FLOAT_VEC3;
                case 4:
                    return gl.FLOAT_VEC4;
                case 16:
                    return gl.FLOAT_MAT4;
            }
            break;
    }
    throw new Error("unknown attribute type for kind '".concat(kind, "' and itemSize '").concat(itemSize, "'"));
}
exports.getAttribType = getAttribType;
function createAttributeBuffer(gl, state, extensions, array, itemSize, divisor, usageHint) {
    if (usageHint === void 0) { usageHint = 'dynamic'; }
    var instancedArrays = extensions.instancedArrays;
    var buffer = createBuffer(gl, array, usageHint, 'attribute');
    var _bufferType = buffer._bufferType, _dataType = buffer._dataType, _bpe = buffer._bpe;
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, buffer), { bind: function (location) {
            gl.bindBuffer(_bufferType, buffer.getBuffer());
            if (itemSize === 16) {
                for (var i = 0; i < 4; ++i) {
                    state.enableVertexAttrib(location + i);
                    gl.vertexAttribPointer(location + i, 4, _dataType, false, 4 * 4 * _bpe, i * 4 * _bpe);
                    instancedArrays.vertexAttribDivisor(location + i, divisor);
                }
            }
            else {
                state.enableVertexAttrib(location);
                gl.vertexAttribPointer(location, itemSize, _dataType, false, 0, 0);
                instancedArrays.vertexAttribDivisor(location, divisor);
            }
        } });
}
exports.createAttributeBuffer = createAttributeBuffer;
function createAttributeBuffers(ctx, schema, values) {
    var buffers = [];
    Object.keys(schema).forEach(function (k) {
        var spec = schema[k];
        if (spec.type === 'attribute') {
            buffers[buffers.length] = [
                k,
                ctx.resources.attribute(values[k].ref.value, spec.itemSize, spec.divisor)
            ];
        }
    });
    return buffers;
}
exports.createAttributeBuffers = createAttributeBuffers;
function createElementsBuffer(gl, array, usageHint) {
    if (usageHint === void 0) { usageHint = 'static'; }
    var buffer = createBuffer(gl, array, usageHint, 'elements');
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, buffer), { bind: function () {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer.getBuffer());
        } });
}
exports.createElementsBuffer = createElementsBuffer;
//# sourceMappingURL=buffer.js.map