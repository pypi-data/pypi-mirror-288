"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PharmacophoreRepresentation = exports.getPharmacophoreParams = exports.getPharmacophoreSphere2 = exports.getPharmacophoreSphere1 = exports.addSphere = exports.getSphere = exports.PharmacophoreArrowHeadParams = exports.PharmacophoreCylinderParams = exports.PharmacophoreSphere2Params = exports.PharmacophoreSphere1Params = exports.PharmacophoreParams = void 0;
var tslib_1 = require("tslib");
var cylinders_1 = require("../../../mol-geo/geometry/cylinders/cylinders");
var cylinders_builder_1 = require("../../../mol-geo/geometry/cylinders/cylinders-builder");
var lines_1 = require("../../../mol-geo/geometry/lines/lines");
var lines_builder_1 = require("../../../mol-geo/geometry/lines/lines-builder");
var mesh_1 = require("../../../mol-geo/geometry/mesh/mesh");
var mesh_builder_1 = require("../../../mol-geo/geometry/mesh/mesh-builder");
var spheres_1 = require("../../../mol-geo/geometry/spheres/spheres");
var spheres_builder_1 = require("../../../mol-geo/geometry/spheres/spheres-builder");
var circle_1 = require("../../../mol-geo/primitive/circle");
var primitive_1 = require("../../../mol-geo/primitive/primitive");
var sphere_1 = require("../../../mol-geo/primitive/sphere");
var tetrahedron_1 = require("../../../mol-geo/primitive/tetrahedron");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var shape_1 = require("../../../mol-model/shape");
var names_1 = require("../../../mol-util/color/names");
var marker_action_1 = require("../../../mol-util/marker-action");
var param_definition_1 = require("../../../mol-util/param-definition");
var representation_1 = require("../../representation");
var representation_2 = require("../../structure/representation");
var representation_3 = require("../representation");
var SharedParams = {
    radiusFactor: param_definition_1.ParamDefinition.Numeric(1, { min: 0.1, max: 3.0, step: 0.01 }, { description: 'Scale the radius of the membrane layer' }),
    center: param_definition_1.ParamDefinition.Vec3((0, linear_algebra_1.Vec3)()),
    radius: param_definition_1.ParamDefinition.Numeric(1),
    vec: param_definition_1.ParamDefinition.Vec3((0, linear_algebra_1.Vec3)()),
};
var PharmacophoreVisuals = {
    'pharmacophore-ball-1': function (ctx, getParams) { return (0, representation_3.ShapeRepresentation)(getPharmacophoreBall1, lines_1.Lines.Utils, { modifyState: function (s) { return ((0, tslib_1.__assign)((0, tslib_1.__assign)({}, s), { markerActions: marker_action_1.MarkerActions.All })); } }); },
    'pharmacophore-ball-2': function (ctx, getParams) { return (0, representation_3.ShapeRepresentation)(getPharmacophoreBall2, lines_1.Lines.Utils, { modifyState: function (s) { return ((0, tslib_1.__assign)((0, tslib_1.__assign)({}, s), { markerActions: marker_action_1.MarkerActions.All })); } }); },
    'pharmacophore-sphere-1': function (ctx, getParams) { return (0, representation_3.ShapeRepresentation)(getPharmacophoreSphere1, spheres_1.Spheres.Utils, { modifyState: function (s) { return ((0, tslib_1.__assign)((0, tslib_1.__assign)({}, s), { markerActions: marker_action_1.MarkerActions.All })); } }); },
    'pharmacophore-sphere-2': function (ctx, getParams) { return (0, representation_3.ShapeRepresentation)(getPharmacophoreSphere2, spheres_1.Spheres.Utils, { modifyState: function (s) { return ((0, tslib_1.__assign)((0, tslib_1.__assign)({}, s), { markerActions: marker_action_1.MarkerActions.All })); } }); },
    'pharmacophore-cylinder': function (ctx, getParams) { return (0, representation_3.ShapeRepresentation)(getArrowCylinder, cylinders_1.Cylinders.Utils, { modifyState: function (s) { return ((0, tslib_1.__assign)((0, tslib_1.__assign)({}, s), { markerActions: marker_action_1.MarkerActions.All })); } }); },
    // 'pharmacophore-arrow': (ctx: RepresentationContext, getParams: RepresentationParamsGetter<PharmacophoreData, PharmacophoreArrowParams>) => ShapeRepresentation(getPharmacophoreArrow, Lines.Utils, { modifyState: s => ({ ...s, markerActions: MarkerActions.Highlighting }) })
    'pharmacophore-arrowhead': function (ctx, getParams) { return (0, representation_3.ShapeRepresentation)(getArrowHead, mesh_1.Mesh.Utils); }
};
var PharmacophoreBall1Params = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, lines_1.Lines.Params), SharedParams), { color: param_definition_1.ParamDefinition.Color(names_1.ColorNames.blue), lineSizeAttenuation: param_definition_1.ParamDefinition.Boolean(false), linesSize: param_definition_1.ParamDefinition.Numeric(1, { min: 0.01, max: 50, step: 0.01 }), dashedLines: param_definition_1.ParamDefinition.Boolean(false), alpha: param_definition_1.ParamDefinition.Numeric(0.2, { min: 0, max: 0.4, step: 0.1 }) });
var PharmacophoreBall2Params = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, lines_1.Lines.Params), SharedParams), { color: param_definition_1.ParamDefinition.Color(names_1.ColorNames.blue), lineSizeAttenuation: param_definition_1.ParamDefinition.Boolean(false), linesSize: param_definition_1.ParamDefinition.Numeric(1, { min: 0.01, max: 50, step: 0.01 }), dashedLines: param_definition_1.ParamDefinition.Boolean(false), alpha: param_definition_1.ParamDefinition.Numeric(0.2, { min: 0, max: 0.4, step: 0.1 }) });
// const PharmacophoreArrowParams = {
//     ...Mesh.Params,
//     alpha: { ...Mesh.Params.alpha, defaultValue: 0.51 },
//     ignoreLight: { ...Mesh.Params.ignoreLight, defaultValue: true },
//     colorX: PD.Color(ColorNames.red, { isEssential: true }),
//     colorY: PD.Color(ColorNames.green, { isEssential: true }),
//     colorZ: PD.Color(ColorNames.blue, { isEssential: true }),
//     scale: PD.Numeric(4, { min: 0.1, max: 5, step: 0.1 }),
// }
// export type PharmacophoreArrowParams = typeof PharmacophoreArrowParams
// export type PharmacophoreArrowProps = PD.Values<PharmacophoreArrowParams>
exports.PharmacophoreParams = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, PharmacophoreBall1Params), PharmacophoreBall2Params), { visuals: param_definition_1.ParamDefinition.MultiSelect(['pharmacophore-ball-1', 'pharmacophore-ball-2', 'pharmacophore-sphere-1', 'pharmacophore-sphere-2', 'pharmacophore-cylinder', 'pharmacophore-arrowhead'], param_definition_1.ParamDefinition.objectToOptions(PharmacophoreVisuals)), alpha: param_definition_1.ParamDefinition.Numeric(0.2, { min: 0, max: 1, step: 0.1 }) });
exports.PharmacophoreSphere1Params = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, spheres_1.Spheres.Params), SharedParams), { sizeFactor: param_definition_1.ParamDefinition.Numeric(1, { min: 0, max: 10, step: 0.1 }), color: param_definition_1.ParamDefinition.Color(names_1.ColorNames.green), alpha: param_definition_1.ParamDefinition.Numeric(0.2, { min: 0, max: 0.4, step: 0.1 }) });
exports.PharmacophoreSphere2Params = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, spheres_1.Spheres.Params), SharedParams), { sizeFactor: param_definition_1.ParamDefinition.Numeric(1, { min: 0, max: 10, step: 0.1 }), color: param_definition_1.ParamDefinition.Color(names_1.ColorNames.brown), alpha: param_definition_1.ParamDefinition.Numeric(0.2, { min: 0, max: 0.4, step: 0.1 }) });
exports.PharmacophoreCylinderParams = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, cylinders_1.Cylinders.Params), SharedParams), { color: param_definition_1.ParamDefinition.Color(names_1.ColorNames.brown), sizeFactor: param_definition_1.ParamDefinition.Numeric(0.1, { min: 0, max: 10, step: 0.1 }) });
exports.PharmacophoreArrowHeadParams = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, mesh_1.Mesh.Params), SharedParams), { color: param_definition_1.ParamDefinition.Color(names_1.ColorNames.brown) });
function getPharmacophoreBall1(ctx, _, props, shape) {
    var radiusFactor = props.radiusFactor, center = props.center, radius = props.radius;
    var scaledRadius = radiusFactor * radius;
    var builder = lines_builder_1.LinesBuilder.create(128, 64, shape === null || shape === void 0 ? void 0 : shape.geometry);
    var planePoint1 = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.add(planePoint1, center, linear_algebra_1.Vec3.create(0, 1, 0));
    var planePoint2 = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.add(planePoint2, center, linear_algebra_1.Vec3.create(0, 0, 1));
    var planePoint3 = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.add(planePoint3, center, linear_algebra_1.Vec3.create(1, 0, 0));
    getLayerCircle(builder, center, planePoint1, scaledRadius, props);
    getLayerCircle(builder, center, planePoint2, scaledRadius, props);
    getLayerCircle(builder, center, planePoint3, scaledRadius, props);
    {
        var center1 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(center1, center, linear_algebra_1.Vec3.create(0, 0.5 * scaledRadius, 0));
        var planePoint11 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(planePoint11, center1, linear_algebra_1.Vec3.create(0, Math.sqrt(0.75), 0));
        getLayerCircle(builder, center1, planePoint11, Math.sqrt(0.75) * scaledRadius, props);
        var center2 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(center2, center, linear_algebra_1.Vec3.create(0, -0.5 * scaledRadius, 0));
        var planePoint12 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(planePoint12, center2, linear_algebra_1.Vec3.create(0, -Math.sqrt(0.75), 0));
        getLayerCircle(builder, center2, planePoint12, Math.sqrt(0.75) * scaledRadius, props);
    }
    {
        var center1 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(center1, center, linear_algebra_1.Vec3.create(0.5 * scaledRadius, 0, 0));
        var planePoint11 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(planePoint11, center1, linear_algebra_1.Vec3.create(Math.sqrt(0.75), 0, 0));
        getLayerCircle(builder, center1, planePoint11, Math.sqrt(0.75) * scaledRadius, props);
        var center2 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(center2, center, linear_algebra_1.Vec3.create(-0.5 * scaledRadius, 0, 0));
        var planePoint12 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(planePoint12, center2, linear_algebra_1.Vec3.create(-Math.sqrt(0.75), 0, 0));
        getLayerCircle(builder, center2, planePoint12, Math.sqrt(0.75) * scaledRadius, props);
    }
    {
        var center1 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(center1, center, linear_algebra_1.Vec3.create(0, 0, 0.5 * scaledRadius));
        var planePoint11 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(planePoint11, center1, linear_algebra_1.Vec3.create(0, 0, Math.sqrt(0.75)));
        getLayerCircle(builder, center1, planePoint11, Math.sqrt(0.75) * scaledRadius, props);
        var center2 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(center2, center, linear_algebra_1.Vec3.create(0, 0, -0.5 * scaledRadius));
        var planePoint12 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(planePoint12, center2, linear_algebra_1.Vec3.create(0, 0, -Math.sqrt(0.75)));
        getLayerCircle(builder, center2, planePoint12, Math.sqrt(0.75) * scaledRadius, props);
    }
    return shape_1.Shape.create('pharmacophore-ball-1', props, builder.getLines(), function () { return props.color; }, function () { return props.linesSize; }, function () { return 'pharmacophore'; });
}
function getPharmacophoreBall2(ctx, _, props, shape) {
    var radiusFactor = props.radiusFactor, center = props.center, radius = props.radius, vec = props.vec;
    var scaledRadius = radiusFactor * radius;
    var newCenter = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.add(newCenter, center, vec);
    var builder = lines_builder_1.LinesBuilder.create(128, 64, shape === null || shape === void 0 ? void 0 : shape.geometry);
    var planePoint1 = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.add(planePoint1, newCenter, linear_algebra_1.Vec3.create(0, 1, 0));
    var planePoint2 = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.add(planePoint2, newCenter, linear_algebra_1.Vec3.create(0, 0, 1));
    var planePoint3 = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.add(planePoint3, newCenter, linear_algebra_1.Vec3.create(1, 0, 0));
    getLayerCircle(builder, newCenter, planePoint1, scaledRadius, props);
    getLayerCircle(builder, newCenter, planePoint2, scaledRadius, props);
    getLayerCircle(builder, newCenter, planePoint3, scaledRadius, props);
    {
        var center1 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(center1, newCenter, linear_algebra_1.Vec3.create(0, 0.5 * scaledRadius, 0));
        var planePoint11 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(planePoint11, center1, linear_algebra_1.Vec3.create(0, Math.sqrt(0.75), 0));
        getLayerCircle(builder, center1, planePoint11, Math.sqrt(0.75) * scaledRadius, props);
        var center2 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(center2, newCenter, linear_algebra_1.Vec3.create(0, -0.5 * scaledRadius, 0));
        var planePoint12 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(planePoint12, center2, linear_algebra_1.Vec3.create(0, -Math.sqrt(0.75), 0));
        getLayerCircle(builder, center2, planePoint12, Math.sqrt(0.75) * scaledRadius, props);
    }
    {
        var center1 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(center1, newCenter, linear_algebra_1.Vec3.create(0.5 * scaledRadius, 0, 0));
        var planePoint11 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(planePoint11, center1, linear_algebra_1.Vec3.create(Math.sqrt(0.75), 0, 0));
        getLayerCircle(builder, center1, planePoint11, Math.sqrt(0.75) * scaledRadius, props);
        var center2 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(center2, newCenter, linear_algebra_1.Vec3.create(-0.5 * scaledRadius, 0, 0));
        var planePoint12 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(planePoint12, center2, linear_algebra_1.Vec3.create(-Math.sqrt(0.75), 0, 0));
        getLayerCircle(builder, center2, planePoint12, Math.sqrt(0.75) * scaledRadius, props);
    }
    {
        var center1 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(center1, newCenter, linear_algebra_1.Vec3.create(0, 0, 0.5 * scaledRadius));
        var planePoint11 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(planePoint11, center1, linear_algebra_1.Vec3.create(0, 0, Math.sqrt(0.75)));
        getLayerCircle(builder, center1, planePoint11, Math.sqrt(0.75) * scaledRadius, props);
        var center2 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(center2, newCenter, linear_algebra_1.Vec3.create(0, 0, -0.5 * scaledRadius));
        var planePoint12 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.add(planePoint12, center2, linear_algebra_1.Vec3.create(0, 0, -Math.sqrt(0.75)));
        getLayerCircle(builder, center2, planePoint12, Math.sqrt(0.75) * scaledRadius, props);
    }
    return shape_1.Shape.create('pharmacophore-ball-2', props, builder.getLines(), function () { return props.color; }, function () { return props.linesSize; }, function () { return 'pharmacophore'; });
}
function getLayerCircle(builder, p, centroid, radius, props, shape) {
    var circle = getCircle(p, centroid, radius);
    var indices = circle.indices, vertices = circle.vertices;
    for (var j = 0, jl = indices.length; j < jl; j += 3) {
        if (props.dashedLines && j % 2 === 1)
            continue; // draw every other segment to get dashes
        var start = indices[j] * 3;
        var end = indices[j + 1] * 3;
        var startX = vertices[start];
        var startY = vertices[start + 1];
        var startZ = vertices[start + 2];
        var endX = vertices[end];
        var endY = vertices[end + 1];
        var endZ = vertices[end + 2];
        builder.add(startX, startY, startZ, endX, endY, endZ, 0);
    }
}
var tmpMat = (0, linear_algebra_1.Mat4)();
var tmpV = (0, linear_algebra_1.Vec3)();
function getCircle(p, centroid, radius) {
    if (linear_algebra_1.Vec3.dot(linear_algebra_1.Vec3.unitY, linear_algebra_1.Vec3.sub(tmpV, p, centroid)) === 0) {
        linear_algebra_1.Mat4.targetTo(tmpMat, p, centroid, linear_algebra_1.Vec3.unitY);
    }
    else {
        linear_algebra_1.Mat4.targetTo(tmpMat, p, centroid, linear_algebra_1.Vec3.unitX);
    }
    linear_algebra_1.Mat4.setTranslation(tmpMat, p);
    linear_algebra_1.Mat4.mul(tmpMat, tmpMat, linear_algebra_1.Mat4.rotX90);
    var circle = (0, circle_1.Circle)({ radius: radius, segments: 64 });
    return (0, primitive_1.transformPrimitive)(circle, tmpMat);
}
var sphereMap = new Map();
function getSphere(detail) {
    var sphere = sphereMap.get(detail);
    if (sphere === undefined) {
        sphere = (0, sphere_1.Sphere)(detail);
        sphereMap.set(detail, sphere);
    }
    return sphere;
}
exports.getSphere = getSphere;
function addSphere(builder, center, radius, detail) {
    builder.add(center[0], center[1], center[2], detail);
}
exports.addSphere = addSphere;
function getPharmacophoreSphere1(ctx, _, props, shape) {
    var center = props.center, radius = props.radius, radiusFactor = props.radiusFactor;
    var builder = spheres_builder_1.SpheresBuilder.create(128, 64);
    addSphere(builder, center, radius, 0);
    return shape_1.Shape.create('pharmacophore-sphere-1', (0, tslib_1.__assign)((0, tslib_1.__assign)({}, props), { sizeFactor: props.radius * 0.1 }), builder.getSpheres(), function () { return props.color; }, function () { return radius * radiusFactor / 2; }, function () { return 'pharmacophore'; });
}
exports.getPharmacophoreSphere1 = getPharmacophoreSphere1;
function getPharmacophoreSphere2(ctx, _, props, shape) {
    var center = props.center, radius = props.radius, vec = props.vec, radiusFactor = props.radiusFactor;
    var newCenter = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.add(newCenter, center, vec);
    var builder = spheres_builder_1.SpheresBuilder.create(128, 64);
    addSphere(builder, newCenter, radius, 1);
    return shape_1.Shape.create('pharmacophore-sphere-2', (0, tslib_1.__assign)((0, tslib_1.__assign)({}, props), { sizeFactor: props.radius * 0.1 }), builder.getSpheres(), function () { return props.color; }, function () { return radius * radiusFactor / 2; }, function () { return 'pharmacophore'; });
}
exports.getPharmacophoreSphere2 = getPharmacophoreSphere2;
function getArrowCylinder(ctx, _, props, shape) {
    var center = props.center, vec = props.vec;
    // 单位向量
    var unitVec = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.normalize(unitVec, vec);
    var gap = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.scale(gap, unitVec, 0.25);
    var moveVec = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.sub(moveVec, vec, gap);
    var newCenter = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.add(newCenter, center, moveVec);
    var moveVec1 = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.scale(moveVec1, unitVec, 0.3);
    linear_algebra_1.Vec3.sub(newCenter, newCenter, moveVec1);
    var builder = cylinders_builder_1.CylindersBuilder.create(128, 64);
    builder.add(center[0], center[1], center[2], newCenter[0], newCenter[1], newCenter[2], 0.025, true, true, 2);
    return shape_1.Shape.create('pharmacophore-cylinder', props, builder.getCylinders(), function () { return props.color; }, function () { return props.sizeFactor; }, function () { return 'pharmacophore'; });
}
function getArrowHead(ctx, _, props, mesh) {
    var center = props.center, vec = props.vec;
    // 单位向量
    var unitVec = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.normalize(unitVec, vec);
    var gap = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.scale(gap, unitVec, 0.25);
    var moveVec11 = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.sub(moveVec11, vec, gap);
    var newCenter = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.add(newCenter, center, moveVec11);
    // 底部三角形中心
    var triangleCenter = linear_algebra_1.Vec3.create(0, 0, 0);
    var moveVec1 = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.scale(moveVec1, unitVec, 0.3);
    linear_algebra_1.Vec3.sub(triangleCenter, newCenter, moveVec1);
    // fix
    // 底部三角形所处的面的单位向量
    // 硬性赋xy为1会出现vec[2]为0时无法计算的bug
    var triangleUnitVec = linear_algebra_1.Vec3.create(0, 0, 0);
    var trianglePointVec = linear_algebra_1.Vec3.create(1, 2, triangleCenter[2] - (unitVec[0] * (1 - triangleCenter[0]) + unitVec[1] * (2 - triangleCenter[1])) / unitVec[2]);
    linear_algebra_1.Vec3.sub(triangleUnitVec, trianglePointVec, triangleCenter);
    linear_algebra_1.Vec3.normalize(triangleUnitVec, triangleUnitVec);
    // 底部三角形中心移动到顶点的向量
    var moveVec = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.scale(moveVec, triangleUnitVec, 0.3);
    // 底部三角形顶点1
    var triangleVertex1 = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.add(triangleVertex1, triangleCenter, moveVec);
    var triangleBaseVec = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.sub(triangleBaseVec, triangleVertex1, triangleCenter);
    // 根据vec旋转得到另外两个顶点坐标
    var triangleVertex2 = linear_algebra_1.Vec3.create(0, 0, 0);
    {
        // vcosθ
        var v1 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.scale(v1, triangleBaseVec, Math.cos(120 * Math.PI / 180));
        // u*vsinθ
        var v2 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.cross(v2, unitVec, triangleBaseVec);
        linear_algebra_1.Vec3.scale(v2, v2, Math.sin(120 * Math.PI / 180));
        // (u·v)u(1-cosθ)
        var v3 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.scale(v3, unitVec, linear_algebra_1.Vec3.dot(unitVec, triangleBaseVec) * (1 - Math.cos(120 * Math.PI / 180)));
        linear_algebra_1.Vec3.add(triangleVertex2, v1, v2);
        linear_algebra_1.Vec3.add(triangleVertex2, triangleVertex2, v3);
        // const res = Vec3.create(0, 0, 0)
        // Vec3.sub(res, triangleVertex2, triangleCenter)
        // Vec3.normalize(res, res)
        // Vec3.scale(res, res, 0.15)
        // Vec3.add(triangleVertex2, res, triangleCenter)
        linear_algebra_1.Vec3.add(triangleVertex2, triangleVertex2, triangleCenter);
    }
    var triangleVertex3 = linear_algebra_1.Vec3.create(0, 0, 0);
    {
        // vcosθ
        var v1 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.scale(v1, triangleBaseVec, Math.cos(240 * Math.PI / 180));
        // u*vsinθ
        var v2 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.cross(v2, unitVec, triangleBaseVec);
        linear_algebra_1.Vec3.scale(v2, v2, Math.sin(240 * Math.PI / 180));
        // (u·v)u(1-cosθ)
        var v3 = linear_algebra_1.Vec3.create(0, 0, 0);
        linear_algebra_1.Vec3.scale(v3, unitVec, linear_algebra_1.Vec3.dot(unitVec, triangleBaseVec) * (1 - Math.cos(240 * Math.PI / 180)));
        linear_algebra_1.Vec3.add(triangleVertex3, v1, v2);
        linear_algebra_1.Vec3.add(triangleVertex3, triangleVertex3, v3);
        // const res = Vec3.create(0, 0, 0)
        // Vec3.sub(res, triangleVertex3, triangleCenter)
        // Vec3.normalize(res, res)
        // Vec3.scale(res, res, 0.15)
        // Vec3.add(triangleVertex3, res, triangleCenter)
        linear_algebra_1.Vec3.add(triangleVertex3, triangleVertex3, triangleCenter);
    }
    var builderState = mesh_builder_1.MeshBuilder.createState(128, 64);
    var vertex = [newCenter[0], newCenter[1], newCenter[2], triangleVertex1[0], triangleVertex1[1], triangleVertex1[2], triangleVertex2[0], triangleVertex2[1], triangleVertex2[2], triangleVertex3[0], triangleVertex3[1], triangleVertex3[2]];
    var tetrahedron = (0, tetrahedron_1.Tetrahedron1)(vertex);
    var mat4 = linear_algebra_1.Mat4.ofRows([
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1.0]
    ]);
    var toFractional = linear_algebra_1.Mat4.invert(linear_algebra_1.Mat4.zero(), mat4);
    mesh_builder_1.MeshBuilder.addPrimitive(builderState, toFractional, tetrahedron);
    return shape_1.Shape.create('axes', {}, mesh_builder_1.MeshBuilder.getMesh(builderState), function () { return props.color; }, function () { return 0.15; }, function () { return ''; });
}
function getPharmacophoreParams(ctx) {
    return param_definition_1.ParamDefinition.clone(exports.PharmacophoreParams);
}
exports.getPharmacophoreParams = getPharmacophoreParams;
function PharmacophoreRepresentation(ctx, getParams) {
    var res = representation_1.Representation.createMulti('Pharmacophore', ctx, getParams, representation_2.StructureRepresentationStateBuilder, PharmacophoreVisuals);
    res.setState({ markerActions: marker_action_1.MarkerActions.All });
    return res;
}
exports.PharmacophoreRepresentation = PharmacophoreRepresentation;
//# sourceMappingURL=pharmacophore.js.map