"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RotateArrowManager = exports.InteractionLineOrderLabelTag = exports.RotateArrowGroupTag = void 0;
var tslib_1 = require("tslib");
var commands_1 = require("../../../mol-plugin/commands");
var mol_state_1 = require("../../../mol-state");
var component_1 = require("../../component");
var transforms_1 = require("../../transforms");
exports.RotateArrowGroupTag = 'Rotate-Arrow-group';
exports.InteractionLineOrderLabelTag = 'Interaction-line-order-label';
var RotateArrowManager = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(RotateArrowManager, _super);
    function RotateArrowManager(plugin) {
        var _this = _super.call(this, {
            interactionLine: []
        }) || this;
        _this.plugin = plugin;
        _this.behaviors = {
            state: _this.ev.behavior(_this.state)
        };
        _this._empty = [];
        plugin.state.data.events.changed.subscribe(function (e) {
            if (e.inTransaction || plugin.behaviors.state.isAnimating.value)
                return;
            _this.sync();
        });
        plugin.behaviors.state.isAnimating.subscribe(function (isAnimating) {
            if (!isAnimating && !plugin.behaviors.state.isUpdating.value)
                _this.sync();
        });
        return _this;
    }
    RotateArrowManager.prototype.stateUpdated = function () {
        this.behaviors.state.next(this.state);
    };
    RotateArrowManager.prototype.getTransforms = function (transformer) {
        var state = this.plugin.state.data;
        var groupRef = mol_state_1.StateSelection.findTagInSubtree(state.tree, mol_state_1.StateTransform.RootRef, exports.RotateArrowGroupTag);
        var ret = groupRef
            ? state.select(mol_state_1.StateSelection.Generators.ofTransformer(transformer, groupRef))
            : this._empty;
        if (ret.length === 0)
            return this._empty;
        return ret;
    };
    RotateArrowManager.prototype.sync = function () {
        var labels = [];
        for (var _i = 0, _a = this.getTransforms(transforms_1.StateTransforms.Representation.StructureSelectionsLabel3D); _i < _a.length; _i++) {
            var cell = _a[_i];
            var tags = cell.obj['tags'];
            if (!tags || !tags.includes(exports.InteractionLineOrderLabelTag))
                labels.push(cell);
        }
        var updated = this.updateState({
            interactionLine: this.getTransforms(transforms_1.StateTransforms.Representation.StructureSelectionsInteractionLine3D)
        });
        if (updated)
            this.stateUpdated();
    };
    RotateArrowManager.prototype.getGroup = function () {
        var state = this.plugin.state.data;
        var groupRef = mol_state_1.StateSelection.findTagInSubtree(state.tree, mol_state_1.StateTransform.RootRef, exports.RotateArrowGroupTag);
        var builder = this.plugin.state.data.build();
        if (groupRef)
            return builder.to(groupRef);
        return builder
            .toRoot()
            .group(transforms_1.StateTransforms.Misc.CreateGroup, { label: "Rotate Arrow Group" }, { tags: exports.RotateArrowGroupTag });
    };
    RotateArrowManager.prototype.findStructure = function (structure, needMerge) {
        if (needMerge === void 0) { needMerge = true; }
        var cells = Array.from(this.plugin.state.data.cells).map(function (item) { return item[1]; });
        var mergedCell = cells.filter(function (item) { var _a; return ((_a = item.obj) === null || _a === void 0 ? void 0 : _a.label) === 'Merged Structure'; });
        var res = cells.filter(function (item) {
            var _a, _b;
            return item.transform.parent ===
                (needMerge ? mergedCell[1].transform.ref : item.transform.parent) &&
                ((_b = (_a = item.obj) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.model) === (structure === null || structure === void 0 ? void 0 : structure.model);
        });
        return res[0];
    };
    RotateArrowManager.prototype.addRotateArrow = function (center, vec, params) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var update, res, state;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        update = this.getGroup();
                        return [4 /*yield*/, update
                                .apply(transforms_1.StateTransforms.Model.MultiStructureSelectionFromExpression, { label: 'RotateArrow' })
                                .apply(transforms_1.StateTransforms.Representation.RotateArrow3D, (0, tslib_1.__assign)({ center: center, vec: vec, visuals: ['rotate-arrow-cylinder', 'rotate-arrow-arrowhead'] }, params))];
                    case 1:
                        res = _a.sent();
                        state = this.plugin.state.data;
                        return [4 /*yield*/, commands_1.PluginCommands.State.Update(this.plugin, {
                                state: state,
                                tree: update,
                                options: { doNotLogTiming: true }
                            })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, res.ref];
                }
            });
        });
    };
    return RotateArrowManager;
}(component_1.StatefulPluginComponent));
exports.RotateArrowManager = RotateArrowManager;
//# sourceMappingURL=rotate-arrow.js.map