import { Canvas3D, PartialCanvas3DProps } from '../mol-canvas3d/canvas3d';
import { UUID } from '../mol-util';
import { CameraManager } from './managers/camera';
import { RepresentationManager } from './managers/representation/index';
import { Cell, CellItem, Format, Granularity, RepresentationType } from './types';
import { CellManager } from './managers/cell';
import { TrajectoryManager } from './managers/trajectory';
import { SnapshotManager } from './managers/snapshot';
import { ParamDefinition as PD } from '../mol-util/param-definition';
import { SelectionManager } from './managers/selection/index';
import { EventsManager } from './managers/events';
import { EditorManager } from './managers/editor';
import { HighlightManager } from './managers/highlight';
import { AtomHierarchy } from './utils';
import { Color } from '../mol-util/color';
import { ViewportScreenshotHelper } from './managers/viewport-screenshot';
export declare const DefaultCanvas3DParams: PD.Values<{
    camera: PD.Group<PD.Normalize<{
        mode: "perspective" | "orthographic";
        helper: PD.Normalize<{
            axes: any;
        }>;
        stereo: PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
            eyeSeparation: any;
            focus: any;
        }>, "on">;
        manualReset: boolean;
    }>>;
    cameraFog: PD.Mapped<PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
        intensity: number;
    }>, "on">>;
    cameraClipping: PD.Group<PD.Normalize<{
        radius: number;
        far: boolean;
    }>>;
    viewport: PD.Mapped<PD.NamedParams<PD.Normalize<unknown>, "canvas"> | PD.NamedParams<PD.Normalize<{
        x: number;
        y: number;
        width: number;
        height: number;
    }>, "static-frame"> | PD.NamedParams<PD.Normalize<{
        x: number;
        y: number;
        width: number;
        height: number;
    }>, "relative-frame">>;
    cameraResetDurationMs: PD.Numeric;
    transparentBackground: PD.BooleanParam;
    multiSample: PD.Group<PD.Normalize<{
        mode: string;
        sampleLevel: number;
    }>>;
    postprocessing: PD.Group<PD.Normalize<{
        occlusion: PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
            samples: any;
            radius: any;
            bias: any;
            blurKernelSize: any;
            resolutionScale: any;
        }>, "on">;
        outline: PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
            scale: any;
            threshold: any;
            color: any;
        }>, "on">;
        antialiasing: PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
            edgeThreshold: any;
            maxSearchSteps: any;
        }>, "smaa"> | PD.NamedParams<PD.Normalize<{
            edgeThresholdMin: any;
            edgeThresholdMax: any;
            iterations: any;
            subpixelQuality: any;
        }>, "fxaa">;
    }>>;
    marking: PD.Group<PD.Normalize<{
        enabled: boolean;
        highlightEdgeColor: Color;
        selectEdgeColor: Color;
        edgeScale: number;
        ghostEdgeStrength: number;
        innerEdgeFactor: number;
    }>>;
    renderer: PD.Group<PD.Normalize<{
        backgroundColor: Color;
        pickingAlphaThreshold: number;
        interiorDarkening: number;
        interiorColorFlag: boolean;
        interiorColor: Color;
        highlightColor: Color;
        selectColor: Color;
        highlightStrength: number;
        selectStrength: number;
        markerPriority: number;
        xrayEdgeFalloff: number;
        light: PD.Normalize<{
            inclination: number;
            azimuth: number;
            color: Color;
            intensity: number;
        }>[];
        ambientColor: Color;
        ambientIntensity: number;
        invalidColor: Color;
        invalidStrength: number;
    }>>;
    trackball: PD.Group<PD.Normalize<{
        noScroll: boolean;
        rotateSpeed: number;
        zoomSpeed: number;
        panSpeed: number;
        animate: PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
            speed: any;
        }>, "spin"> | PD.NamedParams<PD.Normalize<{
            speed: any;
            angle: any;
        }>, "rock">;
        staticMoving: boolean;
        dynamicDampingFactor: number;
        minDistance: number;
        maxDistance: number;
        gestureScaleFactor: number;
        maxWheelDelta: number;
        bindings: {
            dragRotate: import("../mol-util/binding").Binding;
            dragRotateZ: import("../mol-util/binding").Binding;
            dragPan: import("../mol-util/binding").Binding;
            dragZoom: import("../mol-util/binding").Binding;
            dragFocus: import("../mol-util/binding").Binding;
            dragFocusZoom: import("../mol-util/binding").Binding;
            scrollZoom: import("../mol-util/binding").Binding;
            scrollFocus: import("../mol-util/binding").Binding;
            scrollFocusZoom: import("../mol-util/binding").Binding;
        };
        autoAdjustMinMaxDistance: PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
            minDistanceFactor: any;
            minDistancePadding: any;
            maxDistanceFactor: any;
            maxDistanceMin: any;
        }>, "on">;
    }>>;
    interaction: PD.Group<PD.Normalize<{
        maxFps: number;
        preferAtomPixelPadding: number;
    }>>;
    debug: PD.Group<PD.Normalize<{
        sceneBoundingSpheres: boolean;
        visibleSceneBoundingSpheres: boolean;
        objectBoundingSpheres: boolean;
        instanceBoundingSpheres: boolean;
    }>>;
    handle: PD.Group<PD.Normalize<{
        handle: PD.NamedParams<PD.Normalize<unknown>, "off"> | PD.NamedParams<PD.Normalize<{
            alpha: any;
            ignoreLight: any;
            colorX: any;
            colorY: any;
            colorZ: any;
            scale: any;
            doubleSided: any;
            flipSided: any;
            flatShaded: any;
            xrayShaded: any;
            bumpFrequency: any;
            bumpAmplitude: any;
            quality: any;
            material: any;
            clip: any;
        }>, "on">;
    }>>;
}>;
export declare class LightPlugin {
    static Utils: {
        sliceCellItems: (items: CellItem[], type: Granularity) => {
            ref: string;
            elementIds: number[];
            props: Partial<AtomHierarchy>;
        }[];
        queryCellItems: (items?: CellItem[] | undefined) => {
            [key: string]: {
                [key: string]: CellItem[];
            };
        };
        exportToPdb: (item: CellItem) => Promise<string>;
        getBox: (item: CellItem) => Promise<{
            center: import("../mol-math/linear-algebra/3d/vec3").Vec3;
            size: import("../mol-math/linear-algebra/3d/vec3").Vec3;
        }>;
        splitMolecularContent: (content: string, format: Format) => string[];
        checkMolecularContentVerify: (content: string, format: Format) => import("./types").MolecularFileFormatErrorLine[];
        getMergedContent: (items: CellItem[]) => Promise<{
            format: string;
            type: import("./utils").MIME;
            content: string;
        }>;
        traverseAtoms: (ref: string, callback: (atomHierarchy: AtomHierarchy) => void) => Promise<void>;
    };
    canvas3d?: Canvas3D;
    layout?: {
        root: HTMLElement;
        canvas: HTMLCanvasElement;
    };
    cells: Map<UUID, Cell>;
    managers: {
        camera: CameraManager;
        representation: RepresentationManager;
        cell: CellManager;
        trajectory: TrajectoryManager;
        snapshot: SnapshotManager;
        selection: SelectionManager;
        events: EventsManager;
        highlight: HighlightManager;
        editor: EditorManager;
        screenshot: ViewportScreenshotHelper;
    };
    constructor();
    createCanvas(root: HTMLElement, props?: PartialCanvas3DProps): void;
    focus(items: CellItem[], isRecurve?: boolean): Promise<{
        ref: string;
    }[]>;
    show(items: CellItem[], isRecurve?: boolean): Promise<void>;
    hide(items: CellItem[], isRecurve?: boolean): void;
    toggle(params: {
        types: RepresentationType[];
        forceAction?: 'show' | 'hide';
        refs?: UUID[];
    }): void;
    refresh(params?: {
        fixCamera?: boolean;
    }): void;
    clear(): void;
    dispose(): void;
}
export declare const lightPlugin: LightPlugin;
export * from './types';
