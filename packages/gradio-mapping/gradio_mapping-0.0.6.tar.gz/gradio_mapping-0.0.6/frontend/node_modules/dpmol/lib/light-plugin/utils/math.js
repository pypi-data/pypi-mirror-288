"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBox = exports.getDragOffset = exports.rotateArbitraryLine = void 0;
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var loci_1 = require("./loci");
var structure_1 = require("../../mol-model/structure/structure");
var rotateArbitraryLine = function (v1, v2, theta, point) {
    var pOut = [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ];
    var a = v1[0], b = v1[1], c = v1[2];
    var subtractVectors = function (v1, v2) {
        return [v2[0] - v1[0], v2[1] - v1[1], v2[2] - v1[2]];
    };
    var normalizeVector = function (v) {
        var res = linear_algebra_1.Vec3.create(v[0], v[1], v[2]);
        linear_algebra_1.Vec3.normalize(res, res);
        return [res[0], res[1], res[2]];
    };
    var p = normalizeVector(subtractVectors(v1, v2));
    var u = p[0], v = p[1], w = p[2];
    var uu = u * u;
    var uv = u * v;
    var uw = u * w;
    var vv = v * v;
    var vw = v * w;
    var ww = w * w;
    var au = a * u;
    var av = a * v;
    var aw = a * w;
    var bu = b * u;
    var bv = b * v;
    var bw = b * w;
    var cu = c * u;
    var cv = c * v;
    var cw = c * w;
    var costheta = Math.cos(theta * (Math.PI / 180));
    var sintheta = Math.sin(theta * (Math.PI / 180));
    pOut[0][0] = uu + (vv + ww) * costheta;
    pOut[0][1] = uv * (1 - costheta) + w * sintheta;
    pOut[0][2] = uw * (1 - costheta) - v * sintheta;
    pOut[0][3] = 0;
    pOut[1][0] = uv * (1 - costheta) - w * sintheta;
    pOut[1][1] = vv + (uu + ww) * costheta;
    pOut[1][2] = vw * (1 - costheta) + u * sintheta;
    pOut[1][3] = 0;
    pOut[2][0] = uw * (1 - costheta) + v * sintheta;
    pOut[2][1] = vw * (1 - costheta) - u * sintheta;
    pOut[2][2] = ww + (uu + vv) * costheta;
    pOut[2][3] = 0;
    pOut[3][0] =
        (a * (vv + ww) - u * (bv + cw)) * (1 - costheta) + (bw - cv) * sintheta;
    pOut[3][1] =
        (b * (uu + ww) - v * (au + cw)) * (1 - costheta) + (cu - aw) * sintheta;
    pOut[3][2] =
        (c * (uu + vv) - w * (au + bv)) * (1 - costheta) + (av - bu) * sintheta;
    pOut[3][3] = 1;
    var res = [
        point[0] * pOut[0][0] +
            point[1] * pOut[1][0] +
            point[2] * pOut[2][0] +
            pOut[3][0],
        point[0] * pOut[0][1] +
            point[1] * pOut[1][1] +
            point[2] * pOut[2][1] +
            pOut[3][1],
        point[0] * pOut[0][2] +
            point[1] * pOut[1][2] +
            point[2] * pOut[2][2] +
            pOut[3][2]
    ];
    return res;
};
exports.rotateArbitraryLine = rotateArbitraryLine;
var getDragOffset = function (plugin, start, end) {
    var _a, _b, _c, _d, _e, _f;
    if (!plugin.canvas3d) {
        return linear_algebra_1.Vec3.create(0, 0, 0);
    }
    var mouseChange = linear_algebra_1.Vec2.create(0, 0);
    var offset = linear_algebra_1.Vec3.create(0, 0, 0);
    var up = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec2.sub(mouseChange, linear_algebra_1.Vec2.copy(mouseChange, end), start);
    if (linear_algebra_1.Vec2.squaredMagnitude(mouseChange)) {
        var factor = (_b = (_a = plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.input.pixelRatio) !== null && _b !== void 0 ? _b : 1;
        mouseChange[0] *=
            (1 / plugin.canvas3d.camera.zoom) *
                plugin.canvas3d.camera.viewport.width *
                factor;
        mouseChange[1] *=
            (1 / plugin.canvas3d.camera.zoom) *
                plugin.canvas3d.camera.viewport.height *
                factor *
                (((_d = (_c = plugin.layout) === null || _c === void 0 ? void 0 : _c.canvas.clientWidth) !== null && _d !== void 0 ? _d : 1) /
                    ((_f = (_e = plugin.layout) === null || _e === void 0 ? void 0 : _e.canvas.clientHeight) !== null && _f !== void 0 ? _f : 1));
        linear_algebra_1.Vec3.cross(offset, linear_algebra_1.Vec3.sub(offset, plugin.canvas3d.camera.position, plugin.canvas3d.camera.target), plugin.canvas3d.camera.up);
        linear_algebra_1.Vec3.setMagnitude(offset, offset, mouseChange[0]);
        linear_algebra_1.Vec3.setMagnitude(up, plugin.canvas3d.camera.up, mouseChange[1]);
        linear_algebra_1.Vec3.add(offset, offset, up);
        linear_algebra_1.Vec3.scale(offset, offset, 1 / 2100);
        // 1Å = 2100（手动测试得出）
        return offset;
    }
    return linear_algebra_1.Vec3.create(0, 0, 0);
};
exports.getDragOffset = getDragOffset;
var getBox = function (structure, elementIds) {
    var boundaryData = structure_1.StructureElement.Loci.getBoundary((0, loci_1.getLoci)(structure, elementIds));
    return {
        center: linear_algebra_1.Vec3.create((boundaryData.box.max[0] + boundaryData.box.min[0]) / 2, (boundaryData.box.max[1] + boundaryData.box.min[1]) / 2, (boundaryData.box.max[2] + boundaryData.box.min[2]) / 2),
        size: linear_algebra_1.Vec3.create(boundaryData.box.max[0] - boundaryData.box.min[0], boundaryData.box.max[1] - boundaryData.box.min[1], boundaryData.box.max[2] - boundaryData.box.min[2])
    };
};
exports.getBox = getBox;
//# sourceMappingURL=math.js.map