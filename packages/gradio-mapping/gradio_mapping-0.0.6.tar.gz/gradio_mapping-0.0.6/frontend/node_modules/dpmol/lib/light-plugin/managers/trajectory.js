"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrajectoryManager = void 0;
var tslib_1 = require("tslib");
var utils_1 = require("../utils");
var types_1 = require("../types");
var model_1 = require("../model");
var trajectory_1 = require("../representation/trajectory");
var structure_1 = require("../../mol-model/structure");
var rx_event_helper_1 = require("../../mol-util/rx-event-helper");
var representation_1 = require("../representation");
var gro_traj_1 = require("../model/gro-traj");
var TrajectoryManager = /** @class */ (function () {
    function TrajectoryManager(plugin) {
        this.ev = rx_event_helper_1.RxEventHelper.create();
        this.updated = this.ev();
        this.plugin = plugin;
        this.paused = false;
    }
    // coords 支持的类型需要多一点
    TrajectoryManager.prototype.import = function (data, coordsData) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var structureData, model, coordinatesBlob, coordinates, trajectory, elementIds;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.readAsString)(data.data)];
                    case 1:
                        structureData = _a.sent();
                        return [4 /*yield*/, model_1.FormatProvider[data.format].parse(structureData)];
                    case 2:
                        model = _a.sent();
                        return [4 /*yield*/, (0, utils_1.readAsBlob)(coordsData.data)];
                    case 3:
                        coordinatesBlob = _a.sent();
                        return [4 /*yield*/, model_1.FormatProvider[coordsData.format].parse(coordinatesBlob)];
                    case 4:
                        coordinates = _a.sent();
                        return [4 /*yield*/, trajectory_1.TrajectoryRepr.create({
                                model: data.format === types_1.Format.Gro ? model : model[0].model,
                                coordinates: coordinates,
                                frameIndex: 0
                            }, this.plugin.managers.representation.ctx)];
                    case 5:
                        trajectory = _a.sent();
                        elementIds = (0, utils_1.getElementIdsByLoci)(structure_1.Structure.toStructureElementLoci(data.format === types_1.Format.Gro ? structure_1.Structure.ofModel(trajectory.model.frames[0], { dynamicBonds: true }) : model[0]));
                        return [2 /*return*/, this.plugin.managers.cell.create({
                                representations: trajectory.reprs.map(function (repr) { return ((0, tslib_1.__assign)({ isHidden: false }, repr)); }),
                                model: {
                                    trajectory: {
                                        state: trajectory.model,
                                        frameIndex: 0
                                    }
                                },
                                assets: [
                                    { data: structureData, format: data.format },
                                    { data: coordinatesBlob, format: coordsData.format }
                                ],
                                theme: {
                                    color: {
                                        Atom: [
                                            (0, tslib_1.__assign)({ elementIds: elementIds }, this.plugin.managers.representation.defaultTheme.color[types_1.ThemeC.ATOM]),
                                        ],
                                        Ribbon: [
                                            (0, tslib_1.__assign)({ elementIds: elementIds }, this.plugin.managers.representation.defaultTheme.color[types_1.ThemeC.RIBBON]),
                                        ]
                                    },
                                }
                            })];
                }
            });
        });
    };
    TrajectoryManager.prototype.importWithGro = function (data) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var structureData, trajectory, trajectoryRepr;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, utils_1.readAsString)(data.data)];
                    case 1:
                        structureData = _a.sent();
                        return [4 /*yield*/, gro_traj_1.GroTrajModel.parse(structureData)];
                    case 2:
                        trajectory = _a.sent();
                        return [4 /*yield*/, trajectory_1.TrajectoryRepr.createByTrajectory({ trajectory: trajectory, frameIndex: 0 }, this.plugin.managers.representation.ctx)];
                    case 3:
                        trajectoryRepr = _a.sent();
                        return [2 /*return*/, this.plugin.managers.cell.create({
                                representations: trajectoryRepr.reprs.map(function (repr) { return ((0, tslib_1.__assign)({ isHidden: false }, repr)); }),
                                model: {
                                    trajectory: {
                                        state: trajectoryRepr.model,
                                        frameIndex: 0
                                    }
                                },
                                assets: [
                                    { data: structureData, format: data.format },
                                ],
                            })];
                }
            });
        });
    };
    TrajectoryManager.prototype.getTrajectoryCell = function (ref) {
        var cells = [];
        if (ref) {
            var cell = this.plugin.cells.get(ref);
            if (!(cell === null || cell === void 0 ? void 0 : cell.model.trajectory))
                return [];
            cells.push(cell);
        }
        else {
            this.plugin.cells.forEach(function (cell) {
                if (cell.model.trajectory) {
                    cells.push(cell);
                }
            });
        }
        return cells;
    };
    TrajectoryManager.prototype.play = function (ref) {
        var _this = this;
        this.paused = false;
        var auto = function () {
            _this.next(ref);
            if (!_this.paused) {
                window.requestAnimationFrame(auto);
            }
        };
        window.requestAnimationFrame(auto);
    };
    TrajectoryManager.prototype.next = function (ref) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var cells, _i, cells_1, cell, _a, state, frameIndex, newFrameIndex;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        cells = this.getTrajectoryCell(ref);
                        _i = 0, cells_1 = cells;
                        _b.label = 1;
                    case 1:
                        if (!(_i < cells_1.length)) return [3 /*break*/, 4];
                        cell = cells_1[_i];
                        _a = cell.model.trajectory, state = _a.state, frameIndex = _a.frameIndex;
                        newFrameIndex = frameIndex >= state.frameCount - 1 ? 0 : frameIndex + 1;
                        return [4 /*yield*/, trajectory_1.TrajectoryRepr.update(
                            // Repr State Cache
                            Array.from(cell.representations).map(function (_a) {
                                var type = _a[0], r = _a[1];
                                return r.state;
                            }), {
                                trajectory: state,
                                frameIndex: newFrameIndex
                            }, this.plugin.managers.representation.ctx)];
                    case 2:
                        _b.sent();
                        cell.model.trajectory.frameIndex = newFrameIndex;
                        this.updateDependencyByCells(ref);
                        if (ref) {
                            this.updated.next({ ref: ref, frame: newFrameIndex });
                        }
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    TrajectoryManager.prototype.setFrameIndex = function (frameIndex, ref) {
        var _a;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var cells, _i, cells_2, cell;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        cells = this.getTrajectoryCell(ref);
                        _i = 0, cells_2 = cells;
                        _b.label = 1;
                    case 1:
                        if (!(_i < cells_2.length)) return [3 /*break*/, 4];
                        cell = cells_2[_i];
                        return [4 /*yield*/, trajectory_1.TrajectoryRepr.update(
                            // Repr State Cache
                            Array.from(cell.representations).map(function (_a) {
                                var type = _a[0], r = _a[1];
                                return r.state;
                            }), {
                                trajectory: (_a = cell.model.trajectory) === null || _a === void 0 ? void 0 : _a.state,
                                frameIndex: frameIndex
                            }, this.plugin.managers.representation.ctx)];
                    case 2:
                        _b.sent();
                        cell.model.trajectory.frameIndex = frameIndex;
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    TrajectoryManager.prototype.updateDependencyByCells = function (ref) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var trajectoryCells, _i, trajectoryCells_1, trajectoryCell, _loop_1, this_1, _a, _b, dependencyRef;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_c) {
                trajectoryCells = this.getTrajectoryCell(ref);
                for (_i = 0, trajectoryCells_1 = trajectoryCells; _i < trajectoryCells_1.length; _i++) {
                    trajectoryCell = trajectoryCells_1[_i];
                    if (trajectoryCell.dependency.by.length) {
                        _loop_1 = function (dependencyRef) {
                            var cell = this_1.plugin.cells.get(dependencyRef);
                            if (cell) {
                                cell.representations.forEach(function (representation, type) {
                                    if (type === types_1.RepresentationType.IntraInteractions) {
                                        _this.plugin.managers.representation.showGlobalInteraction(true, 'lightPlugin.managers.trajectory.updateDependencyByCells');
                                    }
                                    if (Object.keys(representation_1.MeasurementRepresentation).includes(type)) {
                                        _this.plugin.managers.representation.updateMeasurement({
                                            items: cell.dependency.on,
                                            ref: dependencyRef
                                        });
                                    }
                                });
                            }
                        };
                        this_1 = this;
                        for (_a = 0, _b = trajectoryCell.dependency.by; _a < _b.length; _a++) {
                            dependencyRef = _b[_a];
                            _loop_1(dependencyRef);
                        }
                    }
                }
                return [2 /*return*/];
            });
        });
    };
    TrajectoryManager.prototype.pause = function () {
        this.paused = true;
    };
    return TrajectoryManager;
}());
exports.TrajectoryManager = TrajectoryManager;
//# sourceMappingURL=trajectory.js.map