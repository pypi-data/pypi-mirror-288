"use strict";
/**
 * Copyright (c) 2017-2022 Mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComponentBond = void 0;
var mmcif_1 = require("../../../../mol-io/reader/cif/schema/mmcif");
var cif_1 = require("../../../../mol-io/writer/cif");
var db_1 = require("../../../../mol-data/db");
var property_1 = require("../../common/property");
var ComponentBond;
(function (ComponentBond) {
    ComponentBond.Descriptor = {
        name: 'chem_comp_bond',
        cifExport: {
            prefix: '',
            categories: [
                {
                    name: 'chem_comp_bond',
                    instance: function (ctx) {
                        var p = ComponentBond.Provider.get(ctx.firstModel);
                        if (!p)
                            return cif_1.CifWriter.Category.Empty;
                        var chem_comp_bond = p.data;
                        if (!chem_comp_bond)
                            return cif_1.CifWriter.Category.Empty;
                        var comp_names = ctx.structures[0].uniqueResidueNames;
                        var comp_id = chem_comp_bond.comp_id, _rowCount = chem_comp_bond._rowCount;
                        var indices = [];
                        for (var i = 0; i < _rowCount; i++) {
                            if (comp_names.has(comp_id.value(i)))
                                indices[indices.length] = i;
                        }
                        return cif_1.CifWriter.Category.ofTable(chem_comp_bond, indices);
                    }
                }
            ]
        }
    };
    ComponentBond.Provider = property_1.FormatPropertyProvider.create(ComponentBond.Descriptor);
    function chemCompBondFromTable(model, table) {
        return db_1.Table.pick(table, mmcif_1.mmCIF_Schema.chem_comp_bond, function (i) {
            return model.properties.chemicalComponentMap.has(table.comp_id.value(i));
        });
    }
    ComponentBond.chemCompBondFromTable = chemCompBondFromTable;
    function getEntriesFromChemCompBond(data) {
        var entries = new Map();
        function addEntry(id) {
            // weird behavior when 'PRO' is requested - will report a single bond
            // between N and H because a later operation would override real content
            if (entries.has(id))
                return entries.get(id);
            var e = new Entry(id);
            entries.set(id, e);
            return e;
        }
        var comp_id = data.comp_id, atom_id_1 = data.atom_id_1, atom_id_2 = data.atom_id_2, value_order = data.value_order, pdbx_aromatic_flag = data.pdbx_aromatic_flag, _rowCount = data._rowCount;
        var entry = addEntry(comp_id.value(0));
        for (var i = 0; i < _rowCount; i++) {
            var id = comp_id.value(i);
            var nameA = atom_id_1.value(i);
            var nameB = atom_id_2.value(i);
            var order = value_order.value(i);
            var aromatic = pdbx_aromatic_flag.value(i) === 'Y';
            if (entry.id !== id) {
                entry = addEntry(id);
            }
            var flags = 1 /* Covalent */;
            var ord = 1;
            if (aromatic)
                flags |= 16 /* Aromatic */;
            switch (order.toLowerCase()) {
                case 'delo':
                    flags |= 16 /* Aromatic */;
                    break;
                case 'doub':
                    ord = 2;
                    break;
                case 'trip':
                    ord = 3;
                    break;
                case 'quad':
                    ord = 4;
                    break;
            }
            entry.add(nameA, nameB, ord, flags);
        }
        return entries;
    }
    ComponentBond.getEntriesFromChemCompBond = getEntriesFromChemCompBond;
    var Entry = /** @class */ (function () {
        function Entry(id) {
            this.id = id;
            this.map = new Map();
        }
        Entry.prototype.add = function (a, b, order, flags, swap) {
            if (swap === void 0) { swap = true; }
            var e = this.map.get(a);
            if (e !== void 0) {
                var f = e.get(b);
                if (f === void 0) {
                    e.set(b, { order: order, flags: flags });
                }
            }
            else {
                var map = new Map();
                map.set(b, { order: order, flags: flags });
                this.map.set(a, map);
            }
            if (swap)
                this.add(b, a, order, flags, false);
        };
        return Entry;
    }());
    ComponentBond.Entry = Entry;
})(ComponentBond = exports.ComponentBond || (exports.ComponentBond = {}));
//# sourceMappingURL=chem_comp.js.map