"use strict";
/**
 * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 *
 * based in part on NGL (https://github.com/arose/ngl)
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetalCoordinationProvider = exports.MetalBindingProvider = exports.MetalProvider = exports.DefaultMetalCoordinationParams = exports.MetalCoordinationParams = void 0;
var param_definition_1 = require("../../../mol-util/param-definition");
var features_1 = require("./features");
var util_1 = require("../chemistry/util");
var types_1 = require("../../../mol-model/structure/model/properties/atomic/types");
var common_1 = require("./common");
var types_2 = require("../../../mol-model/structure/model/types");
var atomic_1 = require("../../../mol-model/structure/model/properties/atomic");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
exports.MetalCoordinationParams = {
    distanceMax: param_definition_1.ParamDefinition.Numeric(3.0, { min: 1, max: 5, step: 0.1 })
};
exports.DefaultMetalCoordinationParams = param_definition_1.ParamDefinition.getDefaultValues(exports.MetalCoordinationParams);
var __MetalBondAtomRadii = { 7: 0.71 /* N */, 8: 0.63 /* O */, 16: 1.03 /* S */, 17: 0.99 /* Cl */, 35: 1.14 /* Br */, 53: 1.33 /* I */, 12: 1.39 /* Mg */, 23: 1.34 /* V */, 24: 1.22 /* Cr */, 25: 1.19 /* Mn */, 26: 1.16 /* Fe */, 27: 1.11 /* Co */, 28: 1.10 /* Ni */, 29: 1.12 /* Cu */, 30: 1.18 /* Zn */, 44: 1.25 /* Ru */, 45: 1.25 /* Rh */, 75: 1.31 /* Re */, 76: 1.29 /* Os */, 78: 1.23 /* Pt */, 79: 1.24 /* Au */ };
var IonicTypeMetals = [
    "LI" /* LI */,
    "NA" /* NA */,
    "K" /* K */,
    "RB" /* RB */,
    "CS" /* CS */,
    "MG" /* MG */,
    "CA" /* CA */,
    "SR" /* SR */,
    "BA" /* BA */,
    "AL" /* AL */,
    "GA" /* GA */,
    "IN" /* IN */,
    "TL" /* TL */,
    "SC" /* SC */,
    "SN" /* SN */,
    "PB" /* PB */,
    "BI" /* BI */,
    "SB" /* SB */,
    "HG" /* HG */
];
function addMetal(structure, unit, builder) {
    var elements = unit.elements;
    var _a = unit.model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;
    for (var i = 0, il = elements.length; i < il; ++i) {
        var element = (0, util_1.typeSymbol)(unit, i);
        var type = 0 /* None */;
        if (IonicTypeMetals.includes(element)) {
            type = 13 /* IonicTypeMetal */;
        }
        else if ((0, types_1.isTransitionMetal)(element) ||
            element === "ZN" /* ZN */ ||
            element === "CD" /* CD */) {
            type = 12 /* TransitionMetal */;
        }
        if (type) {
            builder.add(type, 0 /* None */, x[elements[i]], y[elements[i]], z[elements[i]], i);
        }
    }
}
function isProteinSidechain(atomname) {
    return !types_2.ProteinBackboneAtoms.has(atomname);
}
function isProteinBackbone(atomname) {
    return types_2.ProteinBackboneAtoms.has(atomname);
}
function isNucleicBackbone(atomname) {
    return types_2.NucleicBackboneAtoms.has(atomname);
}
/**
 * Metal binding partners (dative bond or ionic-type interaction)
 */
function addMetalBinding(structure, unit, builder) {
    var elements = unit.elements;
    var _a = unit.model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;
    for (var i = 0, il = elements.length; i < il; ++i) {
        var element = (0, util_1.typeSymbol)(unit, i);
        var resname = (0, util_1.compId)(unit, i);
        var atomname = (0, util_1.atomId)(unit, i);
        var dative = false;
        var ionic = false;
        var isStandardAminoacid = types_2.AminoAcidNames.has(resname);
        var isStandardBase = types_2.BaseNames.has(resname);
        if (!isStandardAminoacid && !isStandardBase) {
            if ((0, types_1.isHalogen)(element) ||
                element === "O" /* O */ ||
                element === "S" /* S */) {
                dative = true;
                ionic = true;
            }
            else if (element === "N" /* N */) {
                dative = true;
            }
        }
        else if (isStandardAminoacid) {
            // main chain oxygen atom or oxygen, nitrogen and sulfur from specific amino acids
            if (element === "O" /* O */) {
                if (['ASP', 'GLU', 'SER', 'THR', 'TYR', 'ASN', 'GLN'].includes(resname) &&
                    isProteinSidechain(atomname)) {
                    dative = true;
                    ionic = true;
                }
                else if (isProteinBackbone(atomname)) {
                    dative = true;
                    ionic = true;
                }
            }
            else if (element === "S" /* S */ &&
                (resname === 'CYS' || resname === 'MET')) {
                dative = true;
                ionic = true;
            }
            else if (element === "N" /* N */) {
                if (resname === 'HIS' && isProteinSidechain(atomname)) {
                    dative = true;
                }
            }
        }
        else if (isStandardBase) {
            // http://pubs.acs.org/doi/pdf/10.1021/acs.accounts.6b00253
            // http://onlinelibrary.wiley.com/doi/10.1002/anie.200900399/full
            if (element === "O" /* O */ && isNucleicBackbone(atomname)) {
                dative = true;
                ionic = true;
            }
            else if (['N3', 'N4', 'N7'].includes(atomname)) {
                dative = true;
            }
            else if (['O2', 'O4', 'O6'].includes(atomname)) {
                dative = true;
                ionic = true;
            }
        }
        if (dative) {
            builder.add(11 /* DativeBondPartner */, 0 /* None */, x[elements[i]], y[elements[i]], z[elements[i]], i);
        }
        if (ionic) {
            builder.add(10 /* IonicTypePartner */, 0 /* None */, x[elements[i]], y[elements[i]], z[elements[i]], i);
        }
    }
}
function isMetalCoordination(ti, tj) {
    if (ti === 12 /* TransitionMetal */) {
        return (tj === 11 /* DativeBondPartner */ || tj === 12 /* TransitionMetal */);
    }
    else if (ti === 13 /* IonicTypeMetal */) {
        return tj === 10 /* IonicTypePartner */;
    }
}
function testMetalCoordination(structure, infoA, infoB, distanceSq) {
    var typeA = infoA.types[infoA.feature];
    var typeB = infoB.types[infoB.feature];
    if (!isMetalCoordination(typeA, typeB) && !isMetalCoordination(typeB, typeA))
        return;
    var atomicNumberA = atomic_1.AtomicNumbers[(0, util_1.typeSymbol)(infoA.unit, infoA.members[infoA.offsets[infoA.feature]])];
    var atomicNumberB = atomic_1.AtomicNumbers[(0, util_1.typeSymbol)(infoB.unit, infoB.members[infoB.offsets[infoB.feature]])];
    if (atomicNumberA && atomicNumberB && __MetalBondAtomRadii[atomicNumberA] && __MetalBondAtomRadii[atomicNumberB]) {
        var maxDistance = __MetalBondAtomRadii[atomicNumberA] + __MetalBondAtomRadii[atomicNumberB] + 0.5;
        var tmpVecA = linear_algebra_1.Vec3.create(0, 0, 0);
        var tmpVecB = linear_algebra_1.Vec3.create(0, 0, 0);
        features_1.Features.position(tmpVecA, infoA);
        features_1.Features.position(tmpVecB, infoB);
        var distance = linear_algebra_1.Vec3.distance(tmpVecA, tmpVecB);
        if (distance > maxDistance) {
            return;
        }
    }
    return common_1.InteractionType.MetalCoordination;
}
//
exports.MetalProvider = features_1.Features.Provider([13 /* IonicTypeMetal */, 12 /* TransitionMetal */], addMetal);
exports.MetalBindingProvider = features_1.Features.Provider([10 /* IonicTypePartner */, 11 /* DativeBondPartner */], addMetalBinding);
exports.MetalCoordinationProvider = {
    name: 'metal-coordination',
    params: exports.MetalCoordinationParams,
    createTester: function (props) {
        return {
            maxDistance: props.distanceMax,
            requiredFeatures: new Set([
                13 /* IonicTypeMetal */,
                12 /* TransitionMetal */,
                10 /* IonicTypePartner */,
                11 /* DativeBondPartner */
            ]),
            getType: function (structure, infoA, infoB, distanceSq) {
                return testMetalCoordination(structure, infoA, infoB, distanceSq);
            }
        };
    }
};
//# sourceMappingURL=metal.js.map