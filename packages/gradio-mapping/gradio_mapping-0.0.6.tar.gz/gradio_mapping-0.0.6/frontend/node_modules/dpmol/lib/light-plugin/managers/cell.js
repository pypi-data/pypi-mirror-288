"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CellManager = void 0;
var tslib_1 = require("tslib");
var index_1 = require("../index");
var types_1 = require("../types");
var mol_util_1 = require("../../mol-util");
var loci_1 = require("../../mol-model/structure/structure/element/loci");
var utils_1 = require("../utils");
var representation_1 = require("../representation");
var vec3_1 = require("../../mol-math/linear-algebra/3d/vec3");
var misc_1 = require("../../mol-math/misc");
var loci_2 = require("../../mol-model/loci");
var ball_stick_1 = require("../representation/molecular/ball-stick");
var writer_1 = require("../utils/writer");
var parser_1 = require("../../mol-io/reader/mol/parser");
var model_1 = require("../model");
var secondary_structure_1 = require("../../mol-model-props/computed/secondary-structure");
var structure_1 = require("../../mol-model/structure");
var DefaultThemeValue = (_a = {},
    _a[types_1.ThemeC.ATOM] = [],
    _a[types_1.ThemeC.RIBBON] = [],
    _a[types_1.ThemeC.SURFACE] = [],
    _a);
var CellManager = /** @class */ (function () {
    function CellManager(plugin) {
        var _this = this;
        var _a;
        this.plugin = plugin;
        (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.reprCount.subscribe(function (count) {
            if (count > 100 && _this.idleCellSet.size) {
                var ref = Array.from(_this.idleCellSet.values())[0];
                _this.idleCellSet.delete(ref);
                _this.clearReprState(ref);
            }
        });
        this.idleCellSet = new Set();
    }
    CellManager.prototype.get = function (ref) {
        var cell = this.plugin.cells.get(ref);
        if (!cell) {
            console.error("no ".concat(ref, " cell"));
            return undefined;
            // throw new Error(`no ${ref} cell`)
        }
        return cell;
    };
    CellManager.prototype.getHierarchy = function (ref) {
        var _this = this;
        var cell = this.get(ref);
        if (!(cell === null || cell === void 0 ? void 0 : cell.model.structure)) {
            console.error("".concat(ref, " cell does not have structure"));
            return {
                data: {
                    polymer: {},
                    water: {},
                    otherSolvent: {},
                    metal: {},
                    ion: {},
                    ligand: {},
                    other: {},
                },
                extraData: {
                    sequenceData: {},
                },
            };
        }
        var surface = [];
        var label = [];
        cell.dependency.by.forEach(function (dependencyRef) {
            var _a, _b, _c;
            if (!_this.plugin.cells.has(dependencyRef)) {
                return;
            }
            var dependencyCell = _this.get(dependencyRef);
            if (!dependencyCell)
                return;
            if (dependencyCell.representations.has(index_1.RepresentationType.Label)) {
                label.push({
                    ref: dependencyRef,
                    dependencies: (0, tslib_1.__spreadArray)([], dependencyCell.dependency.on, true),
                    // Repr State Cache
                    label: ((_b = (_a = dependencyCell.representations.get(index_1.RepresentationType.Label)) === null || _a === void 0 ? void 0 : _a.state) !== null && _b !== void 0 ? _b : (_c = dependencyCell.representations.get(index_1.RepresentationType.Label)) === null || _c === void 0 ? void 0 : _c.cache).props.customText,
                });
            }
            if (dependencyCell.representations.has(index_1.RepresentationType.Surface)) {
                surface.push({
                    ref: dependencyRef,
                    dependencies: (0, tslib_1.__spreadArray)([], dependencyCell.dependency.on, true),
                });
            }
        });
        var hierarchy = (0, utils_1.getHierarchy)(cell.model.structure);
        return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, hierarchy), { extraData: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, hierarchy.extraData), { label: label, surface: surface }) });
    };
    CellManager.prototype.getSequence = function (ref) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var structure;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getStructure(ref)];
                    case 1:
                        structure = _a.sent();
                        if (!structure)
                            return [2 /*return*/];
                        return [2 /*return*/, (0, utils_1.getSequence)(structure)];
                }
            });
        });
    };
    CellManager.prototype.getStructure = function (ref) {
        var _a;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var cell, structure, _b, data, format, structure_2, _c, _d;
            return (0, tslib_1.__generator)(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        cell = this.get(ref);
                        if (!cell)
                            return [2 /*return*/];
                        structure = (0, utils_1.getStructureByCell)(cell);
                        if (structure)
                            return [2 /*return*/, structure];
                        if (!(!structure && ((_a = cell.assets) === null || _a === void 0 ? void 0 : _a.length))) return [3 /*break*/, 5];
                        _b = cell.assets[0], data = _b.data, format = _b.format;
                        _d = (_c = model_1.FormatProvider[format]).parse;
                        return [4 /*yield*/, (0, utils_1.readAsString)(data)];
                    case 1: return [4 /*yield*/, _d.apply(_c, [_e.sent()])];
                    case 2:
                        structure_2 = (_e.sent())[0];
                        if (!(format === types_1.Format.Pdb && !!structure_2.elementCount && !structure_1.Model.hasSecondaryStructure(structure_2 === null || structure_2 === void 0 ? void 0 : structure_2.model))) return [3 /*break*/, 4];
                        // 计算二级结构
                        return [4 /*yield*/, secondary_structure_1.SecondaryStructureProvider.attach({}, structure_2, {
                                type: {
                                    name: 'dssp',
                                    params: { oldDefinition: true, oldOrdering: true }
                                }
                            }, true)];
                    case 3:
                        // 计算二级结构
                        _e.sent();
                        _e.label = 4;
                    case 4:
                        this.update(ref, { model: { structure: structure_2 } });
                        return [2 /*return*/, structure_2];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    CellManager.prototype.getLoci = function (item) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var structure;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getStructure(item.ref)];
                    case 1:
                        structure = _a.sent();
                        if (!structure)
                            return [2 /*return*/, loci_2.EmptyLoci];
                        return [2 /*return*/, (0, utils_1.getLoci)(structure, item.elementIds)];
                }
            });
        });
    };
    CellManager.prototype.getMolecularName = function (ref) {
        var _a, _b, _c, _d, _e, _f;
        var cell = this.get(ref);
        if (!cell.model.structure) {
            if (((_a = cell.assets) === null || _a === void 0 ? void 0 : _a.length) && ['sdf', 'mol'].includes(cell.assets[0].format)) {
                return "".concat(cell.assets[0].data).split('\n')[0];
            }
            return '';
        }
        var model = ((_c = (_b = cell.model.structure) === null || _b === void 0 ? void 0 : _b.state.model) !== null && _c !== void 0 ? _c : (_d = cell.model.structure) === null || _d === void 0 ? void 0 : _d.state.models) ? (_e = cell.model.structure) === null || _e === void 0 ? void 0 : _e.state.models[0] : undefined;
        if (!model)
            return '';
        var sourceFileKind = (_f = model.sourceData) === null || _f === void 0 ? void 0 : _f.kind;
        if (sourceFileKind === 'sdf' || sourceFileKind === 'mol') {
            return model.entryId;
        }
        return '';
    };
    CellManager.prototype.isFromPdb = function (ref) {
        var _a;
        var cell = this.plugin.cells.get(ref);
        if (!cell)
            return false;
        var structure = (0, utils_1.getStructureByCell)(cell);
        if (!structure)
            return false;
        var isFromPdb = ((_a = (0, utils_1.getModelByStructure)(structure)) === null || _a === void 0 ? void 0 : _a.sourceData.kind) === 'mmCIF';
        return isFromPdb;
    };
    CellManager.prototype.getCellPdbId = function (ref) {
        if (!this.isFromPdb(ref))
            return '';
        var cell = this.plugin.cells.get(ref);
        if (!cell)
            return '';
        var structure = (0, utils_1.getStructureByCell)(cell);
        if (!structure)
            return '';
        var pdbId = '';
        if (this.plugin.managers.cell.isFromPdb(ref)) {
            var header = (0, writer_1.getPDBSectionLine)(structure, ['HEADER']);
            for (var i = 0, l = header.length; i < l && !pdbId; i++) {
                if (header[i].startsWith('HEADER') && header[i].length >= 66) {
                    var id = header[i].slice(62, 66).replace(' ', '');
                    if (id.length === 4 && /^[A-Za-z0-9]*$/.test(id)) {
                        pdbId = id;
                    }
                }
            }
        }
        return pdbId;
    };
    CellManager.prototype.getMeasurementName = function (ref, type) {
        var _a, _b;
        var cell = this.get(ref);
        var repr = cell.representations.get(type);
        if (!repr) {
            return console.warn("There is no ".concat(type, " in ").concat(ref, " cell"));
        }
        var loci = ((_b = (_a = cell.model) === null || _a === void 0 ? void 0 : _a.loci) !== null && _b !== void 0 ? _b : []).map(function (loci) {
            return loci_2.Loci.getCenter(loci);
        });
        if (type === index_1.RepresentationType.Distance) {
            return "".concat(vec3_1.Vec3.distance(loci[0], loci[1]).toFixed(2), "\u212B");
        }
        if (type === index_1.RepresentationType.Angle) {
            return "".concat((0, misc_1.radToDeg)(vec3_1.Vec3.angle(vec3_1.Vec3.sub((0, vec3_1.Vec3)(), loci[0], loci[1]), vec3_1.Vec3.sub((0, vec3_1.Vec3)(), loci[2], loci[1]))).toFixed(2), "\u00B0");
        }
        if (type === index_1.RepresentationType.Dihedral) {
            return "".concat((0, misc_1.radToDeg)(vec3_1.Vec3.dihedralAngle(loci[0], loci[1], loci[2], loci[3])).toFixed(2), "\u00B0");
        }
        return '';
    };
    CellManager.prototype.create = function (data) {
        var _this = this;
        var _a, _b;
        var representations = data.representations, model = data.model, assets = data.assets, dependency = data.dependency, ref = data.ref, theme = data.theme;
        var uuid = ref !== null && ref !== void 0 ? ref : mol_util_1.UUID.create22();
        var map = new Map();
        representations.forEach(function (representation) {
            var _a;
            // Repr State Cache
            if (!representation.isHidden && representation.state) {
                (_a = _this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.add(representation.state);
            }
            map.set(representation.type, representation);
        });
        this.plugin.cells.set(uuid, {
            ref: uuid,
            representations: map,
            dependency: (0, tslib_1.__assign)({ on: [], by: [] }, dependency),
            theme: {
                color: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, DefaultThemeValue), theme === null || theme === void 0 ? void 0 : theme.color),
                size: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, DefaultThemeValue), theme === null || theme === void 0 ? void 0 : theme.size),
                transparency: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, DefaultThemeValue), theme === null || theme === void 0 ? void 0 : theme.transparency)
            },
            assets: assets,
            model: model
        });
        if ((_a = dependency === null || dependency === void 0 ? void 0 : dependency.on) === null || _a === void 0 ? void 0 : _a.length) {
            Array.from(new Set(dependency === null || dependency === void 0 ? void 0 : dependency.on)).forEach(function (item) {
                _this.addDependency(item.ref, { by: [uuid] });
            });
        }
        if ((_b = dependency === null || dependency === void 0 ? void 0 : dependency.by) === null || _b === void 0 ? void 0 : _b.length) {
            Array.from(new Set(dependency === null || dependency === void 0 ? void 0 : dependency.by)).forEach(function (ref) {
                _this.addDependency(ref, { on: [{ ref: uuid }] });
            });
        }
        this.plugin.managers.snapshot.event.changed.next({ from: 'cell:create' });
        return uuid;
    };
    CellManager.prototype.createEmptyMolecularCell = function (theme) {
        var _a, _b, _c, _d;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var structure, repr, cRef;
            var _e, _f;
            return (0, tslib_1.__generator)(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        structure = (0, utils_1.createEmptyStructure)();
                        return [4 /*yield*/, ball_stick_1.BallAndStickRepr.create(structure, this.plugin.managers.representation.ctx)];
                    case 1:
                        repr = _g.sent();
                        cRef = this.create({
                            representations: [
                                {
                                    state: repr,
                                    isHidden: false,
                                    type: index_1.RepresentationType.BallAndStick,
                                },
                            ],
                            model: { structure: structure },
                            assets: [{ format: types_1.Format.Sdf, data: '' }],
                            theme: {
                                transparency: (_e = {},
                                    _e[types_1.ThemeC.ATOM] = (theme && ((_a = theme[types_1.ThemeC.ATOM]) === null || _a === void 0 ? void 0 : _a.transparency)) ? [(_b = theme[types_1.ThemeC.ATOM]) === null || _b === void 0 ? void 0 : _b.transparency] : [],
                                    _e[types_1.ThemeC.RIBBON] = [],
                                    _e[types_1.ThemeC.SURFACE] = [],
                                    _e),
                                size: (_f = {},
                                    _f[types_1.ThemeC.ATOM] = (theme && ((_c = theme[types_1.ThemeC.ATOM]) === null || _c === void 0 ? void 0 : _c.size)) ? [(_d = theme[types_1.ThemeC.ATOM]) === null || _d === void 0 ? void 0 : _d.size] : [],
                                    _f[types_1.ThemeC.RIBBON] = [],
                                    _f[types_1.ThemeC.SURFACE] = [],
                                    _f)
                            },
                        });
                        return [2 /*return*/, cRef];
                }
            });
        });
    };
    CellManager.prototype.copyMolecular = function (items, data) {
        var _a, _b, _c, _d, _e, _f;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var refs, _loop_1, this_1, _i, items_1, item;
            return (0, tslib_1.__generator)(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        refs = [];
                        _loop_1 = function (item) {
                            var cell, sourceStructure, representations, structure, id, themeC, representation, _loop_2, _h, _j, _k, type, r;
                            return (0, tslib_1.__generator)(this, function (_l) {
                                switch (_l.label) {
                                    case 0:
                                        cell = this_1.get(item.ref);
                                        return [4 /*yield*/, this_1.getStructure(item.ref)];
                                    case 1:
                                        sourceStructure = _l.sent();
                                        representations = [];
                                        structure = (0, utils_1.getStructureByElementIds)(sourceStructure, (_a = item.elementIds) !== null && _a !== void 0 ? _a : [], true, true);
                                        if (!!!structure.elementCount) return [3 /*break*/, 3];
                                        return [4 /*yield*/, secondary_structure_1.SecondaryStructureProvider.attach({}, structure, void 0, true)];
                                    case 2:
                                        _l.sent();
                                        _l.label = 3;
                                    case 3:
                                        id = (0, utils_1.getStructureUniqueId)(structure);
                                        if (!item.representationType) return [3 /*break*/, 5];
                                        themeC = Object.keys(types_1.ReprCBasedTheme).find(function (key) {
                                            return types_1.ReprCBasedTheme[key].includes(item.representationType);
                                        });
                                        return [4 /*yield*/, representation_1.MolecularRepresentation[item.representationType].create(structure, this_1.plugin.managers.representation.ctx, this_1.plugin.managers.representation.createTheme(item.representationType, structure, {
                                                color: { name: 'multi-theme', props: { themes: cell.theme.color[themeC] } },
                                                size: cell.theme.size && ((_b = cell.theme.size[themeC]) === null || _b === void 0 ? void 0 : _b.length) ? cell.theme.size[themeC][0] : this_1.plugin.managers.representation.defaultTheme.size[item.representationType]
                                            }))];
                                    case 4:
                                        representation = _l.sent();
                                        representations.push({
                                            state: representation,
                                            isHidden: (_c = data === null || data === void 0 ? void 0 : data.isHidden) !== null && _c !== void 0 ? _c : true,
                                            type: item.representationType
                                        });
                                        return [3 /*break*/, 9];
                                    case 5:
                                        _loop_2 = function (type, r) {
                                            var themeC, isOverlap, overlapStructure, representation;
                                            return (0, tslib_1.__generator)(this, function (_m) {
                                                switch (_m.label) {
                                                    case 0:
                                                        themeC = Object.keys(types_1.ReprCBasedTheme).find(function (key) {
                                                            return types_1.ReprCBasedTheme[key].includes(type);
                                                        });
                                                        isOverlap = !((_d = item.elementIds) === null || _d === void 0 ? void 0 : _d.length)
                                                            ? true
                                                            // Repr Cache Compatible
                                                            : (0, utils_1.overlapRepresentationByElementIds)(r.state, item.elementIds)
                                                                .length;
                                                        if (!isOverlap) return [3 /*break*/, 2];
                                                        overlapStructure = (0, utils_1.getStructureByElementIds)(r.state ? (0, utils_1.getStructureFromRepresentation)(r.state) : (0, utils_1.getStructureByElementIds)(structure, r.cache.elementIds, true), (_e = item.elementIds) !== null && _e !== void 0 ? _e : [], true, id);
                                                        return [4 /*yield*/, representation_1.MolecularRepresentation[type].create(overlapStructure, this_1.plugin.managers.representation.ctx, this_1.plugin.managers.representation.createTheme(type, overlapStructure, {
                                                                color: { name: 'multi-theme', props: { themes: cell.theme.color[themeC] } },
                                                                size: this_1.plugin.managers.representation.defaultTheme.size[type]
                                                            }))];
                                                    case 1:
                                                        representation = _m.sent();
                                                        representations.push({
                                                            state: representation,
                                                            isHidden: (_f = data === null || data === void 0 ? void 0 : data.isHidden) !== null && _f !== void 0 ? _f : true,
                                                            type: type
                                                        });
                                                        _m.label = 2;
                                                    case 2: return [2 /*return*/];
                                                }
                                            });
                                        };
                                        _h = 0, _j = Array.from(cell.representations);
                                        _l.label = 6;
                                    case 6:
                                        if (!(_h < _j.length)) return [3 /*break*/, 9];
                                        _k = _j[_h], type = _k[0], r = _k[1];
                                        return [5 /*yield**/, _loop_2(type, r)];
                                    case 7:
                                        _l.sent();
                                        _l.label = 8;
                                    case 8:
                                        _h++;
                                        return [3 /*break*/, 6];
                                    case 9:
                                        refs.push(this_1.create({
                                            representations: representations,
                                            model: {
                                                structure: structure
                                            },
                                            assets: cell.assets,
                                            theme: (0, tslib_1.__assign)({}, cell.theme),
                                        }));
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _i = 0, items_1 = items;
                        _g.label = 1;
                    case 1:
                        if (!(_i < items_1.length)) return [3 /*break*/, 4];
                        item = items_1[_i];
                        return [5 /*yield**/, _loop_1(item)];
                    case 2:
                        _g.sent();
                        _g.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        this.plugin.managers.snapshot.event.changed.next({
                            from: 'cell:copyMolecular'
                        });
                        return [2 /*return*/, refs];
                }
            });
        });
    };
    // 单纯处理数据，不处理representation的显影
    CellManager.prototype.update = function (ref, newCell) {
        var _this = this;
        var _a, _b, _c, _d, _e, _f, _g;
        var cell = this.plugin.managers.cell.get(ref);
        cell.model = Object.assign(cell.model, newCell.model);
        if (newCell.theme) {
            cell.theme = {
                color: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, cell.theme.color), newCell.theme.color),
                size: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, cell.theme.size), newCell.theme.size),
                transparency: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, cell.theme.transparency), newCell.theme.transparency)
            };
        }
        if ((_a = newCell.representations) === null || _a === void 0 ? void 0 : _a.length) {
            newCell.representations.forEach(function (representation) {
                var _a;
                cell.representations.set(representation.type, Object.assign(((_a = cell.representations.get(representation.type)) !== null && _a !== void 0 ? _a : {}), representation));
            });
        }
        if ((_c = (_b = newCell.dependency) === null || _b === void 0 ? void 0 : _b.on) === null || _c === void 0 ? void 0 : _c.length) {
            this.removeDependency(ref, { on: cell.dependency.on });
            Array.from(new Set((_d = newCell.dependency) === null || _d === void 0 ? void 0 : _d.on)).forEach(function (item) {
                _this.addDependency(item.ref, { by: [ref] });
            });
        }
        if ((_f = (_e = newCell.dependency) === null || _e === void 0 ? void 0 : _e.by) === null || _f === void 0 ? void 0 : _f.length) {
            this.removeDependency(ref, { by: cell.dependency.by });
            Array.from(new Set((_g = newCell.dependency) === null || _g === void 0 ? void 0 : _g.by)).forEach(function (depRef) {
                _this.addDependency(depRef, { on: [{ ref: ref }] });
            });
        }
        cell.dependency = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, cell.dependency), newCell.dependency);
        if (newCell.assets) {
            cell.assets = newCell.assets;
        }
        this.plugin.managers.snapshot.event.changed.next({ from: 'cell:update' });
    };
    CellManager.prototype.remove = function (items, dependency) {
        var _a, _b;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var interactionRef, removeMap, _loop_3, this_2, _i, items_2, item;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        interactionRef = '';
                        removeMap = new Map();
                        _loop_3 = function (item) {
                            var cell, structure, _loop_4, _d, _e, _f, key, r, _g, _h, ref, dependencyCell;
                            return (0, tslib_1.__generator)(this, function (_j) {
                                switch (_j.label) {
                                    case 0:
                                        if (!this_2.plugin.cells.has(item.ref))
                                            return [2 /*return*/, "continue"];
                                        cell = this_2.get(item.ref);
                                        return [4 /*yield*/, this_2.getStructure(item.ref)];
                                    case 1:
                                        structure = _j.sent();
                                        if (item.ref && structure) {
                                            this_2.plugin.managers.selection.structure.remove({ item: { ref: item.ref, elementIds: (_a = item.elementIds) !== null && _a !== void 0 ? _a : (0, utils_1.getElementsFromStructure)(structure) } });
                                        }
                                        if (removeMap.has(item.ref) && removeMap.get(item.ref) !== undefined) {
                                            removeMap.set(item.ref, item.elementIds === undefined ? undefined : (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], item.elementIds, true), removeMap.get(item.ref), true));
                                        }
                                        else {
                                            removeMap.set(item.ref, item.elementIds);
                                        }
                                        if (dependency) {
                                            cell.representations.forEach(function (r) {
                                                var _a, _b;
                                                if (types_1.MeasurementType.has(r.type) && cell.dependency.on.length) {
                                                    // 当前repr 是measure，且可能存在依赖被删除
                                                    var overlap = cell.dependency.on.some(function (item) {
                                                        return (0, utils_1.isCellItemIntersectCellItem)(item, dependency);
                                                    });
                                                    if (overlap) {
                                                        // Repr State Cache
                                                        if (!r.isHidden && r.state) {
                                                            (_a = _this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.remove(r.state);
                                                        }
                                                        cell.representations.delete(r.type);
                                                    }
                                                }
                                                if (r.type === index_1.RepresentationType.Surface) {
                                                    if (!dependency.elementIds) {
                                                        // Repr State Cache
                                                        if (r.state) {
                                                            (_b = _this.plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.remove(r.state);
                                                        }
                                                        cell.representations.delete(r.type);
                                                    }
                                                }
                                                // // TODO 相互作用力场景
                                                // if (r.type === RepresentationType.IntraInteractions) {
                                                //   console.log(r, items)
                                                //   if (!dependency?.elementIds?.length) {
                                                //     this.remove(items)
                                                //   }
                                                // }
                                                // if (r.type === RepresentationType.BetweenInteractions) {
                                                //   console.log(r, items)
                                                //   if (!dependency?.elementIds?.length) {
                                                //     this.remove(items)
                                                //   }
                                                // }
                                            });
                                        }
                                        else if (!((_b = item === null || item === void 0 ? void 0 : item.elementIds) === null || _b === void 0 ? void 0 : _b.length)) {
                                            // 全部删除
                                            cell.representations.forEach(function (r) {
                                                var _a;
                                                // Repr State Cache
                                                if (!r.isHidden && r.state) {
                                                    (_a = _this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.remove(r.state);
                                                }
                                                cell.representations.delete(r.type);
                                            });
                                            // this.plugin.cells.delete(item.ref)
                                        }
                                        else {
                                            _loop_4 = function (key, r) {
                                                // Repr Cache Compatible
                                                // const intersect = isRepresentationIntersectElementIds(
                                                //   r.state!,
                                                //   item.elementIds!
                                                // )
                                                // // 常规图形
                                                // if (intersect === Intersection.BeIncluded) {
                                                //   // Repr State Cache
                                                //   if (!r.isHidden && r.state) {
                                                //     this.plugin.canvas3d?.remove(r.state)
                                                //   }
                                                //   cell.representations.delete(key)
                                                // } else if (intersect === Intersection.Include || Intersection.Cross) {
                                                var themeC = Object.keys(types_1.ReprCBasedTheme).find(function (reprC) {
                                                    return types_1.ReprCBasedTheme[reprC].includes(key);
                                                });
                                                (0, utils_1.removeElementIdsInRepresentation)(
                                                // Repr Cache Compatible
                                                r.state, item.elementIds, key, function (structure) {
                                                    var _a;
                                                    return _this.plugin.managers.representation.createTheme(key, structure, {
                                                        color: { name: 'multi-theme', props: { themes: cell.theme.color[themeC] } },
                                                        size: cell.theme.size && ((_a = cell.theme.size[themeC]) === null || _a === void 0 ? void 0 : _a.length) ? cell.theme.size[themeC][0] : _this.plugin.managers.representation.defaultTheme.size[r.type]
                                                    });
                                                }, function (structure) {
                                                    var _a;
                                                    return _this.plugin.managers.representation.createTransparencyLayers(structure, (0, tslib_1.__spreadArray)([], ((_a = cell === null || cell === void 0 ? void 0 : cell.theme.transparency[themeC]) !== null && _a !== void 0 ? _a : []), true));
                                                });
                                            };
                                            // 部分删除
                                            // TODO 轨迹图的情况没有考虑
                                            for (_d = 0, _e = Array.from(cell.representations); _d < _e.length; _d++) {
                                                _f = _e[_d], key = _f[0], r = _f[1];
                                                _loop_4(key, r);
                                            }
                                            if (structure) {
                                                cell.model.structure = (0, utils_1.removeStructureByElementIds)(structure, item.elementIds);
                                            }
                                        }
                                        if (!cell.dependency.by.length) return [3 /*break*/, 6];
                                        _g = 0, _h = Array.from(new Set(cell.dependency.by));
                                        _j.label = 2;
                                    case 2:
                                        if (!(_g < _h.length)) return [3 /*break*/, 6];
                                        ref = _h[_g];
                                        dependencyCell = this_2.plugin.cells.get(ref);
                                        if (!(dependencyCell === null || dependencyCell === void 0 ? void 0 : dependencyCell.representations.has(index_1.RepresentationType.IntraInteractions))) return [3 /*break*/, 3];
                                        interactionRef = ref;
                                        return [3 /*break*/, 5];
                                    case 3: return [4 /*yield*/, this_2.remove([{ ref: ref }], item)];
                                    case 4:
                                        _j.sent();
                                        _j.label = 5;
                                    case 5:
                                        _g++;
                                        return [3 /*break*/, 2];
                                    case 6:
                                        if (!cell.representations.size) {
                                            if (cell.dependency.on.length) {
                                                Array.from(new Set(cell.dependency.on)).forEach(function (depItem) {
                                                    var depend = _this.plugin.cells.get(depItem.ref);
                                                    if (!depend)
                                                        return;
                                                    var index = depend.dependency.by.findIndex(function (r) { return r === item.ref; });
                                                    if (index !== -1) {
                                                        depend.dependency.by.splice(index, 1);
                                                    }
                                                });
                                            }
                                            this_2.plugin.cells.delete(item.ref);
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_2 = this;
                        _i = 0, items_2 = items;
                        _c.label = 1;
                    case 1:
                        if (!(_i < items_2.length)) return [3 /*break*/, 4];
                        item = items_2[_i];
                        return [5 /*yield**/, _loop_3(item)];
                    case 2:
                        _c.sent();
                        _c.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        if (interactionRef) {
                            this.plugin.managers.representation.showGlobalInteraction(true, 'lightPlugin.managers.cell.remove');
                        }
                        this.plugin.managers.snapshot.event.changed.next({ from: 'cell:remove' });
                        return [2 /*return*/];
                }
            });
        });
    };
    CellManager.prototype.extractMolecular = function (items, data) {
        var _a, _b, _c, _d, _e;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var refs, _i, items_3, item, cell, sourceStructure, structure, format, representations, _loop_5, this_3, _f, _g, _h, type, r;
            return (0, tslib_1.__generator)(this, function (_j) {
                switch (_j.label) {
                    case 0:
                        refs = [];
                        _i = 0, items_3 = items;
                        _j.label = 1;
                    case 1:
                        if (!(_i < items_3.length)) return [3 /*break*/, 8];
                        item = items_3[_i];
                        cell = this.get(item.ref);
                        return [4 /*yield*/, this.getStructure(item.ref)];
                    case 2:
                        sourceStructure = _j.sent();
                        structure = (0, utils_1.getStructureByElementIds)(sourceStructure, (_a = item.elementIds) !== null && _a !== void 0 ? _a : [], true, true);
                        format = ((_b = cell.assets) === null || _b === void 0 ? void 0 : _b.length) && ((_c = cell.assets[0]) === null || _c === void 0 ? void 0 : _c.format) ? cell.assets[0].format : types_1.Format.Pdb;
                        representations = [];
                        _loop_5 = function (type, r) {
                            var themeC, overlap, overlapStructure, representation;
                            return (0, tslib_1.__generator)(this, function (_k) {
                                switch (_k.label) {
                                    case 0:
                                        themeC = Object.keys(types_1.ReprCBasedTheme).find(function (key) {
                                            return types_1.ReprCBasedTheme[key].includes(type);
                                        });
                                        overlap = (0, utils_1.overlapRepresentationByElementIds)(
                                        // Repr Cache Compatible
                                        r.state, item.elementIds);
                                        if (!overlap.length) return [3 /*break*/, 2];
                                        overlapStructure = (0, utils_1.getStructureByElementIds)(structure, overlap);
                                        return [4 /*yield*/, representation_1.MolecularRepresentation[type].create(overlapStructure, this_3.plugin.managers.representation.ctx, this_3.plugin.managers.representation.createTheme(type, overlapStructure, {
                                                color: { name: 'multi-theme', props: { themes: cell.theme.color[themeC] } },
                                                size: cell.theme.size && ((_d = cell.theme.size[themeC]) === null || _d === void 0 ? void 0 : _d.length) ? cell.theme.size[themeC][0] : this_3.plugin.managers.representation.defaultTheme.size[r.type]
                                            }))];
                                    case 1:
                                        representation = _k.sent();
                                        representations.push({
                                            state: representation,
                                            isHidden: (_e = data === null || data === void 0 ? void 0 : data.isHidden) !== null && _e !== void 0 ? _e : true,
                                            type: type
                                        });
                                        _k.label = 2;
                                    case 2: return [2 /*return*/];
                                }
                            });
                        };
                        this_3 = this;
                        _f = 0, _g = Array.from(cell.representations);
                        _j.label = 3;
                    case 3:
                        if (!(_f < _g.length)) return [3 /*break*/, 6];
                        _h = _g[_f], type = _h[0], r = _h[1];
                        return [5 /*yield**/, _loop_5(type, r)];
                    case 4:
                        _j.sent();
                        _j.label = 5;
                    case 5:
                        _f++;
                        return [3 /*break*/, 3];
                    case 6:
                        refs.push(this.create({
                            representations: representations,
                            model: {
                                structure: structure
                            },
                            assets: [
                                { format: format, data: (0, utils_1.getTextFromStructure)(structure, format) }
                            ],
                            theme: (0, tslib_1.__assign)({}, cell.theme),
                        }));
                        this.remove([item]);
                        _j.label = 7;
                    case 7:
                        _i++;
                        return [3 /*break*/, 1];
                    case 8:
                        this.plugin.managers.snapshot.event.changed.next({
                            from: 'cell:extractMolecular'
                        });
                        return [2 /*return*/, refs];
                }
            });
        });
    };
    CellManager.prototype.addDependency = function (ref, dependency) {
        var _a, _b;
        var cell = this.get(ref);
        if ((_a = dependency.on) === null || _a === void 0 ? void 0 : _a.length) {
            cell.dependency.on = cell.dependency.on.concat(dependency.on);
        }
        if ((_b = dependency.by) === null || _b === void 0 ? void 0 : _b.length) {
            cell.dependency.by = Array.from(new Set(cell.dependency.by.concat(dependency.by)));
        }
    };
    CellManager.prototype.removeDependency = function (ref, dependency) {
        var _this = this;
        var _a, _b;
        if ((_a = dependency.on) === null || _a === void 0 ? void 0 : _a.length) {
            dependency.on.forEach(function (item) {
                if (_this.plugin.cells.has(item.ref)) {
                    _this.get(item.ref).dependency.by = _this.get(item.ref).dependency.by.filter(function (key) { return key !== ref; });
                }
            });
        }
        if ((_b = dependency.by) === null || _b === void 0 ? void 0 : _b.length) {
            dependency.by.forEach(function (depRef) {
                if (_this.plugin.cells.has(depRef)) {
                    _this.get(depRef).dependency.on = _this.get(depRef).dependency.on.filter(function (item) { return item.ref !== ref; });
                }
            });
        }
    };
    CellManager.prototype.query = function (condition) {
        var result = [];
        this.plugin.cells.forEach(function (cell) {
            cell.representations.forEach(function (repr) {
                if (condition(cell, repr)) {
                    result.push(cell);
                }
            });
        });
        return result;
    };
    CellManager.prototype.traverse = function (callback) {
        this.plugin.cells.forEach(function (cell) {
            cell.representations.forEach(function (repr) {
                callback(cell, repr);
            });
        });
    };
    CellManager.prototype.getAllDisplayedCellsRef = function () {
        var refsSet = new Set();
        this.plugin.managers.cell.traverse(function (cell, repr) {
            if ([index_1.RepresentationType.Ribbon, index_1.RepresentationType.BallAndStick, index_1.RepresentationType.Line, index_1.RepresentationType.Stick, index_1.RepresentationType.CPK].includes(repr.type) && !repr.isHidden && (0, utils_1.getStructureByCell)(cell)) {
                refsSet.add(cell.ref);
            }
        });
        return Array.from(refsSet.values());
    };
    CellManager.prototype.clearReprState = function (ref) {
        var _this = this;
        var cell = this.get(ref);
        var elementIdsMap = new Map();
        var structure = cell.model.structure;
        if (!structure)
            return;
        if (structure) {
            var current_1 = 0;
            structure.units.forEach(function (unit) {
                unit.elements.forEach(function (elementId) {
                    elementIdsMap.set(elementId, current_1++);
                });
            });
        }
        Array.from(cell.representations.entries()).forEach(function (_a) {
            var _b;
            var type = _a[0], repr = _a[1];
            if (repr.state) {
                (_b = _this.plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.remove(repr.state);
                cell.representations.set(repr.type, {
                    isHidden: repr.isHidden,
                    type: repr.type,
                    cache: {
                        type: repr.type,
                        elementIds: (0, utils_1.getElementIdsFromRepresentation)(repr.state).map(function (elementId) { return elementIdsMap && (elementIdsMap === null || elementIdsMap === void 0 ? void 0 : elementIdsMap.has(elementId)) ? elementIdsMap === null || elementIdsMap === void 0 ? void 0 : elementIdsMap.get(elementId) : elementId; }),
                        isHidden: repr.isHidden,
                        params: types_1.MeasurementType.has(repr.type) ? (0, utils_1.getMeasurementProps)(repr.type, repr.state) : undefined,
                    }
                });
            }
        });
    };
    CellManager.prototype.recoveryCache = function (ref, cache) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var cell, representations, _i, representations_1, r;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        cell = this.get(ref);
                        representations = Array.from(cell.representations.values());
                        if (!cache) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.recoveryReprCache(cell, cache)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        _i = 0, representations_1 = representations;
                        _a.label = 3;
                    case 3:
                        if (!(_i < representations_1.length)) return [3 /*break*/, 6];
                        r = representations_1[_i];
                        if (!r.cache) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.recoveryReprCache(cell, r.cache)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        _i++;
                        return [3 /*break*/, 3];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    CellManager.prototype.recoveryReprCache = function (cell, cache) {
        var _a, _b;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var structure, themeC, colorItems, transparency;
            return (0, tslib_1.__generator)(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.getStructure(cell.ref)];
                    case 1:
                        structure = _c.sent();
                        if (!structure)
                            return [2 /*return*/];
                        themeC = Object.keys(types_1.ReprCBasedTheme).find(function (key) {
                            return types_1.ReprCBasedTheme[key].includes(cache.type);
                        });
                        colorItems = cell.theme.color[themeC];
                        transparency = cell.theme.transparency ? cell.theme.transparency[themeC] : undefined;
                        return [4 /*yield*/, this.plugin.managers.representation.addMolecularRepr(cell.ref, {
                                reprType: cache.type,
                                elementIds: cache.elementIds,
                                isHidden: cache.isHidden,
                                theme: this.plugin.managers.representation.createTheme(cache.type, (0, utils_1.getStructureByElementIds)(structure, (_a = cache.elementIds) !== null && _a !== void 0 ? _a : [], true), {
                                    color: {
                                        name: 'multi-theme',
                                        props: { themes: colorItems }
                                    },
                                    size: cell.theme.size && ((_b = cell.theme.size[themeC]) === null || _b === void 0 ? void 0 : _b.length) ? cell.theme.size[themeC][0] : this.plugin.managers.representation.defaultTheme.size[cache.type]
                                }),
                                transparency: transparency,
                            })];
                    case 2:
                        _c.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    CellManager.prototype.overlapLigands = function (targetLigandCref, elementIds, ligandContext) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var molInfo, sourceCenter, structure, targetLoci, targetCenter, offsetVec, atoms, chargeMap, i, l, i, l, bonds, i, l;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        molInfo = (0, parser_1.parseMolText)(ligandContext);
                        sourceCenter = [
                            Array.from(molInfo.atoms.x.toArray()).reduce(function (prev, curr) {
                                return prev + curr;
                            }) / molInfo.atoms.count,
                            Array.from(molInfo.atoms.y.toArray()).reduce(function (prev, curr) {
                                return prev + curr;
                            }) / molInfo.atoms.count,
                            Array.from(molInfo.atoms.z.toArray()).reduce(function (prev, curr) {
                                return prev + curr;
                            }) / molInfo.atoms.count,
                        ];
                        return [4 /*yield*/, this.getStructure(targetLigandCref)];
                    case 1:
                        structure = _a.sent();
                        targetLoci = (0, utils_1.getLoci)(structure, elementIds);
                        targetCenter = loci_1.Loci.getBoundary(targetLoci).sphere.center;
                        offsetVec = [
                            targetCenter[0] - sourceCenter[0],
                            targetCenter[1] - sourceCenter[1],
                            targetCenter[2] - sourceCenter[2],
                        ];
                        atoms = [];
                        chargeMap = new Map();
                        for (i = 0, l = molInfo.formalCharges.atomIdx.rowCount; i < l; i++) {
                            chargeMap.set(molInfo.formalCharges.atomIdx.value(i) - 1, molInfo.formalCharges.charge.value(i));
                        }
                        for (i = 0, l = molInfo.atoms.count; i < l; i++) {
                            atoms.push({
                                x: molInfo.atoms.x.value(i) + offsetVec[0],
                                y: molInfo.atoms.y.value(i) + offsetVec[1],
                                z: molInfo.atoms.z.value(i) + offsetVec[2],
                                type_symbol: molInfo.atoms.type_symbol.value(i),
                                charge: chargeMap.get(i) || 0,
                            });
                        }
                        bonds = [];
                        for (i = 0, l = molInfo.bonds.count; i < l; i++) {
                            bonds.push({
                                a: molInfo.bonds.atomIdxA.value(i),
                                b: molInfo.bonds.atomIdxB.value(i),
                                order: molInfo.bonds.order.value(i),
                            });
                        }
                        return [2 /*return*/, {
                                atoms: atoms,
                                bonds: bonds
                            }];
                }
            });
        });
    };
    return CellManager;
}());
exports.CellManager = CellManager;
//# sourceMappingURL=cell.js.map