"use strict";
/**
 * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author Fred Ludlow <Fred.Ludlow@astx.com>
 *
 * based in part on NGL (https://github.com/arose/ngl)
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CationPiProvider = exports.PiStackingProvider = exports.IonicProvider = exports.AromaticRingProvider = exports.PositiveChargeProvider = exports.NegativChargeProvider = exports.DefaultCationPiParams = exports.DefaultPiStackingParams = exports.DefaultIonicParams = void 0;
var param_definition_1 = require("../../../mol-util/param-definition");
var features_1 = require("./features");
var valence_model_1 = require("../valence-model");
var misc_1 = require("../../../mol-math/misc");
var common_1 = require("./common");
var int_1 = require("../../../mol-data/int");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var util_1 = require("../chemistry/util");
var IonicParams = {
    distanceMax: param_definition_1.ParamDefinition.Numeric(5.0, { min: 0, max: 8, step: 0.1 }),
};
exports.DefaultIonicParams = param_definition_1.ParamDefinition.getDefaultValues(IonicParams);
var PiStackingParams = {
    // 薛定谔中face to face是4.4，edge to face是5.5，目前未精确区分，取最大值
    distanceMax: param_definition_1.ParamDefinition.Numeric(5.5, { min: 1, max: 8, step: 0.1 }),
    offsetMax: param_definition_1.ParamDefinition.Numeric(2.0, { min: 0, max: 4, step: 0.1 }),
    angleDevMax: param_definition_1.ParamDefinition.Numeric(30, { min: 0, max: 180, step: 1 }),
};
exports.DefaultPiStackingParams = param_definition_1.ParamDefinition.getDefaultValues(PiStackingParams);
var CationPiParams = {
    distanceMax: param_definition_1.ParamDefinition.Numeric(6.6, { min: 1, max: 8, step: 0.1 }),
    offsetMax: param_definition_1.ParamDefinition.Numeric(2.0, { min: 0, max: 4, step: 0.1 }),
};
exports.DefaultCationPiParams = param_definition_1.ParamDefinition.getDefaultValues(CationPiParams);
//
function getUnitValenceModel(structure, unit) {
    var valenceModel = valence_model_1.ValenceModelProvider.get(structure).value;
    if (!valenceModel)
        throw Error('expected valence model to be available');
    var unitValenceModel = valenceModel.get(unit.id);
    if (!unitValenceModel)
        throw Error('expected valence model for unit to be available');
    return unitValenceModel;
}
function addUnitPositiveCharges(structure, unit, builder) {
    var charge = getUnitValenceModel(structure, unit).charge;
    var elements = unit.elements;
    var _a = unit.model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;
    var residueIt = int_1.Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, elements);
    while (residueIt.hasNext) {
        var _b = residueIt.move(), start = _b.start, end = _b.end;
        var _loop_1 = function (j) {
            if (charge[j] > 0) {
                builder.add(1 /* PositiveCharge */, 0 /* None */, x[elements[j]], y[elements[j]], z[elements[j]], j);
            }
            else if ((0, util_1.typeSymbol)(unit, j) === "N" /* N */) {
                var carbonIndexes_1 = new Set();
                var nitrogenIndexMap_1 = new Map();
                (0, util_1.eachIntraBondedAtom)(unit, j, function (_, k) {
                    if ((0, util_1.typeSymbol)(unit, k) === "C" /* C */) {
                        carbonIndexes_1.add(k);
                    }
                });
                if (carbonIndexes_1.size) {
                    // 确定C只连着三个N
                    carbonIndexes_1.forEach(function (carbonIndex) {
                        var nitrogenIndexes = new Set();
                        (0, util_1.eachIntraBondedAtom)(unit, carbonIndex, function (_, k) {
                            if ((0, util_1.typeSymbol)(unit, k) === "N" /* N */) {
                                nitrogenIndexes.add(k);
                            }
                            else {
                                carbonIndexes_1.delete(carbonIndex);
                            }
                        });
                        if (nitrogenIndexes.size !== 3) {
                            carbonIndexes_1.delete(carbonIndex);
                        }
                        else {
                            nitrogenIndexMap_1.set(carbonIndex, nitrogenIndexes);
                        }
                    });
                }
                else {
                    return "continue";
                }
                var isAdd_1 = false;
                if (carbonIndexes_1.size) {
                    // 确认连着的三个N中，唯一的双键连接的N为尾端，其余两个单键连接的N至少有一个为尾端
                    carbonIndexes_1.forEach(function (carbonIndex) {
                        var bonds = unit.bonds;
                        var nitrogenIndexes = nitrogenIndexMap_1.get(carbonIndex);
                        var doubleBondNitrogenNum = 0;
                        if (!nitrogenIndexes)
                            return;
                        var _loop_2 = function (i, l) {
                            var elementIndexA = bonds.a[i];
                            var elementIndexB = bonds.b[i];
                            if ((elementIndexA === carbonIndex && nitrogenIndexes.has(elementIndexB)) && bonds.edgeProps.order[i] === 2) {
                                if (elementIndexB === j) {
                                    isAdd_1 = true;
                                }
                                var isTail_1 = true;
                                (0, util_1.eachIntraBondedAtom)(unit, elementIndexB, function (_, x) {
                                    if (x !== carbonIndex && (0, util_1.typeSymbol)(unit, x) !== "H" /* H */) {
                                        isTail_1 = false;
                                    }
                                });
                                if (isTail_1) {
                                    nitrogenIndexes.delete(elementIndexB);
                                }
                                doubleBondNitrogenNum++;
                            }
                        };
                        for (var i = 0, l = bonds.a.length; i < l; i++) {
                            _loop_2(i, l);
                        }
                        if (doubleBondNitrogenNum !== 1) {
                            carbonIndexes_1.delete(carbonIndex);
                        }
                        else {
                            nitrogenIndexes.forEach(function (nitrogenIndex) {
                                var isTail = true;
                                (0, util_1.eachIntraBondedAtom)(unit, nitrogenIndex, function (_, x) {
                                    if (x !== carbonIndex && (0, util_1.typeSymbol)(unit, x) !== "H" /* H */) {
                                        isTail = false;
                                    }
                                });
                                if (isTail) {
                                    nitrogenIndexes.delete(nitrogenIndex);
                                }
                            });
                        }
                        if (nitrogenIndexes.size > 1) {
                            carbonIndexes_1.delete(carbonIndex);
                        }
                    });
                }
                else {
                    return "continue";
                }
                if (carbonIndexes_1.size && isAdd_1) {
                    builder.add(1 /* PositiveCharge */, 0 /* None */, x[elements[j]], y[elements[j]], z[elements[j]], j);
                }
            }
        };
        for (var j = start; j < end; ++j) {
            _loop_1(j);
        }
    }
}
function addUnitNegativeCharges(structure, unit, builder) {
    var charge = getUnitValenceModel(structure, unit).charge;
    var elements = unit.elements;
    var _a = unit.model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;
    var residueIt = int_1.Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, elements);
    while (residueIt.hasNext) {
        var _b = residueIt.move(), start = _b.start, end = _b.end;
        var _loop_3 = function (j) {
            if (charge[j] < 0) {
                builder.add(2 /* NegativeCharge */, 0 /* None */, x[elements[j]], y[elements[j]], z[elements[j]], j);
            }
            else if ((0, util_1.typeSymbol)(unit, j) === "O" /* O */) {
                var carbonIndex_1 = -1;
                var carbonNum_1 = 0;
                (0, util_1.eachIntraBondedAtom)(unit, j, function (_, k) {
                    if ((0, util_1.typeSymbol)(unit, k) === "C" /* C */) {
                        carbonIndex_1 = k;
                        carbonNum_1++;
                    }
                });
                if (carbonNum_1 === 1 && carbonIndex_1 !== -1) {
                    var oxygenIndex_1 = new Set();
                    var doubleBondOxygenNum = 0;
                    (0, util_1.eachIntraBondedAtom)(unit, carbonIndex_1, function (_, k) {
                        if ((0, util_1.typeSymbol)(unit, k) === "O" /* O */) {
                            oxygenIndex_1.add(k);
                        }
                    });
                    if (oxygenIndex_1.size === 2) {
                        var bonds = unit.bonds;
                        var isAdd = true;
                        for (var i = 0, l = bonds.a.length; i < l; i++) {
                            var elementIndexA = bonds.a[i];
                            var elementIndexB = bonds.b[i];
                            if (oxygenIndex_1.has(elementIndexB) && elementIndexA !== carbonIndex_1 && (0, util_1.typeSymbol)(unit, elementIndexA) !== "H" /* H */) {
                                doubleBondOxygenNum = -100;
                            }
                            if (bonds.edgeProps.order[i] === 2 && elementIndexB === j) {
                                isAdd = false;
                            }
                            if ((elementIndexA === carbonIndex_1 && oxygenIndex_1.has(elementIndexB)) && bonds.edgeProps.order[i] === 2) {
                                doubleBondOxygenNum++;
                            }
                        }
                        if (doubleBondOxygenNum === 1 && isAdd) {
                            builder.add(2 /* NegativeCharge */, 0 /* None */, x[elements[j]], y[elements[j]], z[elements[j]], j);
                        }
                    }
                }
            }
        };
        for (var j = start; j < end; ++j) {
            _loop_3(j);
        }
    }
}
function addUnitAromaticRings(structure, unit, builder) {
    var elements = unit.elements;
    var _a = unit.model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;
    for (var _i = 0, _b = unit.rings.aromaticRings; _i < _b.length; _i++) {
        var ringIndex = _b[_i];
        var ring = unit.rings.all[ringIndex];
        builder.startState();
        for (var i = 0, il = ring.length; i < il; ++i) {
            var j = ring[i];
            builder.pushMember(x[elements[j]], y[elements[j]], z[elements[j]], j);
        }
        builder.finishState(3 /* AromaticRing */, 0 /* None */);
    }
}
function isIonic(ti, tj) {
    return ((ti === 2 /* NegativeCharge */ && tj === 1 /* PositiveCharge */) ||
        (ti === 1 /* PositiveCharge */ && tj === 2 /* NegativeCharge */));
}
function isPiStacking(ti, tj) {
    return ti === 3 /* AromaticRing */ && tj === 3 /* AromaticRing */;
}
function isCationPi(ti, tj) {
    return ((ti === 3 /* AromaticRing */ && tj === 1 /* PositiveCharge */) ||
        (ti === 1 /* PositiveCharge */ && tj === 3 /* AromaticRing */));
}
var tmpPointA = (0, linear_algebra_1.Vec3)();
var tmpPointB = (0, linear_algebra_1.Vec3)();
function areFeaturesWithinDistanceSq(infoA, infoB, distanceSq) {
    var featureA = infoA.feature, offsetsA = infoA.offsets, membersA = infoA.members;
    var featureB = infoB.feature, offsetsB = infoB.offsets, membersB = infoB.members;
    for (var i = offsetsA[featureA], il = offsetsA[featureA + 1]; i < il; ++i) {
        var elementA = membersA[i];
        infoA.unit.conformation.position(infoA.unit.elements[elementA], tmpPointA);
        for (var j = offsetsB[featureB], jl = offsetsB[featureB + 1]; j < jl; ++j) {
            var elementB = membersB[j];
            infoB.unit.conformation.position(infoB.unit.elements[elementB], tmpPointB);
            if (linear_algebra_1.Vec3.squaredDistance(tmpPointA, tmpPointB) < distanceSq)
                return true;
        }
    }
    return false;
}
var tmpVecA = (0, linear_algebra_1.Vec3)();
var tmpVecB = (0, linear_algebra_1.Vec3)();
var tmpVecC = (0, linear_algebra_1.Vec3)();
var tmpVecD = (0, linear_algebra_1.Vec3)();
function getNormal(out, info) {
    var unit = info.unit, feature = info.feature, offsets = info.offsets, members = info.members;
    var elements = unit.elements;
    var i = offsets[feature];
    info.unit.conformation.position(elements[members[i]], tmpVecA);
    info.unit.conformation.position(elements[members[i + 1]], tmpVecB);
    info.unit.conformation.position(elements[members[i + 2]], tmpVecC);
    return linear_algebra_1.Vec3.triangleNormal(out, tmpVecA, tmpVecB, tmpVecC);
}
var getOffset = function (infoA, infoB, normal) {
    features_1.Features.position(tmpVecA, infoA);
    features_1.Features.position(tmpVecB, infoB);
    linear_algebra_1.Vec3.sub(tmpVecC, tmpVecA, tmpVecB);
    linear_algebra_1.Vec3.projectOnPlane(tmpVecD, tmpVecC, normal);
    linear_algebra_1.Vec3.add(tmpVecD, tmpVecD, tmpVecB);
    return linear_algebra_1.Vec3.distance(tmpVecD, tmpVecB);
};
function getIonicOptions(props) {
    return {
        distanceMaxSq: props.distanceMax * props.distanceMax,
    };
}
function getPiStackingOptions(props) {
    return {
        offsetMax: props.offsetMax,
        angleDevMax: (0, misc_1.degToRad)(props.angleDevMax),
    };
}
function getCationPiOptions(props) {
    return {
        offsetMax: props.offsetMax
    };
}
var deg180InRad = (0, misc_1.degToRad)(180);
var deg90InRad = (0, misc_1.degToRad)(90);
var tmpNormalA = (0, linear_algebra_1.Vec3)();
var tmpNormalB = (0, linear_algebra_1.Vec3)();
function testIonic(structure, infoA, infoB, distanceSq, opts) {
    var typeA = infoA.types[infoA.feature];
    var typeB = infoB.types[infoB.feature];
    if (isIonic(typeA, typeB)) {
        if (areFeaturesWithinDistanceSq(infoA, infoB, opts.distanceMaxSq)) {
            return common_1.InteractionType.Ionic;
        }
    }
}
function testPiStacking(structure, infoA, infoB, distanceSq, opts) {
    var typeA = infoA.types[infoA.feature];
    var typeB = infoB.types[infoB.feature];
    if (isPiStacking(typeA, typeB)) {
        getNormal(tmpNormalA, infoA);
        getNormal(tmpNormalB, infoB);
        var angle = linear_algebra_1.Vec3.angle(tmpNormalA, tmpNormalB);
        // 切换成角度计算
        // const offset = Math.min(getOffset(infoA, infoB, tmpNormalB), getOffset(infoB, infoA, tmpNormalA))
        features_1.Features.position(tmpVecA, infoA);
        features_1.Features.position(tmpVecB, infoB);
        // 两个芳香环中心相连
        linear_algebra_1.Vec3.sub(tmpVecC, tmpVecA, tmpVecB);
        var angleA = linear_algebra_1.Vec3.angle(tmpNormalA, tmpVecC);
        var angleB = linear_algebra_1.Vec3.angle(tmpNormalB, tmpVecC);
        var normalToCentroidAngleA = (0, misc_1.radToDeg)(angleA > deg90InRad ? deg180InRad - angleA : angleA);
        var normalToCentroidAngleB = (0, misc_1.radToDeg)(angleB > deg90InRad ? deg180InRad - angleB : angleB);
        var type = (angle <= opts.angleDevMax || angle >= deg180InRad - opts.angleDevMax) ? 'parallel' : (angle <= opts.angleDevMax + deg90InRad && angle >= deg90InRad - opts.angleDevMax) ? 't-shaped' : undefined;
        var normalToCentroidAngle = type === 'parallel' ? [0, 33] : [0, 30];
        if (type && ((normalToCentroidAngleA >= normalToCentroidAngle[0] && normalToCentroidAngleA <= normalToCentroidAngle[1]) || (normalToCentroidAngleB >= normalToCentroidAngle[0] && normalToCentroidAngleB <= normalToCentroidAngle[1]))) {
            return type === 'parallel' ? common_1.InteractionType.PiStacking : common_1.InteractionType.PiStacking;
        }
        // if (offset <= opts.offsetMax) {
        //     if (angle <= opts.angleDevMax || angle >= deg180InRad - opts.angleDevMax) {
        //         return InteractionType.PiStacking // parallel
        //     } else if (angle <= opts.angleDevMax + deg90InRad && angle >= deg90InRad - opts.angleDevMax) {
        //         return InteractionType.PiStacking // t-shaped
        //     }
        // }
    }
}
function testCationPi(structure, infoA, infoB, distanceSq, opts) {
    var typeA = infoA.types[infoA.feature];
    var typeB = infoB.types[infoB.feature];
    if (isCationPi(typeA, typeB)) {
        var _a = typeA === 3 /* AromaticRing */ ? [infoA, infoB] : [infoB, infoA], infoR = _a[0], infoC = _a[1];
        getNormal(tmpNormalA, infoR);
        var offset = getOffset(infoC, infoR, tmpNormalA);
        if (offset <= opts.offsetMax) {
            return common_1.InteractionType.CationPi;
        }
    }
}
//
exports.NegativChargeProvider = features_1.Features.Provider([2 /* NegativeCharge */], addUnitNegativeCharges);
exports.PositiveChargeProvider = features_1.Features.Provider([1 /* PositiveCharge */], addUnitPositiveCharges);
exports.AromaticRingProvider = features_1.Features.Provider([3 /* AromaticRing */], addUnitAromaticRings);
exports.IonicProvider = {
    name: 'ionic',
    params: IonicParams,
    createTester: function (props) {
        var opts = getIonicOptions(props);
        return {
            maxDistance: props.distanceMax,
            requiredFeatures: new Set([2 /* NegativeCharge */, 1 /* PositiveCharge */]),
            getType: function (structure, infoA, infoB, distanceSq) { return testIonic(structure, infoA, infoB, distanceSq, opts); }
        };
    }
};
exports.PiStackingProvider = {
    name: 'pi-stacking',
    params: PiStackingParams,
    createTester: function (props) {
        var opts = getPiStackingOptions(props);
        return {
            maxDistance: props.distanceMax,
            requiredFeatures: new Set([3 /* AromaticRing */]),
            getType: function (structure, infoA, infoB, distanceSq) { return testPiStacking(structure, infoA, infoB, distanceSq, opts); }
        };
    }
};
exports.CationPiProvider = {
    name: 'cation-pi',
    params: CationPiParams,
    createTester: function (props) {
        var opts = getCationPiOptions(props);
        return {
            maxDistance: props.distanceMax,
            requiredFeatures: new Set([3 /* AromaticRing */, 1 /* PositiveCharge */]),
            getType: function (structure, infoA, infoB, distanceSq) { return testCationPi(structure, infoA, infoB, distanceSq, opts); }
        };
    }
};
//# sourceMappingURL=charged.js.map