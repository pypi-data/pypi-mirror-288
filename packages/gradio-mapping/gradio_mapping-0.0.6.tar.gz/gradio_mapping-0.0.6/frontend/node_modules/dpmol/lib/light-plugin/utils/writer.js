"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkFileFormat = exports.molValidate = exports.pdbValidate = exports.splitSdfContent = exports.splitPdbContent = exports.splitMolecularContent = exports.getMergedStructureContent = exports.getDefaultAtomData = exports.atomDataToSdf = exports.parseToSdf = exports.atomDataToPdb = exports.parseToPDB = exports.getPDBSectionLine = exports.MIME = void 0;
var tslib_1 = require("tslib");
var sprintf_js_1 = require("sprintf-js");
var partial_charge_1 = require("../../mol-model-formats/structure/property/partial-charge");
var string_1 = require("./string");
var structure_1 = require("./structure");
var types_1 = require("../types");
var format_1 = require("./format");
var constant_1 = require("./constant");
var MIME;
(function (MIME) {
    MIME["PDB"] = "chemical/pdb";
    MIME["SDF"] = "chemical/x-mdl-sdf";
    MIME["MOL"] = "chemical/x-mdl-molfile";
    MIME["MOL2"] = "chemical/x-mol2";
})(MIME = exports.MIME || (exports.MIME = {}));
var TITLE_SECTION = [
    'HEADER',
    'SOURCE',
    'AUTHOR',
    'OBSLTE',
    'KEYWDS',
    'REVDAT',
    'TITLE',
    'EXPDTA',
    'SPRSDE',
    'SPLT',
    'NUMMDL',
    'JRNL',
    'CAVEAT',
    'MDLTYP',
    'REMARKS',
    'COMPND'
];
var PRIMARY_STRUCTURE_SECTION = [
    'DBREF',
    'DBREF1',
    'DBREF2',
    'SEQADV',
    'SEQRES',
    'MODRES'
];
var HETEROGEN_SECTION = ['HET   ', 'HETNAM', 'HETSYN', 'FORMUL'];
var getPDBSectionLine = function (structure, section) {
    var model = (0, structure_1.getModelByStructure)(structure);
    if ((model === null || model === void 0 ? void 0 : model.sourceData.kind) === 'mmCIF') {
        var lines = model.sourceData.data.source.data.lines.data.split('\n');
        return lines.filter(function (line) {
            for (var i = 0, l = section.length; i < l; i++) {
                if (line.startsWith(section[i])) {
                    return true;
                }
            }
            return false;
        });
    }
    return [];
};
exports.getPDBSectionLine = getPDBSectionLine;
// TODO 整理pdb格式以外的结构数据（CDR区标记等），在文件内部流转时尽可能保留 by xh
function parseToPDB(structure, elementIds, isInternalTransfer, editPDBFunc) {
    var _a;
    var res = [];
    if (((_a = structure.models[0]) === null || _a === void 0 ? void 0 : _a.sourceData.kind) === 'mmCIF') {
        var section = (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], TITLE_SECTION, true), PRIMARY_STRUCTURE_SECTION, true), HETEROGEN_SECTION, true);
        res.push.apply(res, (0, exports.getPDBSectionLine)(structure, section));
    }
    var elements = [];
    if (elementIds) {
        elements.push.apply(elements, (0, tslib_1.__spreadArray)([], elementIds, true).sort(function (a, b) { return a - b; }));
    }
    else {
        structure.units.forEach(function (unit) { return elements.push.apply(elements, (0, tslib_1.__spreadArray)([], unit.elements, true)); });
    }
    var unit = structure.units[0];
    var atomList = [];
    var hasEmConfidence = false;
    var hasElectrostatic = false;
    elements.forEach(function (element) {
        var atom = {
            elementId: element,
            group_PDB: unit.model.atomicHierarchy.residues.group_PDB.value(unit.residueIndex[element]),
            atom_id: unit.model.atomicConformation.atomId.value(element),
            auth_atom_id: unit.model.atomicHierarchy.atoms.auth_atom_id.value(element),
            label_alt_id: unit.model.atomicHierarchy.atoms.label_alt_id.value(element),
            auth_comp_id: unit.model.atomicHierarchy.atoms.label_comp_id.value(element),
            auth_asym_id: unit.model.atomicHierarchy.chains.auth_asym_id.value(unit.chainIndex[element]),
            auth_seq_id: unit.model.atomicHierarchy.residues.auth_seq_id.value(unit.residueIndex[element]),
            pdbx_PDB_ins_code: unit.model.atomicHierarchy.residues.pdbx_PDB_ins_code.value(unit.residueIndex[element]),
            x: unit.model.atomicConformation.x[element],
            y: unit.model.atomicConformation.y[element],
            z: unit.model.atomicConformation.z[element],
            occupancy: unit.model.atomicConformation.occupancy.value(element),
            B_iso_or_equiv: unit.model.atomicConformation.B_iso_or_equiv.value(element),
            type_symbol: (0, string_1.getStandardTypeSymbol)(unit.model.atomicHierarchy.atoms.type_symbol.value(element)),
            charge: unit.model.atomicHierarchy.atoms.pdbx_formal_charge.value(element),
            em_confidence: unit.model.atomicHierarchy.atoms.em_confidence.value(element),
        };
        atomList.push(atom);
        if (atom.em_confidence) {
            hasEmConfidence = true;
        }
        if (atom.charge) {
            hasElectrostatic = true;
        }
    });
    // 目前pdb中CONECT字段仍不支持键级信息
    // const bondsMap = new Map()
    // cell.obj?.data.units.forEach((bondUnit: any) => {
    //     for (let i = 0, l = bondUnit.bonds.a.length i < l i++) {
    //         const a = bondUnit.elements[bondUnit.bonds.a[i]]
    //         const b = bondUnit.elements[bondUnit.bonds.b[i]]
    //         if (
    //             elements.includes(a) &&
    //             elements.includes(b) &&
    //             !bondsMap.has(`${a}_${b}`) &&
    //             !bondsMap.has(`${b}_${a}`)
    //         ) {
    //             const order = bondUnit.bonds.edgeProps.order[i]
    //             bondsMap.set(`${a}_${b}`, {
    //                 a,
    //                 b,
    //                 order,
    //                 atom_idA: unit.model.atomicConformation.atomId.value(a),
    //                 atom_idB: unit.model.atomicConformation.atomId.value(b),
    //             })
    //         }
    //     }
    // })
    // const bondList: BondData[] = Array.from(bondsMap).map(item => item[1])
    if (editPDBFunc) {
        var _b = editPDBFunc(atomList, []), editedAtomList = _b.editedAtomList, editedBondList = _b.editedBondList;
        res.push(atomDataToPdb(editedAtomList, editedBondList, isInternalTransfer && hasElectrostatic, isInternalTransfer && hasEmConfidence));
        // if (affectedAtomIds?.length) {
        //     const content = await addHs(res.join('\n'), 'pdb', affectedAtomIds)
        //     return content
        // }
        return res.join('\n');
    }
    res.push(atomDataToPdb(atomList, [], isInternalTransfer && hasElectrostatic, isInternalTransfer && hasEmConfidence));
    return res.join('\n');
}
exports.parseToPDB = parseToPDB;
function atomDataToPdb(atomList, bondList, hasElectrostatic, hasEmConfidence) {
    var AtomFormat = "ATOM  %5d %-4s%1s%3s %1s%4d%1s   %8.3f%8.3f%8.3f%6.2f%6.2f      %4s%2s".concat(hasElectrostatic ? '%4.1f' : '%2s  ').concat(hasEmConfidence ? '   %5.2f' : '');
    var HetatmFormat = "HETATM%5d %-4s%1s%3s %1s%4d%1s   %8.3f%8.3f%8.3f%6.2f%6.2f      %4s%2s".concat(hasElectrostatic ? '%4.1f' : '%2s  ').concat(hasEmConfidence ? '   %5.2f' : '');
    var ConectFormat = "CONECT%5s%5s%5s%5s%5s";
    var records = [];
    var bondRecords = [];
    atomList.forEach(function (item) {
        var elementId = item.elementId, atom_id = item.atom_id, auth_atom_id = item.auth_atom_id, label_alt_id = item.label_alt_id, auth_comp_id = item.auth_comp_id, auth_asym_id = item.auth_asym_id, auth_seq_id = item.auth_seq_id, _a = item.pdbx_PDB_ins_code, pdbx_PDB_ins_code = _a === void 0 ? ' ' : _a, x = item.x, y = item.y, z = item.z, occupancy = item.occupancy, B_iso_or_equiv = item.B_iso_or_equiv, type_symbol = item.type_symbol, group_PDB = item.group_PDB, charge = item.charge, em_confidence = item.em_confidence;
        var formatString = group_PDB === 'HETATM' ? HetatmFormat : AtomFormat;
        records.push((0, sprintf_js_1.sprintf)(formatString, atom_id, auth_atom_id, label_alt_id, auth_comp_id, auth_asym_id, auth_seq_id, pdbx_PDB_ins_code, x, y, z, occupancy, B_iso_or_equiv, ' ', type_symbol, hasElectrostatic ? charge : '  ', hasEmConfidence ? em_confidence : ''));
        var connectAtoms = [];
        // TODO pdb CONNECT字段该选择哪些成键进行回写？by xh
        if (bondList) {
            bondList.forEach(function (bond) {
                if (bond.a === elementId && !connectAtoms.includes(bond.atom_idB)) {
                    for (var i = 0, l = bond.order; i < l; i++) {
                        connectAtoms.push(bond.atom_idB);
                    }
                    return;
                }
                if (bond.b === elementId && !connectAtoms.includes(bond.atom_idA)) {
                    for (var i = 0, l = bond.order; i < l; i++) {
                        connectAtoms.push(bond.atom_idA);
                    }
                }
            });
            if (connectAtoms.length > 0) {
                var atoms = [];
                while (connectAtoms.length > 0) {
                    var atomId = connectAtoms.shift();
                    if (atomId) {
                        atoms.push(atomId);
                    }
                    if (atoms.length === 4) {
                        bondRecords.push((0, sprintf_js_1.sprintf)(ConectFormat, atom_id, atoms[0], atoms[1], atoms[2], atoms[3]));
                        atoms = [];
                    }
                }
                if (atoms.length > 0) {
                    bondRecords.push((0, sprintf_js_1.sprintf)(ConectFormat, atom_id, atoms[0] || '', atoms[1] || '', atoms[2] || '', atoms[3] || ''));
                    atoms = [];
                }
            }
        }
    });
    return (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], records, true), bondRecords, true).join('\n');
}
exports.atomDataToPdb = atomDataToPdb;
function parseToSdf(structure, elementIds, isFromRCSB, editMolFunc, allowAromaticBondType) {
    var _a, _b, _c, _d, _e, _f;
    if (allowAromaticBondType === void 0) { allowAromaticBondType = false; }
    var elements = [];
    if (elementIds) {
        elements.push.apply(elements, (0, tslib_1.__spreadArray)([], elementIds, true).filter(function (elementId) { return elementId < structure.elementCount; }).sort(function (a, b) { return a - b; }));
    }
    else {
        structure.units.forEach(function (unit) { return elements.push.apply(elements, (0, tslib_1.__spreadArray)([], unit.elements, true)); });
    }
    if (elements.length > 999) {
        return '';
    }
    if (elements.length <= 0) {
        if (editMolFunc) {
            var _g = editMolFunc([], []), editedAtomList = _g.editedAtomList, editedBondList = _g.editedBondList;
            var model = (_a = structure === null || structure === void 0 ? void 0 : structure.state.model) !== null && _a !== void 0 ? _a : structure === null || structure === void 0 ? void 0 : structure.state.models[0];
            var sourceFileKind = (_b = model === null || model === void 0 ? void 0 : model.sourceData) === null || _b === void 0 ? void 0 : _b.kind;
            var res_1 = (0, exports.atomDataToSdf)(editedAtomList, editedBondList);
            if (sourceFileKind === 'sdf' || sourceFileKind === 'mol') {
                return (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([model.entryId], res_1.split('\n').slice(1), true), ['$$$$'], false).join('\n');
            }
            return "".concat(res_1, "\n$$$$");
        }
        return '';
    }
    // if (isFromRCSB) {
    //     let pdbId
    //     if (cell.obj?.data.model?.sourceData.kind === 'mmCIF') {
    //         const lines = (cell?.obj?.data.models?.length
    //             ? cell?.obj?.data.models[0]
    //             : cell?.obj?.data.model
    //         )?.sourceData.data.source.data.lines.data.split('\n')
    //         for (let i = 0, l = lines.length i < l && !pdbId i++) {
    //             if (lines[i].startsWith('HEADER') && lines[i].length >= 66) {
    //                 const id = lines[i].slice(62, 66).replace(' ', '')
    //                 if (id.length === 4 && /^[A-Za-z0-9]*$/.test(id)) {
    //                     pdbId = id
    //                 }
    //             }
    //         }
    //     }
    //     if (pdbId) {
    //         const residueId = (cell?.obj?.data.models?.length
    //             ? cell?.obj?.data.models[0]
    //             : cell?.obj?.data.model
    //         ).atomicHierarchy.residues.auth_seq_id.value(cell.obj?.data.units[0].residueIndex[select ? select[0] : 0])
    //         const chainId = (cell?.obj?.data.models?.length
    //             ? cell?.obj?.data.models[0]
    //             : cell?.obj?.data.model
    //         ).atomicHierarchy.chains.auth_asym_id.value(cell.obj?.data.units[0].chainIndex[select ? select[0] : 0])
    //         // 调接口从RCSB获取ligand
    //         const rcsbFile = await getRCSBLigandFile(pdbId, chainId, residueId, TARGET_FORMAT.SDF)
    //         if ((rcsbFile as any).status === 200 && rcsbFile.data.length > 0) {
    //             return rcsbFile.data
    //         }
    //     }
    // }
    // let isAromatic = false
    // if (cell.obj?.data.model?.sourceData.kind === 'mmCIF') {
    //     for (let i = 0, il = cell.obj?.data.units.length i < il i++) {
    //         const unit = cell.obj?.data.units[i]
    //         for (let j = 0, jl = unit.rings.aromaticRings.length j < jl j++) {
    //             const ring = unit.rings.all[unit.rings.aromaticRings[j]]
    //             const ringElements = ring.map((item: number) => unit.elements[item])
    //             if (ringElements.filter((item: number) => elements.includes(item)).length === ringElements.length) {
    //                 isAromatic = true
    //                 break
    //             }
    //         }
    //         if (isAromatic) {
    //             break
    //         }
    //     }
    // }
    // if (isAromatic) {
    //     const pdbContent = await parseToPDB(plugin, ref, select)
    //     const file = new File([pdbContent], `aromatic.pdb`)
    //     const res = await convert(file, TARGET_FORMAT.SDF)
    //     if (typeof res.data === 'string') {
    //         return res.data
    //     }
    // }
    var unit = structure.units[0];
    var atomList = [];
    var bondsMap = new Map();
    elements.forEach(function (element) {
        var _a;
        atomList.push({
            elementId: element,
            group_PDB: unit.model.atomicHierarchy.residues.group_PDB.value(unit.residueIndex[element]),
            atom_id: unit.model.atomicConformation.atomId.value(element),
            auth_atom_id: unit.model.atomicHierarchy.atoms.label_atom_id.value(element),
            label_alt_id: unit.model.atomicHierarchy.atoms.label_alt_id.value(element),
            auth_comp_id: unit.model.atomicHierarchy.atoms.label_comp_id.value(element),
            auth_asym_id: unit.model.atomicHierarchy.chains.auth_asym_id.value(unit.chainIndex[element]),
            auth_seq_id: unit.model.atomicHierarchy.residues.auth_seq_id.value(unit.residueIndex[element]),
            pdbx_PDB_ins_code: unit.model.atomicHierarchy.residues.pdbx_PDB_ins_code.value(unit.residueIndex[element]),
            x: unit.model.atomicConformation.x[element],
            y: unit.model.atomicConformation.y[element],
            z: unit.model.atomicConformation.z[element],
            occupancy: unit.model.atomicConformation.occupancy.value(element),
            B_iso_or_equiv: unit.model.atomicConformation.B_iso_or_equiv.value(element),
            type_symbol: (0, string_1.getStandardTypeSymbol)(unit.model.atomicHierarchy.atoms.type_symbol.value(element)),
            charge: unit.model.atomicHierarchy.atoms.pdbx_formal_charge.value(element) ||
                ((_a = partial_charge_1.AtomPartialCharge.Provider.get(unit.model)) === null || _a === void 0 ? void 0 : _a.data.value(element)) ||
                0
        });
    });
    var elementIdSet = new Set(elementIds);
    var aromaticBondMap = new Map();
    if (allowAromaticBondType && ((_c = structure.model) === null || _c === void 0 ? void 0 : _c.sourceData.kind) === 'mmCIF') {
        var _loop_1 = function (i, il) {
            var unit_1 = structure.units[i];
            var _loop_2 = function (j, jl) {
                var ring = unit_1.rings.all[unit_1.rings.aromaticRings[j]];
                var ringElements = ring.map(function (item) { return unit_1.elements[item]; });
                ringElements.forEach(function (atom, index) {
                    if (elementIdSet.has(atom)) {
                        aromaticBondMap.set(atom, new Set((0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], ringElements.slice(0, index), true), ringElements.slice(index + 1), true)));
                    }
                });
            };
            for (var j = 0, jl = unit_1.rings.aromaticRings.length; j < jl; j++) {
                _loop_2(j, jl);
            }
        };
        for (var i = 0, il = structure.units.length; i < il; i++) {
            _loop_1(i, il);
        }
    }
    structure.units.forEach(function (bondUnit) {
        var _a;
        for (var i = 0, l = bondUnit.bonds.a.length; i < l; i++) {
            var a = bondUnit.elements[bondUnit.bonds.a[i]];
            var b = bondUnit.elements[bondUnit.bonds.b[i]];
            if (elements.includes(a) &&
                elements.includes(b) &&
                !bondsMap.has("".concat(a, "_").concat(b)) &&
                !bondsMap.has("".concat(b, "_").concat(a))) {
                var order = allowAromaticBondType && (aromaticBondMap.has(a) && ((_a = aromaticBondMap.get(a)) === null || _a === void 0 ? void 0 : _a.has(b))) ? 4 : bondUnit.bonds.edgeProps.order[i];
                bondsMap.set("".concat(a, "_").concat(b), {
                    a: elements.indexOf(a) + 1,
                    b: elements.indexOf(b) + 1,
                    order: order
                });
            }
        }
    });
    var properties = [];
    if (((_d = structure.model) === null || _d === void 0 ? void 0 : _d.sourceData.kind) === 'sdf' &&
        ((_e = structure.state.models) === null || _e === void 0 ? void 0 : _e.length)) {
        var dataItems = (_f = structure.state.models[0]) === null || _f === void 0 ? void 0 : _f.sourceData.data.dataItems;
        for (var i = 0, l = dataItems.data.rowCount; i < l; i++) {
            properties.push("> ".concat(dataItems.dataHeader.value(i), "\n").concat(dataItems.data.value(i)));
        }
    }
    if (editMolFunc) {
        var _h = editMolFunc(atomList, Array.from(bondsMap).map(function (item) { return item[1]; })), editedAtomList = _h.editedAtomList, editedBondList = _h.editedBondList;
        var res_2 = (0, exports.atomDataToSdf)(editedAtomList, editedBondList);
        // if (affectedAtomIds?.length) {
        //     const content = await addHs(res, 'sdf', affectedAtomIds)
        //     return `${content}\n${properties.join('\n\n')}`
        // }
        return "".concat(res_2, "\n").concat(properties.join('\n\n')).concat(properties.length ? '\n\n' : '', "$$$$");
    }
    var res = (0, exports.atomDataToSdf)(atomList, Array.from(bondsMap).map(function (item) { return item[1]; }));
    return "".concat(res, "\n").concat(properties.join('\n\n')).concat(properties.length ? '\n\n' : '', "$$$$");
}
exports.parseToSdf = parseToSdf;
var getMolChargeTag = function (charge) {
    switch (charge) {
        case 0:
            return 0;
        case 3:
            return 1;
        case 2:
            return 2;
        case 1:
            return 3;
        case -1:
            return 5;
        case -2:
            return 6;
        case -3:
            return 7;
        default:
            return 0;
    }
};
var atomDataToSdf = function (atomList, bondsList, molecularName) {
    var countFormat = '%3d%3d  0  0  0  0  0  0  0  0999 V2000';
    var atomFormat = '%10.4f%10.4f%10.4f %-2s  0%3d  0  0  0  0  0  0  0  0  0  0';
    var bondFormat = '%3s%3s%3s  0  0  0  0';
    var records = [];
    records.push("".concat(molecularName || '', "\n\n"));
    records.push((0, sprintf_js_1.sprintf)(countFormat, atomList.length, bondsList.length));
    atomList.forEach(function (item) {
        var x = item.x, y = item.y, z = item.z, type_symbol = item.type_symbol, charge = item.charge;
        records.push((0, sprintf_js_1.sprintf)(atomFormat, x, y, z, type_symbol, getMolChargeTag(charge)));
    });
    bondsList.forEach(function (item) {
        var a = item.a, b = item.b, order = item.order;
        records.push((0, sprintf_js_1.sprintf)(bondFormat, a, b, order));
    });
    records.push('M  END');
    return records.join('\n');
};
exports.atomDataToSdf = atomDataToSdf;
var getDefaultAtomData = function (atomId, elementType, position, charge) {
    return {
        elementId: -1,
        group_PDB: 'HETATM',
        atom_id: atomId,
        auth_atom_id: elementType,
        label_alt_id: '',
        auth_comp_id: 'UNK',
        auth_asym_id: ' ',
        auth_seq_id: '1',
        x: parseFloat(position[0].toFixed(3)),
        y: parseFloat(position[1].toFixed(3)),
        z: parseFloat(position[2].toFixed(3)),
        occupancy: '1',
        B_iso_or_equiv: '0.00',
        type_symbol: elementType,
        charge: charge !== null && charge !== void 0 ? charge : 0
    };
};
exports.getDefaultAtomData = getDefaultAtomData;
var getMergedStructureContent = function (structures, 
// 目前只有Add Bond的情况才能调用merge，根据后续场景判断是否变成通用参数
newBondAtoms) {
    var atomList = [];
    var bondList = [];
    var atomId = 1;
    var format = 'sdf';
    var newBondAtomId = [];
    var sdfAtomList = [];
    var isRemapChainId = false;
    var chainIdSet = new Set();
    var remapChainIdMap = new Map();
    var data = structures.sort(function (a) { var _a; return ((_a = (0, structure_1.getModelByStructure)(a)) === null || _a === void 0 ? void 0 : _a.sourceData.kind) === 'mmCIF' ? -1 : 1; });
    data.forEach(function (structure, index) {
        var _a;
        if (!structure)
            return;
        if (((_a = (0, structure_1.getModelByStructure)(structure)) === null || _a === void 0 ? void 0 : _a.sourceData.kind) ===
            'mmCIF') {
            var chainIds = Array.from((0, structure_1.getModelByStructure)(structure).properties.structAsymMap.keys());
            chainIds.forEach(function (chainId) {
                remapChainIdMap.set("".concat(index, "\n").concat(chainId), chainId);
                if (chainIdSet.has(chainId)) {
                    isRemapChainId = true;
                }
                chainIdSet.add(chainId);
            });
        }
    });
    var sdfChainId = '';
    var sdfResidueId = 1;
    if (remapChainIdMap.size > 35) {
        return { format: 'pdb', type: MIME.PDB, content: '' };
    }
    if (isRemapChainId) {
        chainIdSet.clear();
        Array.from(remapChainIdMap.keys()).forEach(function (key, index) {
            var chainId = 65 + index > 90 ? String.fromCharCode(65 + index) : "".concat(index);
            remapChainIdMap.set(key, chainId);
            if (index === remapChainIdMap.size - 1) {
                sdfChainId = 65 + index + 1 > 90 ? String.fromCharCode(65 + index + 1) : "".concat(index);
            }
        });
    }
    else {
        for (var i = 65; i < 91 && sdfChainId === ''; i++) {
            var chainId = String.fromCharCode(i);
            if (!chainIdSet.has(chainId)) {
                sdfChainId = chainId;
            }
        }
        for (var i = 48; i < 58 && sdfChainId === ''; i++) {
            var chainId = String.fromCharCode(i);
            if (!chainIdSet.has(chainId)) {
                sdfChainId = chainId;
            }
        }
    }
    data.forEach(function (structure, i) {
        var _a;
        if (!structure)
            return;
        if (((_a = (0, structure_1.getModelByStructure)(structure)) === null || _a === void 0 ? void 0 : _a.sourceData.kind) ===
            'mmCIF') {
            var res = [];
            var header = (0, exports.getPDBSectionLine)(structure, ['HEADER']);
            res.push.apply(res, header);
            var elements_1 = (0, structure_1.getElementsFromStructure)(structure);
            var unit_2 = structure.units[0];
            var atoms_1 = [];
            elements_1.forEach(function (element) {
                var _a;
                if (newBondAtoms &&
                    ((i === newBondAtoms[0].index && element === newBondAtoms[0].elementId[0]) ||
                        (i === newBondAtoms[1].index && element === newBondAtoms[1].elementId[0]))) {
                    newBondAtomId.push(atomId);
                }
                var chainId = unit_2.model.atomicHierarchy.chains.auth_asym_id.value(unit_2.chainIndex[element]);
                var atom = {
                    elementId: atomId,
                    atom_id: "".concat(atomId),
                    group_PDB: unit_2.model.atomicHierarchy.residues.group_PDB.value(unit_2.residueIndex[element]),
                    auth_atom_id: unit_2.model.atomicHierarchy.atoms.auth_atom_id.value(element),
                    label_alt_id: unit_2.model.atomicHierarchy.atoms.label_alt_id.value(element),
                    auth_comp_id: unit_2.model.atomicHierarchy.atoms.label_comp_id.value(element),
                    auth_asym_id: (_a = remapChainIdMap.get("".concat(i, "\n").concat(chainId))) !== null && _a !== void 0 ? _a : chainId,
                    auth_seq_id: unit_2.model.atomicHierarchy.residues.auth_seq_id.value(unit_2.residueIndex[element]),
                    pdbx_PDB_ins_code: unit_2.model.atomicHierarchy.residues.pdbx_PDB_ins_code.value(unit_2.residueIndex[element]),
                    x: unit_2.model.atomicConformation.x[element],
                    y: unit_2.model.atomicConformation.y[element],
                    z: unit_2.model.atomicConformation.z[element],
                    occupancy: unit_2.model.atomicConformation.occupancy.value(element),
                    B_iso_or_equiv: unit_2.model.atomicConformation.B_iso_or_equiv.value(element),
                    type_symbol: (0, string_1.getStandardTypeSymbol)(unit_2.model.atomicHierarchy.atoms.type_symbol.value(element)),
                    charge: unit_2.model.atomicHierarchy.atoms.pdbx_formal_charge.value(element),
                };
                atoms_1.push(atom);
                atomId++;
            });
            var bondsMap_1 = new Map();
            structure.units.forEach(function (bondUnit) {
                for (var i_1 = 0, l = bondUnit.bonds.a.length; i_1 < l; i_1++) {
                    var a = bondUnit.elements[bondUnit.bonds.a[i_1]];
                    var b = bondUnit.elements[bondUnit.bonds.b[i_1]];
                    if (elements_1.includes(a) &&
                        elements_1.includes(b) &&
                        !bondsMap_1.has("".concat(a, "_").concat(b)) &&
                        !bondsMap_1.has("".concat(b, "_").concat(a))) {
                        var order = bondUnit.bonds.edgeProps.order[i_1];
                        bondsMap_1.set("".concat(a, "_").concat(b), {
                            a: atoms_1[elements_1.indexOf(a)].elementId,
                            b: atoms_1[elements_1.indexOf(b)].elementId,
                            order: order,
                            atom_idA: atoms_1[elements_1.indexOf(a)].atom_id,
                            atom_idB: atoms_1[elements_1.indexOf(a)].atom_id,
                        });
                    }
                }
            });
            atomList.push.apply(atomList, atoms_1);
            bondList.push.apply(bondList, Array.from(bondsMap_1).map(function (item) { return item[1]; }));
            format = 'pdb';
        }
        else {
            var elements_2 = (0, structure_1.getElementsFromStructure)(structure);
            var unit_3 = structure.units[0];
            var atoms_2 = [];
            var bondsMap_2 = new Map();
            elements_2.forEach(function (element) {
                var _a;
                if (newBondAtoms &&
                    ((i === newBondAtoms[0].index && element === newBondAtoms[0].elementId[0]) ||
                        (i === newBondAtoms[1].index && element === newBondAtoms[1].elementId[0]))) {
                    newBondAtomId.push(atomId);
                }
                atoms_2.push({
                    elementId: atomId,
                    group_PDB: 'HETATM',
                    atom_id: "".concat(atomId),
                    auth_atom_id: unit_3.model.atomicHierarchy.atoms.label_atom_id.value(element),
                    label_alt_id: unit_3.model.atomicHierarchy.atoms.label_alt_id.value(element),
                    auth_comp_id: unit_3.model.atomicHierarchy.atoms.label_comp_id.value(element),
                    auth_asym_id: sdfChainId,
                    auth_seq_id: "".concat(sdfResidueId),
                    pdbx_PDB_ins_code: unit_3.model.atomicHierarchy.residues.pdbx_PDB_ins_code.value(unit_3.residueIndex[element]),
                    x: unit_3.model.atomicConformation.x[element],
                    y: unit_3.model.atomicConformation.y[element],
                    z: unit_3.model.atomicConformation.z[element],
                    occupancy: unit_3.model.atomicConformation.occupancy.value(element),
                    B_iso_or_equiv: unit_3.model.atomicConformation.B_iso_or_equiv.value(element),
                    type_symbol: (0, string_1.getStandardTypeSymbol)(unit_3.model.atomicHierarchy.atoms.type_symbol.value(element)),
                    charge: unit_3.model.atomicHierarchy.atoms.pdbx_formal_charge.value(element) ||
                        ((_a = partial_charge_1.AtomPartialCharge.Provider.get(unit_3.model)) === null || _a === void 0 ? void 0 : _a.data.value(element)) ||
                        0,
                });
                atomId++;
            });
            // 环上的bond也要考虑进来
            structure.units.forEach(function (bondUnit) {
                for (var i_2 = 0, l = bondUnit.bonds.a.length; i_2 < l; i_2++) {
                    var a = bondUnit.elements[bondUnit.bonds.a[i_2]];
                    var b = bondUnit.elements[bondUnit.bonds.b[i_2]];
                    if (elements_2.includes(a) &&
                        elements_2.includes(b) &&
                        !bondsMap_2.has("".concat(a, "_").concat(b)) &&
                        !bondsMap_2.has("".concat(b, "_").concat(a))) {
                        var order = bondUnit.bonds.edgeProps.order[i_2];
                        bondsMap_2.set("".concat(a, "_").concat(b), {
                            a: atoms_2[elements_2.indexOf(a)].elementId,
                            b: atoms_2[elements_2.indexOf(b)].elementId,
                            order: order,
                            atom_idA: atoms_2[elements_2.indexOf(a)].atom_id,
                            atom_idB: atoms_2[elements_2.indexOf(a)].atom_id,
                        });
                    }
                }
            });
            sdfResidueId++;
            sdfAtomList.push.apply(sdfAtomList, atoms_2);
            bondList.push.apply(bondList, Array.from(bondsMap_2).map(function (item) { return item[1]; }));
        }
    });
    if (newBondAtomId.length === 2) {
        bondList.push({
            a: newBondAtomId[0],
            b: newBondAtomId[1],
            order: 1,
            atom_idA: "".concat(newBondAtomId[0]),
            atom_idB: "".concat(newBondAtomId[1]),
        });
    }
    atomList.push.apply(atomList, sdfAtomList);
    if (format === 'pdb') {
        return { format: 'pdb', type: MIME.PDB, content: atomList.length > 99999 ? '' : atomDataToPdb(atomList, bondList, false, false) };
    }
    return { format: 'sdf', type: MIME.SDF, content: atomList.length > 999 || bondList.length > 999 ? '' : "".concat((0, exports.atomDataToSdf)(atomList, bondList), "\n$$$$") };
};
exports.getMergedStructureContent = getMergedStructureContent;
var splitMolecularContent = function (content, format) {
    switch (format) {
        case types_1.Format.Pdb:
            return (0, exports.splitPdbContent)(content);
        case types_1.Format.Sdf:
        case types_1.Format.Mol:
            return (0, exports.splitSdfContent)(content);
        default:
            return [content];
    }
};
exports.splitMolecularContent = splitMolecularContent;
var splitPdbContent = function (content) {
    var lines = content.split('\n');
    var globalLines = [];
    var unGlobalLines = [[]];
    var i = 0;
    lines.forEach(function (line) {
        switch (line[0]) {
            case 'A':
                if (line.startsWith('ATOM')) {
                    unGlobalLines[i].push(line);
                    return;
                }
                if (line.startsWith('AUTHER'))
                    return;
                globalLines.push(line);
                break;
            case 'C':
                if (line.startsWith('CONECT')) {
                    unGlobalLines[i].push(line);
                    return;
                }
                globalLines.push(line);
                break;
            case 'E':
                if (line.startsWith('ENDMDL')) {
                    if (unGlobalLines[i].length > 0) {
                        i++;
                        unGlobalLines.push([]);
                    }
                    return;
                }
                if (line.startsWith('END'))
                    return;
                globalLines.push(line);
                break;
            case 'H':
                if (line.startsWith('HETATM')) {
                    unGlobalLines[i].push(line);
                    return;
                }
                globalLines.push(line);
                break;
            case 'M':
                if (line.startsWith('MODEL')) {
                    if (unGlobalLines[i].length > 0) {
                        i++;
                        unGlobalLines.push([]);
                    }
                    return;
                }
                if (line.startsWith('MASTER'))
                    return;
                globalLines.push(line);
                break;
            case 'R':
                if (line.startsWith('REVDAT'))
                    return;
                globalLines.push(line);
                break;
            case 'S':
                if (line.startsWith('SOURCE'))
                    return;
                globalLines.push(line);
                break;
            case 'T':
                if (line.startsWith('TER')) {
                    unGlobalLines[i].push(line);
                    return;
                }
                globalLines.push(line);
                break;
            default:
                globalLines.push(line);
        }
    });
    var globalContent = globalLines.join('\n');
    var res = [];
    unGlobalLines.forEach(function (item) {
        if (item.length > 0) {
            res.push("".concat(globalContent).concat(globalContent ? '\n' : '').concat(item.join('\n')));
        }
    });
    return res;
};
exports.splitPdbContent = splitPdbContent;
var splitSdfContent = function (content) {
    return content.split(/\$\$\$\$\r?\n?/).filter(function (item) { return item.trim() !== ''; });
};
exports.splitSdfContent = splitSdfContent;
// 目前没在用了，用户输入属实太不靠谱了，不敢检查
var pdbValidate = function (content) {
    var lines = content.split('\n');
    var errorLine = [];
    lines.forEach(function (line, index) {
        switch (line[0]) {
            case 'A':
                if (line.startsWith('ATOM')) {
                    var errorInfo = (0, format_1.checkLineValidate)(line, constant_1.pdbAtomLineFormat);
                    if (errorInfo.length > 0) {
                        errorLine.push({
                            index: index,
                            info: errorInfo,
                        });
                    }
                }
                if (line.startsWith('ANISOU')) {
                    var errorInfo = (0, format_1.checkLineValidate)(line, constant_1.pdbAnisouLineFormat);
                    if (errorInfo.length > 0) {
                        errorLine.push({
                            index: index,
                            info: errorInfo,
                        });
                    }
                }
                break;
            case 'C':
                if (line.startsWith('CONECT')) {
                    var errorInfo = (0, format_1.checkLineValidate)(line, constant_1.pdbConectLineFormat);
                    if (errorInfo.length > 0) {
                        errorLine.push({
                            index: index,
                            info: errorInfo,
                        });
                    }
                }
                break;
            case 'H':
                if (line.startsWith('HETATM')) {
                    var errorInfo = (0, format_1.checkLineValidate)(line, constant_1.pdbAtomLineFormat);
                    if (errorInfo.length > 0) {
                        errorLine.push({
                            index: index,
                            info: errorInfo,
                        });
                    }
                }
                break;
            default:
        }
    });
    return errorLine;
};
exports.pdbValidate = pdbValidate;
// 由于rdkit不支持，stext block目前被判断为invalid
var molValidate = function (content) {
    var lines = content.split('\n');
    var isStart = true;
    var hasLigand = false;
    var headers = [];
    var errorLine = [];
    for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i];
        if (isStart) {
            if (headers.length < 4) {
                headers.push(line);
                if (headers.length === 4) {
                    var errorInfo = (0, format_1.checkLineValidate)(line, constant_1.molCountLineFormat);
                    if (errorInfo.length > 0) {
                        errorLine.push({
                            index: i,
                            info: errorInfo,
                        });
                    }
                }
            }
            else if (line.startsWith('M  END')) {
                hasLigand = true;
                isStart = false;
                headers = [];
            }
            else if (!line.startsWith('M') && !line.startsWith('V')) {
                if (line.startsWith('G') || line.startsWith('A')) {
                    i++;
                }
                else if (line.slice(4, 5) !== 'T' && line.slice(4, 5) !== 'F') {
                    if (line.length < 34) {
                        var errorInfo = (0, format_1.checkLineValidate)(line, constant_1.molBondFormatCheck);
                        if (errorInfo.length > 0) {
                            errorLine.push({
                                index: i,
                                info: errorInfo,
                            });
                        }
                    }
                    else {
                        var errorInfo = (0, format_1.checkLineValidate)(line, constant_1.molAtomLineFormat);
                        if (errorInfo.length > 0) {
                            errorLine.push({
                                index: i,
                                info: errorInfo,
                            });
                        }
                    }
                }
            }
        }
        else if (line.startsWith('$$$$')) {
            isStart = true;
            headers = [];
        }
    }
    if (!hasLigand) {
        errorLine.push({
            index: 0,
            info: [
                {
                    start: 0,
                    end: 0,
                },
            ],
        });
    }
    return errorLine;
};
exports.molValidate = molValidate;
var checkFileFormat = function (content, foramt) {
    switch (foramt) {
        case types_1.Format.Sdf:
        case types_1.Format.Mol:
            return (0, exports.molValidate)(content);
        // case 'pdb':
        //     return pdbValidate(content);
        default:
            return [];
    }
};
exports.checkFileFormat = checkFileFormat;
//# sourceMappingURL=writer.js.map