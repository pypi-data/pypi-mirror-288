"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapshotManager = void 0;
var tslib_1 = require("tslib");
var index_1 = require("../index");
var types_1 = require("../types");
var object_1 = require("../../mol-util/object");
var utils_1 = require("../utils");
var download_1 = require("../../mol-util/download");
var rx_event_helper_1 = require("../../mol-util/rx-event-helper");
var model_1 = require("../model");
var secondary_structure_1 = require("../../mol-model-props/computed/secondary-structure");
var model_2 = require("../../mol-model/structure/model");
var SnapshotManager = /** @class */ (function () {
    function SnapshotManager(plugin) {
        this.ev = rx_event_helper_1.RxEventHelper.create();
        this.event = {
            changed: this.ev()
        };
        this.plugin = plugin;
    }
    SnapshotManager.prototype.setSnapshot = function (snapshot, getDataByServerData) {
        var _a, _b, _c, _d, _e;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var cells, _i, _f, cell, _loop_1, this_1, _g, _h, cell;
            return (0, tslib_1.__generator)(this, function (_j) {
                switch (_j.label) {
                    case 0:
                        cells = new Map();
                        if (((_a = snapshot === null || snapshot === void 0 ? void 0 : snapshot.params) === null || _a === void 0 ? void 0 : _a.showPolarHydrogenOnly) !== undefined) {
                            this.plugin.managers.representation.showPolarHydrogenOnly = snapshot.params.showPolarHydrogenOnly;
                        }
                        if (((_b = snapshot === null || snapshot === void 0 ? void 0 : snapshot.params) === null || _b === void 0 ? void 0 : _b.interactionParams) !== undefined) {
                            this.plugin.managers.representation.interactionParams = snapshot.params.interactionParams;
                        }
                        for (_i = 0, _f = snapshot.cells; _i < _f.length; _i++) {
                            cell = _f[_i];
                            cells.set(cell.ref, {
                                ref: cell.ref,
                                assets: cell.assets,
                                dependency: cell.dependency,
                                model: {},
                                representations: new Map(),
                                theme: cell.theme
                            });
                        }
                        this.plugin.cells = cells;
                        _loop_1 = function (cell) {
                            var _k, structure, trajectory, other, representations, dependency, theme, cellStructure, structures, _l, _m, cellTheme, newTheme_1, _loop_2, _o, representations_1, r, r, hasServerData, sourceData, _p, newDependencyOnData;
                            return (0, tslib_1.__generator)(this, function (_q) {
                                switch (_q.label) {
                                    case 0:
                                        _k = cell.model, structure = _k.structure, trajectory = _k.trajectory, other = _k.other, representations = cell.representations, dependency = cell.dependency, theme = cell.theme;
                                        cellStructure = void 0;
                                        if (!structure) return [3 /*break*/, 6];
                                        if (!(representations === null || representations === void 0 ? void 0 : representations.some(function (repr) { return repr.isHidden !== true; }))) return [3 /*break*/, 5];
                                        _m = (_l = model_1.FormatProvider[structure.format]).parse;
                                        return [4 /*yield*/, (0, utils_1.readAsString)(structure.data)];
                                    case 1: return [4 /*yield*/, _m.apply(_l, [_q.sent()])];
                                    case 2:
                                        structures = (_q.sent());
                                        if (!(structure.format === types_1.Format.Pdb && !!structures[0].elementCount && !model_2.Model.hasSecondaryStructure((_c = structures[0]) === null || _c === void 0 ? void 0 : _c.model))) return [3 /*break*/, 4];
                                        return [4 /*yield*/, secondary_structure_1.SecondaryStructureProvider.attach({}, structures[0], {
                                                type: {
                                                    name: 'dssp',
                                                    params: { oldDefinition: true, oldOrdering: true }
                                                }
                                            }, true)];
                                    case 3:
                                        _q.sent();
                                        _q.label = 4;
                                    case 4:
                                        cellStructure = structures[0];
                                        this_1.plugin.managers.cell.update(cell.ref, {
                                            representations: [],
                                            model: {
                                                structure: structures[0]
                                            },
                                            assets: [{ format: structure.format, data: structure.data }]
                                        });
                                        return [3 /*break*/, 6];
                                    case 5:
                                        this_1.plugin.managers.cell.update(cell.ref, {
                                            representations: [],
                                            model: {
                                                structure: undefined
                                            },
                                            assets: [{ format: structure.format, data: structure.data }]
                                        });
                                        _q.label = 6;
                                    case 6:
                                        cellTheme = cell.theme;
                                        if (theme) {
                                            newTheme_1 = {};
                                            Object.keys(theme).forEach(function (key) {
                                                var themeData = theme[key];
                                                if (themeData) {
                                                    var newThemeData_1 = {};
                                                    Object.keys(themeData).forEach(function (themeC) {
                                                        var items = themeData[themeC];
                                                        var res = [];
                                                        if (items === null || items === void 0 ? void 0 : items.length) {
                                                            items.forEach(function (item) {
                                                                res.push((0, tslib_1.__assign)((0, tslib_1.__assign)({}, item), { elementIds: item.elementIds ? (0, utils_1.uncompressElementIds)(item.elementIds) : item.elementIds }));
                                                            });
                                                        }
                                                        newThemeData_1[themeC] = res;
                                                    });
                                                    newTheme_1[key] = newThemeData_1;
                                                }
                                            });
                                            cellTheme = newTheme_1;
                                            this_1.plugin.managers.cell.update(cell.ref, {
                                                representations: [],
                                                model: {},
                                                theme: newTheme_1,
                                            });
                                        }
                                        if (!(representations === null || representations === void 0 ? void 0 : representations.length)) return [3 /*break*/, 11];
                                        if (!!cellStructure) return [3 /*break*/, 7];
                                        this_1.plugin.managers.cell.update(cell.ref, {
                                            representations: representations === null || representations === void 0 ? void 0 : representations.map(function (repr) {
                                                var _a;
                                                if (repr.cache)
                                                    return repr;
                                                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, repr), { elementIds: [], cache: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, repr), { elementIds: ((_a = repr.elementIds) === null || _a === void 0 ? void 0 : _a.length) ? (0, utils_1.uncompressElementIds)(repr.elementIds) : repr.elementIds }) });
                                            }),
                                            model: {},
                                        });
                                        return [3 /*break*/, 11];
                                    case 7:
                                        _loop_2 = function (r) {
                                            var themeC, colorItems, transparency, elementIds;
                                            return (0, tslib_1.__generator)(this, function (_r) {
                                                switch (_r.label) {
                                                    case 0:
                                                        if (!((_d = r.elementIds) === null || _d === void 0 ? void 0 : _d.length)) return [3 /*break*/, 2];
                                                        themeC = Object.keys(types_1.ReprCBasedTheme).find(function (key) {
                                                            return types_1.ReprCBasedTheme[key].includes(r.type);
                                                        });
                                                        colorItems = cellTheme.color[themeC];
                                                        transparency = cellTheme.transparency ? cellTheme.transparency[themeC] : undefined;
                                                        elementIds = r.elementIds ? (0, utils_1.uncompressElementIds)(r.elementIds) : [];
                                                        // snapshot 恢复空elementId
                                                        return [4 /*yield*/, this_1.plugin.managers.representation.addMolecularRepr(cell.ref, {
                                                                reprType: r.type,
                                                                elementIds: elementIds,
                                                                isHidden: r.isHidden,
                                                                theme: this_1.plugin.managers.representation.createTheme(r.type, (0, utils_1.getStructureByElementIds)(cellStructure, elementIds, true), {
                                                                    color: {
                                                                        name: 'multi-theme',
                                                                        props: { themes: colorItems }
                                                                    },
                                                                    size: cellTheme.size && ((_e = cellTheme.size[themeC]) === null || _e === void 0 ? void 0 : _e.length) ? cellTheme.size[themeC][0] : this_1.plugin.managers.representation.defaultTheme.size[r.type],
                                                                }),
                                                                transparency: transparency,
                                                            })];
                                                    case 1:
                                                        // snapshot 恢复空elementId
                                                        _r.sent();
                                                        _r.label = 2;
                                                    case 2: return [2 /*return*/];
                                                }
                                            });
                                        };
                                        _o = 0, representations_1 = representations;
                                        _q.label = 8;
                                    case 8:
                                        if (!(_o < representations_1.length)) return [3 /*break*/, 11];
                                        r = representations_1[_o];
                                        return [5 /*yield**/, _loop_2(r)];
                                    case 9:
                                        _q.sent();
                                        _q.label = 10;
                                    case 10:
                                        _o++;
                                        return [3 /*break*/, 8];
                                    case 11:
                                        if (!other) return [3 /*break*/, 16];
                                        r = representations[0];
                                        hasServerData = other.serverData && !other.data;
                                        if (!(hasServerData && getDataByServerData)) return [3 /*break*/, 13];
                                        return [4 /*yield*/, getDataByServerData(other.serverData)];
                                    case 12:
                                        _p = _q.sent();
                                        return [3 /*break*/, 14];
                                    case 13:
                                        _p = other;
                                        _q.label = 14;
                                    case 14:
                                        sourceData = _p;
                                        return [4 /*yield*/, this_1.plugin.managers.representation.createOther({
                                                data: r.type === index_1.RepresentationType.IsoSurface ? new File([sourceData.data], sourceData.name) : sourceData,
                                                serverData: other.serverData,
                                                type: r.type,
                                                ref: cell.ref,
                                                isHidden: r.isHidden
                                                // TODO other 类型的repr有theme吗
                                            })];
                                    case 15:
                                        _q.sent();
                                        _q.label = 16;
                                    case 16:
                                        if (!dependency.on.length) return [3 /*break*/, 18];
                                        newDependencyOnData = dependency.on.map(function (item) { return ((0, tslib_1.__assign)((0, tslib_1.__assign)({}, item), { elementIds: item.elementIds ? (0, utils_1.uncompressElementIds)(item.elementIds) : item.elementIds })); });
                                        return [4 /*yield*/, this_1.plugin.managers.representation.createMeasurement({
                                                items: newDependencyOnData,
                                                type: representations[0].type,
                                                ref: cell.ref,
                                                props: representations[0].params,
                                                isHidden: representations[0].isHidden,
                                            })];
                                    case 17:
                                        _q.sent();
                                        this_1.plugin.managers.cell.update(cell.ref, {
                                            representations: [],
                                            model: {},
                                            dependency: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, cell.dependency), { on: newDependencyOnData })
                                        });
                                        _q.label = 18;
                                    case 18:
                                        if (trajectory) {
                                            // TODO
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        _g = 0, _h = snapshot.cells;
                        _j.label = 1;
                    case 1:
                        if (!(_g < _h.length)) return [3 /*break*/, 4];
                        cell = _h[_g];
                        return [5 /*yield**/, _loop_1(cell)];
                    case 2:
                        _j.sent();
                        _j.label = 3;
                    case 3:
                        _g++;
                        return [3 /*break*/, 1];
                    case 4:
                        this.refresh();
                        return [2 /*return*/];
                }
            });
        });
    };
    SnapshotManager.prototype.getSnapshot = function (toServer) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var cells, elementIdsMap;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.timestamp = Date.now();
                        cells = [];
                        elementIdsMap = {};
                        Array.from(this.plugin.cells.values()).map(function (cell) {
                            var structure = cell.model.structure, ref = cell.ref;
                            if (structure) {
                                var elementsMap_1 = new Map();
                                var current_1 = 0;
                                structure.units.forEach(function (unit) {
                                    unit.elements.forEach(function (elementId) {
                                        elementsMap_1.set(elementId, current_1++);
                                    });
                                });
                                elementIdsMap[ref] = elementsMap_1;
                            }
                        });
                        return [4 /*yield*/, Promise.all(Array.from(this.plugin.cells.values()).map(function (cell) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                                var representations, assets, _a, structure, trajectory, other, rest, newCell, hasServerData, sourceFile, _b, _c, _d, elementsMap_2, dependOn_1;
                                var _e;
                                var _f, _g, _h;
                                return (0, tslib_1.__generator)(this, function (_j) {
                                    switch (_j.label) {
                                        case 0:
                                            representations = cell.representations, assets = cell.assets, _a = cell.model, structure = _a.structure, trajectory = _a.trajectory, other = _a.other, rest = (0, tslib_1.__rest)(cell, ["representations", "assets", "model"]);
                                            newCell = (0, object_1.deepClone)(rest);
                                            newCell.model = {};
                                            if (representations.get(index_1.RepresentationType.IntraInteractions) ||
                                                representations.get(index_1.RepresentationType.BetweenInteractions)) {
                                                return [2 /*return*/];
                                            }
                                            if (structure) {
                                                newCell.model.structure = {
                                                    data: (0, utils_1.getTextFromStructure)(structure, assets === null || assets === void 0 ? void 0 : assets[0].format),
                                                    format: assets === null || assets === void 0 ? void 0 : assets[0].format
                                                };
                                            }
                                            else if (assets) {
                                                newCell.assets = assets;
                                            }
                                            // if (loci) {
                                            //   // XXX 这块ref的取值逻辑稍微有点风险
                                            //   newCell.model.loci = loci.map((l, index) => ({
                                            //     ref: cell.dependency.on[index].ref,
                                            //     elementIds: getElementIdsByLoci(l)
                                            //   }))
                                            // }
                                            if (trajectory) {
                                                // TODO trajectory.state中提取结构信息
                                                newCell.model.trajectory = {
                                                    data: '提取的结构信息',
                                                    format: assets === null || assets === void 0 ? void 0 : assets[0].format
                                                };
                                            }
                                            if (!other) return [3 /*break*/, 5];
                                            if (!representations.get(index_1.RepresentationType.IsoSurface)) return [3 /*break*/, 4];
                                            hasServerData = !!cell.model.other.serverData;
                                            sourceFile = hasServerData ? cell.model.other.data : cell.model.other;
                                            _b = newCell.model;
                                            if (!toServer) return [3 /*break*/, 1];
                                            _c = {
                                                serverData: hasServerData ? cell.model.other.serverData : cell.model.other
                                            };
                                            return [3 /*break*/, 3];
                                        case 1:
                                            _e = {};
                                            _d = Uint8Array.bind;
                                            return [4 /*yield*/, sourceFile.arrayBuffer()];
                                        case 2:
                                            _c = (_e.data = new (_d.apply(Uint8Array, [void 0, _j.sent()]))(),
                                                _e.name = sourceFile.name,
                                                _e.serverData = hasServerData ? cell.model.other.serverData : cell.model.other,
                                                _e);
                                            _j.label = 3;
                                        case 3:
                                            _b.other = _c;
                                            return [3 /*break*/, 5];
                                        case 4:
                                            newCell.model.other = cell.model.other;
                                            _j.label = 5;
                                        case 5:
                                            if (representations === null || representations === void 0 ? void 0 : representations.size) {
                                                newCell.representations = [];
                                                elementsMap_2 = elementIdsMap[rest.ref];
                                                representations.forEach(function (representation) {
                                                    // Repr State Cache
                                                    newCell.representations.push({
                                                        type: representation.type,
                                                        elementIds: representation.state ? (0, utils_1.compressElementIds)((0, utils_1.getElementIdsFromRepresentation)(representation.state).map(function (elementId) { return elementsMap_2 && (elementsMap_2 === null || elementsMap_2 === void 0 ? void 0 : elementsMap_2.has(elementId)) ? elementsMap_2 === null || elementsMap_2 === void 0 ? void 0 : elementsMap_2.get(elementId) : elementId; })) : [],
                                                        isHidden: representation.isHidden,
                                                        params: types_1.MeasurementType.has(representation.type) && representation.state ? (0, utils_1.getMeasurementProps)(representation.type, representation.state) : undefined,
                                                        cache: representation.cache,
                                                    });
                                                });
                                                if (rest.theme) {
                                                    Object.keys(rest.theme).forEach(function (key) {
                                                        var themeData = rest.theme[key];
                                                        if (themeData) {
                                                            var newThemeData_2 = {};
                                                            Object.keys(themeData).forEach(function (themeC) {
                                                                var items = themeData[themeC];
                                                                var res = [];
                                                                if (items === null || items === void 0 ? void 0 : items.length) {
                                                                    items.forEach(function (item) {
                                                                        res.push((0, tslib_1.__assign)((0, tslib_1.__assign)({}, item), { elementIds: (0, utils_1.compressElementIds)(item.elementIds && elementsMap_2 ? item.elementIds.map(function (elementId) { var _a; return (_a = elementsMap_2.get(elementId)) !== null && _a !== void 0 ? _a : elementId; }) : item.elementIds) }));
                                                                    });
                                                                }
                                                                newThemeData_2[themeC] = res;
                                                            });
                                                            newCell.theme[key] = newThemeData_2;
                                                        }
                                                    });
                                                }
                                            }
                                            if ((_g = (_f = rest.dependency) === null || _f === void 0 ? void 0 : _f.on) === null || _g === void 0 ? void 0 : _g.length) {
                                                dependOn_1 = [];
                                                (_h = rest.dependency) === null || _h === void 0 ? void 0 : _h.on.forEach(function (item) {
                                                    var elementsMap = elementIdsMap[rest.ref];
                                                    dependOn_1.push((0, tslib_1.__assign)((0, tslib_1.__assign)({}, item), { elementIds: (0, utils_1.compressElementIds)(item.elementIds && elementsMap ? item.elementIds.map(function (elementId) { var _a; return (_a = elementsMap.get(elementId)) !== null && _a !== void 0 ? _a : elementId; }) : item.elementIds) }));
                                                });
                                                newCell.dependency.on = dependOn_1;
                                            }
                                            cells.push(newCell);
                                            return [2 /*return*/];
                                    }
                                });
                            }); }))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, {
                                cells: cells,
                                timestamp: this.timestamp,
                                params: {
                                    interactionParams: (0, object_1.deepClone)(this.plugin.managers.representation.interactionParams),
                                    showPolarHydrogenOnly: this.plugin.managers.representation.showPolarHydrogenOnly,
                                }
                            }];
                }
            });
        });
    };
    SnapshotManager.prototype.refresh = function () {
        var _a, _b, _c;
        var plugin = this.plugin;
        (_a = plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.pause(true);
        (_b = plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.clear();
        plugin.cells.forEach(function (cell) {
            cell.representations.forEach(function (r) {
                var _a;
                if (!r.isHidden && r.state) {
                    (_a = plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.add(r.state);
                }
            });
        });
        // TODO 会引起 WebGL: INVALID_OPERATION: bindTexture: attempt to use a deleted object，暂时不知道什么时候调用animate合适
        (_c = plugin.canvas3d) === null || _c === void 0 ? void 0 : _c.animate();
    };
    SnapshotManager.prototype.downloadAsImage = function (name, params) {
        var _a, _b;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _c, width, height, crop, viewport, c, _d, colorBufferFloat, textureFloat, aoProps, pass, imageData, canvas, canvasCtx, blob;
            return (0, tslib_1.__generator)(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _c = params
                            ? params
                            : {
                                width: ((_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.webgl.gl.drawingBufferWidth) || 0,
                                height: ((_b = this.plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.webgl.gl.drawingBufferHeight) || 0
                            }, width = _c.width, height = _c.height;
                        crop = { x: 0, y: 0, width: 1, height: 1 } // 目前暂时写死
                        ;
                        viewport = {
                            x: Math.floor(crop.x * width),
                            y: Math.floor(crop.y * height),
                            width: Math.ceil(crop.width * width),
                            height: Math.ceil(crop.height * height)
                        };
                        if (viewport.width + viewport.x > width)
                            viewport.width = width - viewport.x;
                        if (viewport.height + viewport.y > height)
                            viewport.height = height - viewport.y;
                        if (width <= 0 || height <= 0)
                            return [2 /*return*/];
                        c = this.plugin.canvas3d;
                        _d = c.webgl.extensions, colorBufferFloat = _d.colorBufferFloat, textureFloat = _d.textureFloat;
                        aoProps = c.props.postprocessing.occlusion;
                        pass = c.getImagePass({
                            transparentBackground: true,
                            cameraHelper: { axes: { name: 'off', params: {} } },
                            multiSample: {
                                mode: 'on',
                                sampleLevel: colorBufferFloat && textureFloat ? 4 : 2
                            },
                            postprocessing: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, c.props.postprocessing), { occlusion: aoProps.name === 'on'
                                    ? {
                                        name: 'on',
                                        params: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, aoProps.params), { samples: 128, resolutionScale: c.webgl.pixelRatio })
                                    }
                                    : aoProps }),
                            marking: (0, tslib_1.__assign)({}, c.props.marking)
                        });
                        imageData = pass.getImageData(width, height, viewport);
                        canvas = document.createElement('canvas');
                        canvas.width = imageData.width;
                        canvas.height = imageData.height;
                        canvasCtx = canvas.getContext('2d');
                        if (!canvasCtx)
                            throw new Error('Could not create canvas 2d context');
                        canvasCtx.putImageData(imageData, 0, 0);
                        return [4 /*yield*/, (0, utils_1.canvasToBlob)(canvas, 'png')];
                    case 1:
                        blob = _e.sent();
                        (0, download_1.download)(blob, name);
                        return [2 /*return*/];
                }
            });
        });
    };
    return SnapshotManager;
}());
exports.SnapshotManager = SnapshotManager;
//# sourceMappingURL=snapshot.js.map