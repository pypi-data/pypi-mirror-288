"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uncompressElementIds = exports.compressElementIds = exports.isNonPolarHydrogen = exports.getWholeResiduesCellItem = exports.getGlobalCellItems = exports.getMergedContent = exports.getHydrogenType = exports.getStructureByCell = exports.getStructureUniqueId = exports.getModelByStructure = exports.queryCellItemsByHierarchyType = exports.sliceCellItemsByGranularity = exports.traverseAtoms = exports.getAtomHierarchyByStructure = exports.getAtomHierarchyByUnit = exports.getElementsFromStructure = exports.getStructureByStructureQuery = exports.getStructureQuery = exports.generateStructureByEditFuncAndStructure = exports.getTextFromStructure = exports.getProteinAndOthersElementIdByStructure = exports.getMergedStructure = exports.copyStructure = exports.getStructureByElementIds = exports.getElementIdsFromRepresentation = exports.getStructureFromRepresentation = exports.removeStructureByElementIds = exports.createEmptyStructure = void 0;
var tslib_1 = require("tslib");
var structure_1 = require("../../mol-model/structure");
var types_1 = require("../types");
var loci_1 = require("../../mol-model/structure/structure/element/loci");
var loci_2 = require("./loci");
var partial_charge_1 = require("../../mol-model-formats/structure/property/partial-charge");
var string_1 = require("./string");
var hierarchy_1 = require("./hierarchy");
var model_1 = require("../model");
var writer_1 = require("./writer");
var compiler_1 = require("../../mol-script/runtime/query/compiler");
var mol_util_1 = require("../../mol-util");
var types_2 = require("../../mol-model/structure/model/types");
var ions_1 = require("../../mol-model/structure/model/types/ions");
var script_1 = require("../../mol-script/script");
var builder_1 = require("../../mol-script/language/builder");
var int_1 = require("../../mol-data/int");
var functional_group_1 = require("../../mol-model-props/computed/chemistry/functional-group");
var util_1 = require("../../mol-model-props/computed/chemistry/util");
var state_1 = require("./state");
var createEmptyStructure = function () {
    var builder = structure_1.Structure.Builder();
    return builder.getStructure();
};
exports.createEmptyStructure = createEmptyStructure;
var removeStructureByElementIds = function (structure, elementIds) {
    var builder = structure_1.Structure.Builder();
    var elementSet = new Set(elementIds);
    for (var _i = 0, _a = structure.units; _i < _a.length; _i++) {
        var unit = _a[_i];
        var elements = (0, tslib_1.__spreadArray)([], unit.elements, true).filter(function (item) { return !elementSet.has(item); });
        if (elements.length) {
            builder.addUnit(unit.kind, unit.model, unit.conformation.operator, elements, unit.traits);
        }
    }
    return builder.getStructure();
};
exports.removeStructureByElementIds = removeStructureByElementIds;
var getStructureFromRepresentation = function (representation) {
    var loci = representation.getLoci();
    if (loci.kind === 'structure-loci') {
        return loci.structure;
    }
    if (loci.kind === 'element-loci') {
        return loci_1.Loci.toStructure(loci);
    }
    return structure_1.Structure.Empty;
};
exports.getStructureFromRepresentation = getStructureFromRepresentation;
var getElementIdsFromRepresentation = function (representation) {
    var loci = representation.getLoci();
    if (loci.kind === 'structure-loci') {
        return (0, loci_2.getElementIdsByLoci)(structure_1.Structure.toStructureElementLoci(loci.structure));
    }
    if (loci.kind === 'element-loci') {
        return (0, loci_2.getElementIdsByLoci)(loci);
    }
    return [];
};
exports.getElementIdsFromRepresentation = getElementIdsFromRepresentation;
var getStructureByElementIds = function (structure, elementIds, copyWhenIdsIsEmpty, updateModelId) {
    if ((elementIds === null || elementIds === void 0 ? void 0 : elementIds.length) === 0 && !copyWhenIdsIsEmpty) {
        return structure_1.Structure.Empty;
    }
    var builder = structure_1.Structure.Builder();
    var elementSet = new Set(elementIds);
    var newModelId = typeof updateModelId === 'string' ? updateModelId : mol_util_1.UUID.create22();
    for (var _i = 0, _a = structure.units; _i < _a.length; _i++) {
        var unit = _a[_i];
        var elements = (elementIds === null || elementIds === void 0 ? void 0 : elementIds.length)
            ? (0, tslib_1.__spreadArray)([], unit.elements, true).filter(function (item) { return elementSet.has(item); })
            : unit.elements;
        if (elements.length) {
            builder.addUnit(unit.kind, updateModelId ? (0, tslib_1.__assign)((0, tslib_1.__assign)({}, unit.model), { id: newModelId }) : unit.model, unit.conformation.operator, elements, unit.traits);
        }
    }
    return builder.getStructure();
};
exports.getStructureByElementIds = getStructureByElementIds;
var copyStructure = function (structure) {
    return structure_1.Structure.create(structure.units);
};
exports.copyStructure = copyStructure;
var getMergedStructure = function (items, plugin) {
    var builder = structure_1.Structure.Builder();
    var unitsMap = new Map();
    var id = 0;
    var _loop_1 = function (i, l) {
        var _a = items[i], ref = _a.ref, elementIds = _a.elementIds;
        var s = (0, exports.getStructureByCell)(plugin.cells.get(ref));
        var elementSet = new Set(elementIds);
        unitsMap.set(i, []);
        for (var _i = 0, _b = s.units; _i < _b.length; _i++) {
            var unit = _b[_i];
            var elements = elementIds
                ? (0, tslib_1.__spreadArray)([], unit.elements, true).filter(function (item) { return elementSet.has(item); })
                : unit.elements;
            if (elements.length) {
                unitsMap.get(i).push(id);
                builder.addUnit(unit.kind, unit.model, unit.conformation.operator, elements, unit.traits, id);
                id++;
            }
        }
    };
    for (var i = 0, l = items.length; i < l; i++) {
        _loop_1(i, l);
    }
    return {
        unitsMap: unitsMap,
        structure: builder.getStructure()
    };
};
exports.getMergedStructure = getMergedStructure;
var getProteinAndOthersElementIdByStructure = function (structure) {
    if (structure.model.sourceData.kind === 'gro') {
        return {
            polymer: (0, exports.getElementsFromStructure)((0, exports.getStructureByStructureQuery)((0, exports.getStructureQuery)(structure, state_1.StructureSelectionQueries.polymer.expression))),
            other: (0, exports.getElementsFromStructure)((0, exports.getStructureByStructureQuery)((0, exports.getStructureQuery)(structure, builder_1.MolScriptBuilder.struct.modifier.exceptBy({
                0: script_1.Script.toExpression((0, script_1.Script)("(sel.atom.all)", 'mol-script')),
                by: state_1.StructureSelectionQueries.polymer.expression
            }))))
        };
    }
    var polymerElements = {};
    var otherElements = {};
    var polymerElementIdsSet = new Set();
    var polymerElementIds = [];
    var eutecticMoleculeAtomsMap = new Map();
    var bondMap = new Map();
    structure.units.forEach(function (unit) {
        var _a;
        unit.elements.forEach(function (element) {
            var data = (0, exports.getAtomHierarchyByUnit)(unit, element);
            if (data.groupPDB === 'ATOM' && !['UNK', 'MOL'].includes(data.residueName)) {
                (0, hierarchy_1.setHierarchyData)(polymerElements, data);
                polymerElementIdsSet.add(data.elementId);
                polymerElementIds.push(data.elementId);
                return;
            }
            if (data.groupPDB === 'HETATM' || ['UNK', 'MOL'].includes(data.residueName)) {
                var key = "".concat(data.chainId, "_").concat(data.residueId);
                eutecticMoleculeAtomsMap.set(key, eutecticMoleculeAtomsMap.has(key)
                    ? (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], eutecticMoleculeAtomsMap.get(key), true), [data], false) : [data]);
                return;
            }
            (0, hierarchy_1.setHierarchyData)(otherElements, data);
        });
        for (var i = 0, l = unit.bonds.a.length; i < l; i++) {
            var a = unit.elements[unit.bonds.a[i]];
            var b = unit.elements[unit.bonds.b[i]];
            if (!bondMap.has(a)) {
                bondMap.set(a, new Set([b]));
            }
            else {
                (_a = bondMap.get(a)) === null || _a === void 0 ? void 0 : _a.add(b);
            }
        }
    });
    eutecticMoleculeAtomsMap.forEach(function (val) {
        var isEutectic = false;
        var elementIds = new Set(val.map(function (item) { return item.elementId; }));
        elementIds.forEach(function (elementIdA) {
            if (bondMap.has(elementIdA)) {
                var connect = bondMap.get(elementIdA);
                connect === null || connect === void 0 ? void 0 : connect.forEach(function (elementIdB) {
                    if (polymerElementIdsSet.has(elementIdB)) {
                        isEutectic = true;
                    }
                });
            }
        });
        val.forEach(function (data) {
            if (isEutectic) {
                Object.assign(data, { isEutectic: true });
                polymerElementIds.push(data.elementId);
                polymerElementIdsSet.add(data.elementId);
            }
            else {
                (0, hierarchy_1.setHierarchyData)(otherElements, data);
            }
        });
    });
    var otherElementIds = [];
    Object.keys(otherElements).forEach(function (chainId) {
        Object.keys(otherElements[chainId]).forEach(function (residueId) {
            otherElementIds.push.apply(otherElementIds, otherElements[chainId][residueId].map(function (item) { return item.elementId; }));
        });
    });
    return {
        polymer: polymerElementIds,
        other: otherElementIds
    };
};
exports.getProteinAndOthersElementIdByStructure = getProteinAndOthersElementIdByStructure;
var getTextFromStructure = function (structure, format) {
    var _a;
    if (!structure.elementCount)
        return '';
    if (format === types_1.Format.Pdb) {
        return (0, writer_1.parseToPDB)(structure, undefined, true);
    }
    var model = (0, exports.getModelByStructure)(structure);
    var molecularName = (_a = model === null || model === void 0 ? void 0 : model.entryId) !== null && _a !== void 0 ? _a : '';
    if (format === types_1.Format.Sdf || format === types_1.Format.Mol) {
        return molecularName ? (0, tslib_1.__spreadArray)([molecularName], (0, writer_1.parseToSdf)(structure).split('\n').slice(1), true).join('\n') : (0, writer_1.parseToSdf)(structure);
    }
};
exports.getTextFromStructure = getTextFromStructure;
// TODO 出入参需要再明确下
var generateStructureByEditFuncAndStructure = function (structure, editMolFunc, editPDBFunc, forceKind) { return (0, tslib_1.__awaiter)(void 0, void 0, void 0, function () {
    var model, kind, structures, _a, _b, newContent, structures;
    var _c, _d, _e;
    return (0, tslib_1.__generator)(this, function (_f) {
        switch (_f.label) {
            case 0:
                model = ((_c = structure === null || structure === void 0 ? void 0 : structure.models) === null || _c === void 0 ? void 0 : _c.length)
                    ? structure.models[0]
                    : structure === null || structure === void 0 ? void 0 : structure.model;
                kind = (_e = forceKind !== null && forceKind !== void 0 ? forceKind : (model
                    ? model.sourceData.kind
                    : (_d = structure === null || structure === void 0 ? void 0 : structure.parent) === null || _d === void 0 ? void 0 : _d.model.sourceData.kind)) !== null && _e !== void 0 ? _e : 'sdf';
                if (!(kind === 'mmCIF')) return [3 /*break*/, 3];
                _b = (_a = model_1.FormatProvider[types_1.Format.Pdb]).parse;
                return [4 /*yield*/, (0, writer_1.parseToPDB)(structure, undefined, true, editPDBFunc)];
            case 1: return [4 /*yield*/, _b.apply(_a, [_f.sent()])];
            case 2:
                structures = (_f.sent());
                return [2 /*return*/, structures];
            case 3: return [4 /*yield*/, (0, writer_1.parseToSdf)(structure, undefined, false, editMolFunc)];
            case 4:
                newContent = _f.sent();
                return [4 /*yield*/, model_1.FormatProvider[types_1.Format.Sdf].parse(newContent)];
            case 5:
                structures = (_f.sent());
                return [2 /*return*/, structures];
        }
    });
}); };
exports.generateStructureByEditFuncAndStructure = generateStructureByEditFuncAndStructure;
var getStructureQuery = function (structure, expression) {
    var compiled = (0, compiler_1.compile)(expression);
    var res = compiled(new structure_1.QueryContext(structure));
    return res;
};
exports.getStructureQuery = getStructureQuery;
var getStructureByStructureQuery = function (structureQuery) {
    var structure;
    if (structureQuery.structure) {
        structure = structureQuery.structure;
    }
    else if (structureQuery.structures) {
        var locis = structureQuery.structures
            .map(function (item) {
            return (item === null || item === void 0 ? void 0 : item.units.length) > 0
                ? structure_1.Structure.toStructureElementLoci(item)
                : undefined;
        })
            .filter(function (item) { return item; });
        if (locis.length === 0) {
            return (0, exports.createEmptyStructure)();
        }
        var loci = locis[0];
        for (var i = 1; i < locis.length; i++) {
            loci = loci_1.Loci.union(loci, locis[i]);
        }
        structure = loci_1.Loci.toStructure(loci);
    }
    return structure;
};
exports.getStructureByStructureQuery = getStructureByStructureQuery;
var getElementsFromStructure = function (structure) {
    var res = [];
    structure.units.forEach(function (unit) {
        res.push.apply(res, unit.elements);
    });
    return res;
};
exports.getElementsFromStructure = getElementsFromStructure;
var getAtomHierarchyByUnit = function (unit, elementId) {
    var _a;
    var data = {
        unitId: unit.invariantId,
        elementId: elementId,
        chainId: unit.model.atomicHierarchy.chains.auth_asym_id.value(unit.chainIndex[elementId]),
        groupPDB: unit.model.atomicHierarchy.residues.group_PDB.value(unit.residueIndex[elementId]),
        residueId: unit.model.atomicHierarchy.residues.auth_seq_id.value(unit.residueIndex[elementId]),
        insertCode: unit.model.atomicHierarchy.residues.pdbx_PDB_ins_code.value(unit.residueIndex[elementId]),
        residueName: unit.model.atomicHierarchy.atoms.label_comp_id.value(elementId),
        atomId: unit.model.atomicConformation.atomId.value(elementId),
        atomName: unit.model.atomicHierarchy.atoms.label_atom_id.value(elementId),
        typeSymbol: (0, string_1.getStandardTypeSymbol)(unit.model.atomicHierarchy.atoms.type_symbol.value(elementId)),
        charge: ((_a = partial_charge_1.AtomPartialCharge.Provider.get(unit.model)) === null || _a === void 0 ? void 0 : _a.data.value(elementId)) || 0,
        altId: unit.model.atomicHierarchy.atoms.label_alt_id.value(elementId),
        cdr: unit.model.atomicHierarchy.atoms.cdr.value(elementId) || 0,
        bfactor: unit.model.atomicHierarchy.atoms.B_iso_or_equiv.value(elementId),
        em_confidence: unit.model.atomicHierarchy.atoms.em_confidence.value(elementId),
        x: unit.model.atomicConformation.x[elementId],
        y: unit.model.atomicConformation.y[elementId],
        z: unit.model.atomicConformation.z[elementId],
        residueIndex: unit.residueIndex[elementId],
        occupancy: unit.model.atomicConformation.occupancy.value(elementId),
    };
    return data;
};
exports.getAtomHierarchyByUnit = getAtomHierarchyByUnit;
var getAtomHierarchyByStructure = function (structure, elementId, unitId) {
    var targetUnitId = unitId;
    if (unitId === undefined) {
        structure.units.some(function (unit) {
            if (unit.elements.includes(elementId)) {
                targetUnitId = unit.invariantId;
                return true;
            }
            return false;
        });
    }
    if (targetUnitId === undefined || !structure.unitMap.has(targetUnitId))
        return {};
    var unit = structure.unitMap.get(targetUnitId);
    var data = (0, exports.getAtomHierarchyByUnit)(unit, elementId);
    return data;
};
exports.getAtomHierarchyByStructure = getAtomHierarchyByStructure;
var traverseAtoms = function (structure, callback) {
    structure.units.forEach(function (unit) {
        unit.elements.forEach(function (element) {
            var data = (0, exports.getAtomHierarchyByUnit)(unit, element);
            callback(data);
        });
    });
};
exports.traverseAtoms = traverseAtoms;
var sliceCellItemsByGranularity = function (plugin, items, type) {
    var res = [];
    items.forEach(function (item) {
        var cell = plugin.managers.cell.get(item.ref);
        var structure = (0, exports.getStructureByCell)(cell);
        var itemsMap = new Map();
        var elementIdSet = new Set(item.elementIds);
        if (!structure) {
            return;
        }
        structure.units.forEach(function (unit) {
            unit.elements.forEach(function (element) {
                var _a;
                if (item.elementIds && !elementIdSet.has(element))
                    return;
                var data = (0, exports.getAtomHierarchyByUnit)(unit, element);
                var key = (0, hierarchy_1.getGranularityUniqueId)(data, type);
                if (itemsMap.has(key)) {
                    (_a = itemsMap.get(key)) === null || _a === void 0 ? void 0 : _a.push(data);
                }
                else {
                    itemsMap.set(key, [data]);
                }
            });
        });
        itemsMap.forEach(function (items) {
            res.push({
                ref: item.ref,
                elementIds: items.map(function (item) { return item.elementId; }),
                props: (0, hierarchy_1.getGranularityProps)(items[0], type)
            });
        });
    });
    return res;
};
exports.sliceCellItemsByGranularity = sliceCellItemsByGranularity;
var queryCellItemsByHierarchyType = function (plugin, cellItems) {
    var res = {};
    var refsSet = new Set();
    var items = cellItems !== null && cellItems !== void 0 ? cellItems : [];
    if (!cellItems) {
        plugin.managers.cell.traverse(function (cell, repr) {
            if ((0, exports.getStructureByCell)(cell) && !repr.isHidden) {
                refsSet.add(cell.ref);
            }
        });
    }
    refsSet.forEach(function (ref) {
        items.push({
            ref: ref
        });
    });
    items.forEach(function (item) {
        var _a;
        var ref = item.ref, elementIds = item.elementIds;
        var elementIdSet = new Set(elementIds);
        var cell = plugin.cells.get(ref);
        if (!cell)
            return;
        var structure = (0, exports.getStructureByCell)(cell);
        if (!structure)
            return;
        var solventElementIds = [];
        var waterElementIds = [];
        var otherElementIds = [];
        var polymerElementIds = new Set();
        var ligandElements = new Map();
        var otherElements = new Map();
        var eutecticMoleculeAtomsMap = new Map();
        var bondMap = new Map();
        structure.units.forEach(function (unit) {
            var _a;
            unit.elements.forEach(function (element) {
                var _a, _b;
                if (elementIds && !elementIdSet.has(element)) {
                    return;
                }
                var data = (0, exports.getAtomHierarchyByUnit)(unit, element);
                var key = (0, hierarchy_1.getGranularityUniqueId)(data, types_1.Granularity.Residue);
                if (hierarchy_1.SolventNameSet.has(data.residueName.toUpperCase())) {
                    solventElementIds.push(data.elementId);
                    return;
                }
                if (types_2.WaterNames.has(data.residueName.toUpperCase())) {
                    waterElementIds.push(data.elementId);
                    return;
                }
                if (hierarchy_1.MetalNameSet.has(data.typeSymbol.toUpperCase())) {
                    otherElementIds.push(data.elementId);
                    return;
                }
                if (ions_1.IonNames.has(data.residueName.toUpperCase())) {
                    otherElementIds.push(data.elementId);
                    return;
                }
                // residue name为UNK和MOL的固定分到ligand分组中
                if (data.groupPDB === 'ATOM' && !['UNK', 'MOL'].includes(data.residueName)) {
                    polymerElementIds.add(data.elementId);
                    return;
                }
                if (data.groupPDB === 'HETATM' || ['UNK', 'MOL'].includes(data.residueName)) {
                    if (eutecticMoleculeAtomsMap.has(key)) {
                        (_a = eutecticMoleculeAtomsMap.get(key)) === null || _a === void 0 ? void 0 : _a.push(data);
                    }
                    else {
                        eutecticMoleculeAtomsMap.set(key, [data]);
                    }
                    return;
                }
                if (otherElements.has(key)) {
                    (_b = otherElements.get(key)) === null || _b === void 0 ? void 0 : _b.push(data);
                }
                else {
                    otherElements.set(key, [data]);
                }
            });
            for (var i = 0, l = unit.bonds.a.length; i < l; i++) {
                var a = unit.elements[unit.bonds.a[i]];
                var b = unit.elements[unit.bonds.b[i]];
                if (!bondMap.has(a)) {
                    bondMap.set(a, new Set([b]));
                }
                else {
                    (_a = bondMap.get(a)) === null || _a === void 0 ? void 0 : _a.add(b);
                }
            }
        });
        eutecticMoleculeAtomsMap.forEach(function (val, key) {
            var isEutectic = false;
            var elementIds = new Set(val.map(function (item) { return item.elementId; }));
            elementIds.forEach(function (elementIdA) {
                if (bondMap.has(elementIdA)) {
                    var connect = bondMap.get(elementIdA);
                    connect === null || connect === void 0 ? void 0 : connect.forEach(function (elementIdB) {
                        if (polymerElementIds.has(elementIdB)) {
                            isEutectic = true;
                        }
                    });
                }
            });
            val.forEach(function (data) {
                var _a;
                if (isEutectic) {
                    polymerElementIds.add(data.elementId);
                }
                else {
                    if (otherElements.has(key)) {
                        (_a = otherElements.get(key)) === null || _a === void 0 ? void 0 : _a.push(data);
                    }
                    else {
                        otherElements.set(key, [data]);
                    }
                }
            });
        });
        otherElements.forEach(function (val, key) {
            var heavyAtoms = val.filter(function (item) { return item.typeSymbol !== 'H'; });
            if (heavyAtoms.length > 10 && heavyAtoms.length < 150) {
                ligandElements.set(key, val);
            }
            else {
                otherElementIds.push.apply(otherElementIds, val.map(function (item) { return item.elementId; }));
            }
        });
        res[ref] = (_a = {},
            _a[types_1.HierarchyType.Protein] = polymerElementIds.size
                ? [{ ref: ref, elementIds: Array.from(polymerElementIds.values()) }]
                : [],
            _a[types_1.HierarchyType.Ligand] = Array.from(ligandElements.entries()).map(function (_a) {
                var key = _a[0], residue = _a[1];
                return ({
                    ref: ref,
                    elementIds: residue.map(function (item) { return item.elementId; }),
                    name: key
                });
            }),
            _a[types_1.HierarchyType.Solvent] = solventElementIds.length
                ? [{ ref: ref, elementIds: solventElementIds }]
                : [],
            _a[types_1.HierarchyType.Water] = waterElementIds.length
                ? [{ ref: ref, elementIds: waterElementIds }]
                : [],
            _a[types_1.HierarchyType.Other] = otherElementIds.length
                ? [{ ref: ref, elementIds: otherElementIds }]
                : [],
            _a);
    });
    return res;
};
exports.queryCellItemsByHierarchyType = queryCellItemsByHierarchyType;
var getModelByStructure = function (structure) {
    var _a;
    return ((_a = structure.model) !== null && _a !== void 0 ? _a : structure.models[0]);
};
exports.getModelByStructure = getModelByStructure;
var getStructureUniqueId = function (structure) {
    var _a, _b;
    return (_b = ((_a = structure.model) !== null && _a !== void 0 ? _a : structure.models[0])) === null || _b === void 0 ? void 0 : _b.id;
};
exports.getStructureUniqueId = getStructureUniqueId;
var getStructureByCell = function (cell) {
    var _a, _b, _c, _d;
    return ((_a = cell === null || cell === void 0 ? void 0 : cell.model.structure) !== null && _a !== void 0 ? _a : (((_b = cell === null || cell === void 0 ? void 0 : cell.model) === null || _b === void 0 ? void 0 : _b.trajectory) ? structure_1.Structure.ofModel((_c = cell === null || cell === void 0 ? void 0 : cell.model.trajectory) === null || _c === void 0 ? void 0 : _c.state.getFrameAtIndex((_d = cell === null || cell === void 0 ? void 0 : cell.model.trajectory) === null || _d === void 0 ? void 0 : _d.frameIndex)) : undefined));
};
exports.getStructureByCell = getStructureByCell;
var getHydrogenType = function (structure, element) {
    var unit = structure.units.filter(function (item) {
        return int_1.SortedArray.has(item.elements, element);
    })[0];
    if (!unit || structure_1.Unit.isCoarse(unit))
        return types_1.HydrogenVariant.NotHydrogen;
    if (unit.model.atomicHierarchy.derived.atom.atomicNumber[element] !== 1) {
        var type_1 = types_1.HydrogenVariant.NotHydrogen;
        (0, util_1.eachBondedAtom)(structure, unit, unit.elements.indexOf(element), function (unit, index) {
            if (unit.model.atomicHierarchy.derived.atom.atomicNumber[unit.elements[index]] === 1) {
                switch ((0, exports.getHydrogenType)(structure, unit.elements[index])) {
                    case types_1.HydrogenVariant.Polar:
                        type_1 = types_1.HydrogenVariant.ConnectPolar;
                        break;
                    case types_1.HydrogenVariant.NonPolar:
                        type_1 = types_1.HydrogenVariant.ConnectNonPolar;
                        break;
                    default:
                }
            }
        });
        return type_1;
    }
    var polar = (0, functional_group_1.hasPolarNeighbour)(structure, unit, int_1.SortedArray.indexOf(unit.elements, element));
    if (polar)
        return types_1.HydrogenVariant.Polar;
    if (!polar)
        return types_1.HydrogenVariant.NonPolar;
    return types_1.HydrogenVariant.NotHydrogen;
};
exports.getHydrogenType = getHydrogenType;
var getMergedContent = function (plugin, items) { return (0, tslib_1.__awaiter)(void 0, void 0, void 0, function () {
    var structures;
    return (0, tslib_1.__generator)(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, Promise.all((items.filter(function (item) { return plugin.cells.has(item.ref); }).map(function (item) {
                    return plugin.managers.cell.getStructure(item.ref);
                })))];
            case 1:
                structures = _a.sent();
                return [2 /*return*/, (0, writer_1.getMergedStructureContent)(structures)];
        }
    });
}); };
exports.getMergedContent = getMergedContent;
var getGlobalCellItems = function (plugin) {
    return Array.from(plugin.cells.entries()).map(function (_a) {
        var ref = _a[0], cell = _a[1];
        var structure = (0, exports.getStructureByCell)(cell);
        if (!structure)
            return { ref: '' };
        if (cell.representations.size === 0 || Array.from(cell.representations.values()).filter(function (repr) { return !repr.isHidden; }).length === 0) {
            return { ref: '' };
        }
        return { ref: ref };
    }).filter(function (item) { return item.ref; });
};
exports.getGlobalCellItems = getGlobalCellItems;
var getWholeResiduesCellItem = function (plugin, items) {
    var res = [];
    items.forEach(function (_a) {
        var ref = _a.ref, elementIds = _a.elementIds;
        var currElementIds = [];
        if (!(elementIds === null || elementIds === void 0 ? void 0 : elementIds.length))
            return;
        var cell = plugin.managers.cell.get(ref);
        var structure = (0, exports.getStructureByCell)(cell);
        if (!structure) {
            return;
        }
        var residueKeys = new Set(elementIds.map(function (elementId) { return (0, hierarchy_1.getGranularityUniqueId)((0, exports.getAtomHierarchyByStructure)(structure, elementId), types_1.Granularity.Residue); }));
        structure.units.forEach(function (unit) {
            unit.elements.forEach(function (element) {
                var data = (0, exports.getAtomHierarchyByUnit)(unit, element);
                var key = (0, hierarchy_1.getGranularityUniqueId)(data, types_1.Granularity.Residue);
                if (residueKeys.has(key)) {
                    currElementIds.push(element);
                }
            });
        });
        if (!currElementIds.length)
            return;
        res.push({ ref: ref, elementIds: (0, tslib_1.__spreadArray)([], currElementIds, true) });
    });
    return res;
};
exports.getWholeResiduesCellItem = getWholeResiduesCellItem;
var isNonPolarHydrogen = function (structure, elementId) {
    var data = (0, exports.getAtomHierarchyByStructure)(structure, elementId);
    return data.typeSymbol === 'H' && (0, exports.getHydrogenType)(structure, elementId) === types_1.HydrogenVariant.NonPolar;
};
exports.isNonPolarHydrogen = isNonPolarHydrogen;
var compressElementIds = function (elementIds) {
    if (!elementIds)
        return elementIds;
    var res = [];
    var sorted = elementIds.sort(function (a, b) { return +a - +b; });
    var currArr = [];
    sorted.forEach(function (elementId, index) {
        if (currArr.length === 0) {
            currArr.push(elementId);
            return;
        }
        if (currArr.length === 1) {
            if (currArr[0] === elementId - 1) {
                currArr.push(elementId);
            }
            else {
                res.push(currArr[0], currArr[0]);
                currArr = [elementId];
            }
            return;
        }
        if (currArr.length === 2) {
            if (currArr[1] === elementId - 1) {
                currArr[1] = elementId;
            }
            else {
                res.push.apply(res, currArr);
                currArr = [elementId];
            }
        }
    });
    if (currArr.length) {
        res.push.apply(res, (currArr.length === 2 ? currArr : [currArr[0], currArr[0]]));
    }
    return res;
};
exports.compressElementIds = compressElementIds;
var uncompressElementIds = function (elementIds) {
    var res = [];
    for (var i = 0, l = elementIds.length; i < l; i += 2) {
        for (var j = elementIds[i]; j <= elementIds[i + 1]; j++) {
            res.push(j);
        }
    }
    return res;
};
exports.uncompressElementIds = uncompressElementIds;
//# sourceMappingURL=structure.js.map