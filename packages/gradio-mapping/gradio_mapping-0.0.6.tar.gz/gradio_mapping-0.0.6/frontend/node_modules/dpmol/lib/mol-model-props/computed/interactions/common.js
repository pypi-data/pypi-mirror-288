"use strict";
/**
 * Copyright (c) 2019-2022 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.featureGroupLabel = exports.featureTypeLabel = exports.interactionTypeLabel = exports.InteractionType = exports.InteractionFlag = exports.InteractionsInterContacts = exports.InteractionsIntraContacts = void 0;
var tslib_1 = require("tslib");
var inter_unit_graph_1 = require("../../../mol-math/graph/inter-unit-graph");
var InteractionsIntraContacts;
(function (InteractionsIntraContacts) {
    /**
     * Note: assumes that feature members of a contact are non-overlapping
     */
    function createElementsIndex(contacts, features, elementsCount) {
        var offsets = new Int32Array(elementsCount + 1);
        var bucketFill = new Int32Array(elementsCount);
        var bucketSizes = new Int32Array(elementsCount);
        var members = features.members, featureOffsets = features.offsets;
        for (var i = 0, il = contacts.edgeCount * 2; i < il; ++i) {
            var aI = contacts.a[i];
            var bI = contacts.b[i];
            if (aI > bI)
                continue;
            for (var j = featureOffsets[aI], jl = featureOffsets[aI + 1]; j < jl; ++j) {
                ++bucketSizes[members[j]];
            }
            for (var j = featureOffsets[bI], jl = featureOffsets[bI + 1]; j < jl; ++j) {
                ++bucketSizes[members[j]];
            }
        }
        var offset = 0;
        for (var i = 0; i < elementsCount; i++) {
            offsets[i] = offset;
            offset += bucketSizes[i];
        }
        offsets[elementsCount] = offset;
        var indices = new Int32Array(offset);
        for (var i = 0, il = contacts.edgeCount * 2; i < il; ++i) {
            var aI = contacts.a[i];
            var bI = contacts.b[i];
            if (aI > bI)
                continue;
            for (var j = featureOffsets[aI], jl = featureOffsets[aI + 1]; j < jl; ++j) {
                var m = members[j];
                var om = offsets[m] + bucketFill[m];
                indices[om] = i;
                ++bucketFill[m];
            }
            for (var j = featureOffsets[bI], jl = featureOffsets[bI + 1]; j < jl; ++j) {
                var m = members[j];
                var om = offsets[m] + bucketFill[m];
                indices[om] = i;
                ++bucketFill[m];
            }
        }
        return { indices: indices, offsets: offsets };
    }
    InteractionsIntraContacts.createElementsIndex = createElementsIndex;
})(InteractionsIntraContacts || (InteractionsIntraContacts = {}));
exports.InteractionsIntraContacts = InteractionsIntraContacts;
var InteractionsInterContacts = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(InteractionsInterContacts, _super);
    function InteractionsInterContacts(map, unitsFeatures) {
        var _this = _super.call(this, map) || this;
        _this.elementKeyIndex = new Map();
        for (var i = 0, il = _this.edges.length; i < il; ++i) {
            var _a = _this.edges[i], unitA = _a.unitA, indexA = _a.indexA;
            var _b = unitsFeatures.get(unitA), offsets = _b.offsets, members = _b.members;
            for (var j = offsets[indexA], jl = offsets[indexA + 1]; j < jl; ++j) {
                var vertexKey = _this.getElementKey(members[j], unitA);
                var e = _this.elementKeyIndex.get(vertexKey);
                if (e === undefined) {
                    _this.elementKeyIndex.set(vertexKey, [i]);
                }
                else {
                    e.push(i);
                }
            }
        }
        return _this;
    }
    InteractionsInterContacts.prototype.getContactIndicesForElement = function (index, unit) {
        return this.elementKeyIndex.get(this.getElementKey(index, unit.id)) || [];
    };
    InteractionsInterContacts.prototype.getElementKey = function (index, unitId) {
        return "".concat(index, "|").concat(unitId);
    };
    return InteractionsInterContacts;
}(inter_unit_graph_1.InterUnitGraph));
exports.InteractionsInterContacts = InteractionsInterContacts;
var InteractionFlag;
(function (InteractionFlag) {
    InteractionFlag[InteractionFlag["None"] = 0] = "None";
    InteractionFlag[InteractionFlag["Filtered"] = 1] = "Filtered";
})(InteractionFlag = exports.InteractionFlag || (exports.InteractionFlag = {}));
var InteractionType;
(function (InteractionType) {
    InteractionType[InteractionType["Unknown"] = 0] = "Unknown";
    InteractionType[InteractionType["Ionic"] = 1] = "Ionic";
    InteractionType[InteractionType["CationPi"] = 2] = "CationPi";
    InteractionType[InteractionType["PiStacking"] = 3] = "PiStacking";
    InteractionType[InteractionType["HydrogenBond"] = 4] = "HydrogenBond";
    InteractionType[InteractionType["HalogenBond"] = 5] = "HalogenBond";
    InteractionType[InteractionType["Hydrophobic"] = 6] = "Hydrophobic";
    InteractionType[InteractionType["MetalCoordination"] = 7] = "MetalCoordination";
    InteractionType[InteractionType["WeakHydrogenBond"] = 8] = "WeakHydrogenBond";
})(InteractionType = exports.InteractionType || (exports.InteractionType = {}));
function interactionTypeLabel(type) {
    switch (type) {
        case InteractionType.HydrogenBond:
            return 'Hydrogen Bond';
        case InteractionType.Hydrophobic:
            return 'Hydrophobic Contact';
        case InteractionType.HalogenBond:
            return 'Halogen Bond';
        case InteractionType.Ionic:
            return 'Salt Bridge';
        case InteractionType.MetalCoordination:
            return 'Metal Bond';
        case InteractionType.CationPi:
            return 'Cation-Pi Interaction';
        case InteractionType.PiStacking:
            return 'Pi Stacking';
        case InteractionType.WeakHydrogenBond:
            return 'Weak Hydrogen Bond';
        case InteractionType.Unknown:
            return 'Unknown Interaction';
    }
}
exports.interactionTypeLabel = interactionTypeLabel;
function featureTypeLabel(type) {
    switch (type) {
        case 0 /* None */:
            return 'None';
        case 1 /* PositiveCharge */:
            return 'Positive Charge';
        case 2 /* NegativeCharge */:
            return 'Negative Charge';
        case 3 /* AromaticRing */:
            return 'Aromatic Ring';
        case 4 /* HydrogenDonor */:
            return 'Hydrogen Donor';
        case 5 /* HydrogenAcceptor */:
            return 'Hydrogen Acceptor';
        case 6 /* HalogenDonor */:
            return 'Halogen Donor';
        case 7 /* HalogenAcceptor */:
            return 'Halogen Acceptor';
        case 8 /* HydrophobicAtom */:
            return 'HydrophobicAtom';
        case 9 /* WeakHydrogenDonor */:
            return 'Weak Hydrogen Donor';
        case 10 /* IonicTypePartner */:
            return 'Ionic Type Partner';
        case 11 /* DativeBondPartner */:
            return 'Dative Bond Partner';
        case 12 /* TransitionMetal */:
            return 'Transition Metal';
        case 13 /* IonicTypeMetal */:
            return 'Ionic Type Metal';
    }
}
exports.featureTypeLabel = featureTypeLabel;
function featureGroupLabel(group) {
    switch (group) {
        case 0 /* None */:
            return 'None';
        case 1 /* QuaternaryAmine */:
            return 'Quaternary Amine';
        case 2 /* TertiaryAmine */:
            return 'Tertiary Amine';
        case 3 /* Sulfonium */:
            return 'Sulfonium';
        case 4 /* SulfonicAcid */:
            return 'Sulfonic Acid';
        case 5 /* Sulfate */:
            return 'Sulfate';
        case 6 /* Phosphate */:
            return 'Phosphate';
        case 7 /* Halocarbon */:
            return 'Halocarbon';
        case 8 /* Guanidine */:
            return 'Guanidine';
        case 9 /* Acetamidine */:
            return 'Acetamidine';
        case 10 /* Carboxylate */:
            return 'Carboxylate';
    }
}
exports.featureGroupLabel = featureGroupLabel;
//# sourceMappingURL=common.js.map