"use strict";
/**
 * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructureComplexElementTypes = exports.CustomStructureProperties = exports.CustomModelProperties = exports.StructureComponent = exports.StructureComplexElement = exports.StructureSelectionFromBundle = exports.StructureSelectionFromScript = exports.MultiStructureSelectionFromExpression = exports.StructureSelectionFromExpression = exports.TransformStructureConformation = exports.StructureFromModel = exports.StructureFromTrajectory = exports.ModelFromTrajectory = exports.TrajectoryFromMOL2 = exports.TrajectoryFromSDF = exports.TrajectoryFromMOL = exports.TrajectoryFromGRO = exports.TrajectoryFromPDB = exports.TrajectoryFromMmCif = exports.TrajectoryFromBlob = exports.TrajectoryFromModelAndCoordinates = exports.CoordinatesFromXtc = void 0;
var tslib_1 = require("tslib");
// import { parseDcd } from '../../mol-io/reader/dcd/parser';
var parser_1 = require("../../mol-io/reader/gro/parser");
var parser_2 = require("../../mol-io/reader/pdb/parser");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
// import { shapeFromPly } from '../../mol-model-formats/shape/ply';
// import { coordinatesFromDcd } from '../../mol-model-formats/structure/dcd';
var gro_1 = require("../../mol-model-formats/structure/gro");
var mmcif_1 = require("../../mol-model-formats/structure/mmcif");
var pdb_1 = require("../../mol-model-formats/structure/pdb");
// import { topologyFromPsf } from '../../mol-model-formats/structure/psf';
var structure_1 = require("../../mol-model/structure");
var builder_1 = require("../../mol-script/language/builder");
var script_1 = require("../../mol-script/script");
var mol_state_1 = require("../../mol-state");
var mol_task_1 = require("../../mol-task");
var mol_util_1 = require("../../mol-util");
var param_definition_1 = require("../../mol-util/param-definition");
var root_structure_1 = require("../helpers/root-structure");
var structure_component_1 = require("../helpers/structure-component");
var structure_query_1 = require("../helpers/structure-query");
var structure_selection_query_1 = require("../helpers/structure-selection-query");
var objects_1 = require("../objects");
var parser_3 = require("../../mol-io/reader/mol/parser");
var mol_1 = require("../../mol-model-formats/structure/mol");
// import { trajectoryFromCifCore } from '../../mol-model-formats/structure/cif-core';
// import { trajectoryFromCube } from '../../mol-model-formats/structure/cube';
var parser_4 = require("../../mol-io/reader/mol2/parser");
var mol2_1 = require("../../mol-model-formats/structure/mol2");
var parser_5 = require("../../mol-io/reader/xtc/parser");
var xtc_1 = require("../../mol-model-formats/structure/xtc");
// import { parseXyz } from '../../mol-io/reader/xyz/parser';
// import { trajectoryFromXyz } from '../../mol-model-formats/structure/xyz';
var parser_6 = require("../../mol-io/reader/sdf/parser");
var sdf_1 = require("../../mol-model-formats/structure/sdf");
var CoordinatesFromXtc = objects_1.PluginStateTransform.BuiltIn({
    name: 'coordinates-from-xtc',
    display: { name: 'Parse XTC', description: 'Parse XTC binary data.' },
    from: [objects_1.PluginStateObject.Data.Binary],
    to: objects_1.PluginStateObject.Molecule.Coordinates
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse XTC', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var parsed, coordinates;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, parser_5.parseXtc)(a.data).runInContext(ctx)];
                    case 1:
                        parsed = _a.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        return [4 /*yield*/, (0, xtc_1.coordinatesFromXtc)(parsed.result).runInContext(ctx)];
                    case 2:
                        coordinates = _a.sent();
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Coordinates(coordinates, { label: a.label, description: 'Coordinates' })];
                }
            });
        }); });
    }
});
exports.CoordinatesFromXtc = CoordinatesFromXtc;
// type TopologyFromPsf = typeof TopologyFromPsf
// const TopologyFromPsf = PluginStateTransform.BuiltIn({
//     name: 'topology-from-psf',
//     display: { name: 'PSF Topology', description: 'Parse PSF string data.' },
//     from: [SO.Format.Psf],
//     to: SO.Molecule.Topology
// })({
//     apply({ a }) {
//         return Task.create('Create Topology', async ctx => {
//             const topology = await topologyFromPsf(a.data).runInContext(ctx);
//             return new SO.Molecule.Topology(topology, { label: topology.label || a.label, description: 'Topology' });
//         });
//     }
// });
function getTrajectory(ctx, obj, coordinates) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var topology, model;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(obj.type === objects_1.PluginStateObject.Molecule.Topology.type)) return [3 /*break*/, 2];
                    topology = obj.data;
                    return [4 /*yield*/, structure_1.Model.trajectoryFromTopologyAndCoordinates(topology, coordinates).runInContext(ctx)];
                case 1: return [2 /*return*/, _a.sent()];
                case 2:
                    if (obj.type === objects_1.PluginStateObject.Molecule.Model.type) {
                        model = obj.data;
                        return [2 /*return*/, structure_1.Model.trajectoryFromModelAndCoordinates(model, coordinates)];
                    }
                    _a.label = 3;
                case 3: throw new Error('no model/topology found');
            }
        });
    });
}
var TrajectoryFromModelAndCoordinates = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-model-and-coordinates',
    display: {
        name: 'Trajectory from Topology & Coordinates',
        description: 'Create a trajectory from existing model/topology and coordinates.'
    },
    from: objects_1.PluginStateObject.Root,
    to: objects_1.PluginStateObject.Molecule.Trajectory,
    params: {
        modelRef: param_definition_1.ParamDefinition.Text('', { isHidden: true }),
        coordinatesRef: param_definition_1.ParamDefinition.Text('', { isHidden: true })
    }
})({
    apply: function (_a) {
        var _this = this;
        var params = _a.params, dependencies = _a.dependencies;
        return mol_task_1.Task.create('Create trajectory from model/topology and coordinates', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var coordinates, trajectory, props;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        coordinates = dependencies[params.coordinatesRef]
                            .data;
                        return [4 /*yield*/, getTrajectory(ctx, dependencies[params.modelRef], coordinates)];
                    case 1:
                        trajectory = _a.sent();
                        props = {
                            label: 'Trajectory',
                            description: "".concat(trajectory.frameCount, " model").concat(trajectory.frameCount === 1 ? '' : 's')
                        };
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(trajectory, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromModelAndCoordinates = TrajectoryFromModelAndCoordinates;
var TrajectoryFromBlob = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-blob',
    display: {
        name: 'Parse Blob',
        description: 'Parse format blob into a single trajectory.'
    },
    from: objects_1.PluginStateObject.Format.Blob,
    to: objects_1.PluginStateObject.Molecule.Trajectory
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse Format Blob', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var models, _i, _a, e, block, xs, i, x, i, props;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        models = [];
                        _i = 0, _a = a.data;
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 7];
                        e = _a[_i];
                        if (e.kind !== 'cif')
                            return [3 /*break*/, 6];
                        block = e.data.blocks[0];
                        return [4 /*yield*/, (0, mmcif_1.trajectoryFromMmCIF)(block).runInContext(ctx)];
                    case 2:
                        xs = _b.sent();
                        if (xs.frameCount === 0)
                            throw new Error('No models found.');
                        i = 0;
                        _b.label = 3;
                    case 3:
                        if (!(i < xs.frameCount)) return [3 /*break*/, 6];
                        return [4 /*yield*/, mol_task_1.Task.resolveInContext(xs.getFrameAtIndex(i), ctx)];
                    case 4:
                        x = _b.sent();
                        models.push(x);
                        _b.label = 5;
                    case 5:
                        i++;
                        return [3 /*break*/, 3];
                    case 6:
                        _i++;
                        return [3 /*break*/, 1];
                    case 7:
                        for (i = 0; i < models.length; i++) {
                            structure_1.Model.TrajectoryInfo.set(models[i], { index: i, size: models.length });
                        }
                        props = {
                            label: 'Trajectory',
                            description: "".concat(models.length, " model").concat(models.length === 1 ? '' : 's')
                        };
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(new structure_1.ArrayTrajectory(models), props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromBlob = TrajectoryFromBlob;
function trajectoryProps(trajectory) {
    var first = trajectory.representative;
    return {
        label: "".concat(first.entry),
        description: "".concat(trajectory.frameCount, " model").concat(trajectory.frameCount === 1 ? '' : 's')
    };
}
var TrajectoryFromMmCif = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-mmcif',
    display: {
        name: 'Trajectory from mmCIF',
        description: 'Identify and create all separate models in the specified CIF data block'
    },
    from: objects_1.PluginStateObject.Format.Cif,
    to: objects_1.PluginStateObject.Molecule.Trajectory,
    params: function (a) {
        if (!a) {
            return {
                blockHeader: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Text(void 0, {
                    description: 'Header of the block to parse. If none is specifed, the 1st data block in the file is used.'
                }))
            };
        }
        var blocks = a.data.blocks;
        return {
            blockHeader: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Select(blocks[0] && blocks[0].header, blocks.map(function (b) { return [b.header, b.header]; }), { description: 'Header of the block to parse' }))
        };
    }
})({
    isApplicable: function (a) { return a.data.blocks.length > 0; },
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Parse mmCIF', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var header, block, models, props;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        header = params.blockHeader || a.data.blocks[0].header;
                        block = a.data.blocks.find(function (b) { return b.header === header; });
                        if (!block)
                            throw new Error("Data block '".concat([header], "' not found."));
                        return [4 /*yield*/, (0, mmcif_1.trajectoryFromMmCIF)(block).runInContext(ctx)];
                    case 1:
                        models = _a.sent();
                        if (models.frameCount === 0)
                            throw new Error('No models found.');
                        props = trajectoryProps(models);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(models, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromMmCif = TrajectoryFromMmCif;
var TrajectoryFromPDB = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-pdb',
    display: {
        name: 'Parse PDB',
        description: 'Parse PDB string and create trajectory.'
    },
    from: [objects_1.PluginStateObject.Data.String],
    to: objects_1.PluginStateObject.Molecule.Trajectory,
    params: {
        isPdbqt: param_definition_1.ParamDefinition.Boolean(false)
    }
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Parse PDB', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var parsed, models, props;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, parser_2.parsePDB)(a.data, a.label, params.isPdbqt).runInContext(ctx)];
                    case 1:
                        parsed = _a.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        return [4 /*yield*/, (0, pdb_1.trajectoryFromPDB)(parsed.result).runInContext(ctx)];
                    case 2:
                        models = _a.sent();
                        props = trajectoryProps(models);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(models, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromPDB = TrajectoryFromPDB;
var TrajectoryFromGRO = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-gro',
    display: { name: 'Parse GRO', description: 'Parse GRO string and create trajectory.' },
    from: [objects_1.PluginStateObject.Data.String],
    to: objects_1.PluginStateObject.Molecule.Trajectory
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse GRO', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var parsed, models, props;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, parser_1.parseGRO)(a.data).runInContext(ctx)];
                    case 1:
                        parsed = _a.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        return [4 /*yield*/, (0, gro_1.trajectoryFromGRO)(parsed.result).runInContext(ctx)];
                    case 2:
                        models = _a.sent();
                        props = trajectoryProps(models);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(models, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromGRO = TrajectoryFromGRO;
var TrajectoryFromMOL = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-mol',
    display: {
        name: 'Parse MOL',
        description: 'Parse MOL string and create trajectory.'
    },
    from: [objects_1.PluginStateObject.Data.String],
    to: objects_1.PluginStateObject.Molecule.Trajectory
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse MOL', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var parsed, models, props;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, parser_3.parseMol)(a.data).runInContext(ctx)];
                    case 1:
                        parsed = _a.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        return [4 /*yield*/, (0, mol_1.trajectoryFromMol)(parsed.result).runInContext(ctx)];
                    case 2:
                        models = _a.sent();
                        props = trajectoryProps(models);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(models, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromMOL = TrajectoryFromMOL;
var TrajectoryFromSDF = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-sdf',
    display: {
        name: 'Parse SDF',
        description: 'Parse SDF string and create trajectory.'
    },
    from: [objects_1.PluginStateObject.Data.String],
    to: objects_1.PluginStateObject.Molecule.Trajectory
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse SDF', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var parsed, models, _i, _a, compound, traj_1, i, _b, _c, traj, props;
            return (0, tslib_1.__generator)(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, (0, parser_6.parseSdf)(a.data).runInContext(ctx)];
                    case 1:
                        parsed = _d.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        models = [];
                        _i = 0, _a = parsed.result.compounds;
                        _d.label = 2;
                    case 2:
                        if (!(_i < _a.length)) return [3 /*break*/, 8];
                        compound = _a[_i];
                        return [4 /*yield*/, (0, sdf_1.trajectoryFromSdf)(compound).runInContext(ctx)];
                    case 3:
                        traj_1 = _d.sent();
                        i = 0;
                        _d.label = 4;
                    case 4:
                        if (!(i < traj_1.frameCount)) return [3 /*break*/, 7];
                        _c = (_b = models).push;
                        return [4 /*yield*/, mol_task_1.Task.resolveInContext(traj_1.getFrameAtIndex(i), ctx)];
                    case 5:
                        _c.apply(_b, [_d.sent()]);
                        _d.label = 6;
                    case 6:
                        i++;
                        return [3 /*break*/, 4];
                    case 7:
                        _i++;
                        return [3 /*break*/, 2];
                    case 8:
                        traj = new structure_1.ArrayTrajectory(models);
                        props = trajectoryProps(traj);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(traj, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromSDF = TrajectoryFromSDF;
var TrajectoryFromMOL2 = objects_1.PluginStateTransform.BuiltIn({
    name: 'trajectory-from-mol2',
    display: {
        name: 'Parse MOL2',
        description: 'Parse MOL2 string and create trajectory.'
    },
    from: [objects_1.PluginStateObject.Data.String],
    to: objects_1.PluginStateObject.Molecule.Trajectory
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse MOL2', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var parsed, models, props;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, parser_4.parseMol2)(a.data, a.label).runInContext(ctx)];
                    case 1:
                        parsed = _a.sent();
                        if (parsed.isError)
                            throw new Error(parsed.message);
                        return [4 /*yield*/, (0, mol2_1.trajectoryFromMol2)(parsed.result).runInContext(ctx)];
                    case 2:
                        models = _a.sent();
                        props = trajectoryProps(models);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Trajectory(models, props)];
                }
            });
        }); });
    }
});
exports.TrajectoryFromMOL2 = TrajectoryFromMOL2;
// type TrajectoryFromCube = typeof TrajectoryFromCube
// const TrajectoryFromCube = PluginStateTransform.BuiltIn({
//     name: 'trajectory-from-cube',
//     display: { name: 'Parse Cube', description: 'Parse Cube file to create a trajectory.' },
//     from: SO.Format.Cube,
//     to: SO.Molecule.Trajectory
// })({
//     apply({ a }) {
//         return Task.create('Parse MOL', async ctx => {
//             const models = await trajectoryFromCube(a.data).runInContext(ctx);
//             const props = trajectoryProps(models);
//             return new SO.Molecule.Trajectory(models, props);
//         });
//     }
// });
// type TrajectoryFromCifCore = typeof TrajectoryFromCifCore
// const TrajectoryFromCifCore = PluginStateTransform.BuiltIn({
//     name: 'trajectory-from-cif-core',
//     display: { name: 'Parse CIF Core', description: 'Identify and create all separate models in the specified CIF data block' },
//     from: SO.Format.Cif,
//     to: SO.Molecule.Trajectory,
//     params(a) {
//         if (!a) {
//             return {
//                 blockHeader: PD.Optional(PD.Text(void 0, { description: 'Header of the block to parse. If none is specifed, the 1st data block in the file is used.' }))
//             };
//         }
//         const { blocks } = a.data;
//         return {
//             blockHeader: PD.Optional(PD.Select(blocks[0] && blocks[0].header, blocks.map(b => [b.header, b.header] as [string, string]), { description: 'Header of the block to parse' }))
//         };
//     }
// })({
//     apply({ a, params }) {
//         return Task.create('Parse CIF Core', async ctx => {
//             const header = params.blockHeader || a.data.blocks[0].header;
//             const block = a.data.blocks.find(b => b.header === header);
//             if (!block) throw new Error(`Data block '${[header]}' not found.`);
//             const models = await trajectoryFromCifCore(block).runInContext(ctx);
//             if (models.frameCount === 0) throw new Error('No models found.');
//             const props = trajectoryProps(models);
//             return new SO.Molecule.Trajectory(models, props);
//         });
//     }
// });
var plus1 = function (v) { return v + 1; }, minus1 = function (v) { return v - 1; };
var ModelFromTrajectory = objects_1.PluginStateTransform.BuiltIn({
    name: 'model-from-trajectory',
    display: {
        name: 'Molecular Model',
        description: 'Create a molecular model from specified index in a trajectory.'
    },
    from: objects_1.PluginStateObject.Molecule.Trajectory,
    to: objects_1.PluginStateObject.Molecule.Model,
    params: function (a) {
        if (!a) {
            return {
                modelIndex: param_definition_1.ParamDefinition.Numeric(0, {}, {
                    description: 'Zero-based index of the model',
                    immediateUpdate: true
                })
            };
        }
        return {
            modelIndex: param_definition_1.ParamDefinition.Converted(plus1, minus1, param_definition_1.ParamDefinition.Numeric(1, { min: 1, max: a.data.frameCount, step: 1 }, { description: 'Model Index', immediateUpdate: true }))
        };
    }
})({
    isApplicable: function (a) { return a.data.frameCount > 0; },
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Model from Trajectory', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var modelIndex, model, label, description;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        modelIndex = params.modelIndex % a.data.frameCount;
                        if (modelIndex < 0)
                            modelIndex += a.data.frameCount;
                        return [4 /*yield*/, mol_task_1.Task.resolveInContext(a.data.getFrameAtIndex(modelIndex), ctx)];
                    case 1:
                        model = _a.sent();
                        label = "Model ".concat(modelIndex + 1);
                        description = a.data.frameCount === 1 ? undefined : "of ".concat(a.data.frameCount);
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Model(model, { label: label, description: description })];
                }
            });
        }); });
    },
    interpolate: function (a, b, t) {
        var modelIndex = t >= 1
            ? b.modelIndex
            : a.modelIndex + Math.floor((b.modelIndex - a.modelIndex + 1) * t);
        return { modelIndex: modelIndex };
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customProperties.dispose();
    }
});
exports.ModelFromTrajectory = ModelFromTrajectory;
var StructureFromTrajectory = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-from-trajectory',
    display: {
        name: 'Structure from Trajectory',
        description: 'Create a molecular structure from a trajectory.'
    },
    from: objects_1.PluginStateObject.Molecule.Trajectory,
    to: objects_1.PluginStateObject.Molecule.Structure
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Build Structure', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var s, props;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, structure_1.Structure.ofTrajectory(a.data, ctx)];
                    case 1:
                        s = _a.sent();
                        props = {
                            label: 'Ensemble',
                            description: structure_1.Structure.elementDescription(s)
                        };
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Structure(s, props)];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.StructureFromTrajectory = StructureFromTrajectory;
var StructureFromModel = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-from-model',
    display: {
        name: 'Structure',
        description: 'Create a molecular structure (model, assembly, or symmetry) from the specified model.'
    },
    from: objects_1.PluginStateObject.Molecule.Model,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: function (a) {
        return root_structure_1.RootStructureDefinition.getParams(a && a.data);
    }
})({
    canAutoUpdate: function (_a) {
        var oldParams = _a.oldParams, newParams = _a.newParams;
        return root_structure_1.RootStructureDefinition.canAutoUpdate(oldParams.type, newParams.type);
    },
    apply: function (_a, plugin) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Build Structure', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                return [2 /*return*/, root_structure_1.RootStructureDefinition.create(plugin, ctx, a.data, params && params.type)];
            });
        }); });
    },
    update: function (_a) {
        var a = _a.a, b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams;
        if (!(0, mol_util_1.deepEqual)(oldParams, newParams))
            return mol_state_1.StateTransformer.UpdateResult.Recreate;
        if (b.data.model === a.data)
            return mol_state_1.StateTransformer.UpdateResult.Unchanged;
        if (!structure_1.Model.areHierarchiesEqual(a.data, b.data.model))
            return mol_state_1.StateTransformer.UpdateResult.Recreate;
        b.data = b.data.remapModel(a.data);
        return mol_state_1.StateTransformer.UpdateResult.Updated;
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.StructureFromModel = StructureFromModel;
var _translation = (0, linear_algebra_1.Vec3)(), _m = (0, linear_algebra_1.Mat4)(), _n = (0, linear_algebra_1.Mat4)();
var TransformStructureConformation = objects_1.PluginStateTransform.BuiltIn({
    name: 'transform-structure-conformation',
    display: { name: 'Transform Conformation' },
    isDecorator: true,
    from: objects_1.PluginStateObject.Molecule.Structure,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: {
        transform: param_definition_1.ParamDefinition.MappedStatic('components', {
            components: param_definition_1.ParamDefinition.Group({
                axis: param_definition_1.ParamDefinition.Vec3(linear_algebra_1.Vec3.create(1, 0, 0)),
                angle: param_definition_1.ParamDefinition.Numeric(0, { min: -180, max: 180, step: 0.1 }),
                translation: param_definition_1.ParamDefinition.Vec3(linear_algebra_1.Vec3.create(0, 0, 0))
            }, { isFlat: true }),
            matrix: param_definition_1.ParamDefinition.Group({
                data: param_definition_1.ParamDefinition.Mat4(linear_algebra_1.Mat4.identity()),
                transpose: param_definition_1.ParamDefinition.Boolean(false)
            }, { isFlat: true })
        }, { label: 'Kind' })
    }
})({
    canAutoUpdate: function (_a) {
        var newParams = _a.newParams;
        return newParams.transform.name !== 'matrix';
    },
    apply: function (_a) {
        // TODO: optimze
        // TODO: think of ways how to fast-track changes to this for animations
        var a = _a.a, params = _a.params;
        var transform = (0, linear_algebra_1.Mat4)();
        if (params.transform.name === 'components') {
            var _b = params.transform.params, axis = _b.axis, angle = _b.angle, translation = _b.translation;
            var center = a.data.boundary.sphere.center;
            linear_algebra_1.Mat4.fromTranslation(_m, linear_algebra_1.Vec3.negate(_translation, center));
            linear_algebra_1.Mat4.fromTranslation(_n, linear_algebra_1.Vec3.add(_translation, center, translation));
            var rot = linear_algebra_1.Mat4.fromRotation((0, linear_algebra_1.Mat4)(), (Math.PI / 180) * angle, linear_algebra_1.Vec3.normalize((0, linear_algebra_1.Vec3)(), axis));
            linear_algebra_1.Mat4.mul3(transform, _n, rot, _m);
        }
        else if (params.transform.name === 'matrix') {
            linear_algebra_1.Mat4.copy(transform, params.transform.params.data);
            if (params.transform.params.transpose)
                linear_algebra_1.Mat4.transpose(transform, transform);
        }
        var s = structure_1.Structure.transform(a.data, transform);
        return new objects_1.PluginStateObject.Molecule.Structure(s, {
            label: a.label,
            description: "".concat(a.description, " [Transformed]")
        });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
    // interpolate(src, tar, t) {
    //     // TODO: optimize
    //     const u = Mat4.fromRotation(Mat4(), Math.PI / 180 * src.angle, Vec3.normalize(Vec3(), src.axis));
    //     Mat4.setTranslation(u, src.translation);
    //     const v = Mat4.fromRotation(Mat4(), Math.PI / 180 * tar.angle, Vec3.normalize(Vec3(), tar.axis));
    //     Mat4.setTranslation(v, tar.translation);
    //     const m = SymmetryOperator.slerp(Mat4(), u, v, t);
    //     const rot = Mat4.getRotation(Quat.zero(), m);
    //     const axis = Vec3();
    //     const angle = Quat.getAxisAngle(axis, rot);
    //     const translation = Mat4.getTranslation(Vec3(), m);
    //     return { axis, angle, translation };
    // }
});
exports.TransformStructureConformation = TransformStructureConformation;
var StructureSelectionFromExpression = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-selection-from-expression',
    display: {
        name: 'Selection',
        description: 'Create a molecular structure from the specified expression.'
    },
    from: objects_1.PluginStateObject.Molecule.Structure,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: function () { return ({
        expression: param_definition_1.ParamDefinition.Value(builder_1.MolScriptBuilder.struct.generator.all, {
            isHidden: true
        }),
        label: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Text('', { isHidden: true }))
    }); }
})({
    apply: function (_a) {
        var a = _a.a, params = _a.params, cache = _a.cache;
        var _b = structure_query_1.StructureQueryHelper.createAndRun(a.data, params.expression), selection = _b.selection, entry = _b.entry;
        cache.entry = entry;
        if (structure_1.StructureSelection.isEmpty(selection))
            return mol_state_1.StateObject.Null;
        var s = structure_1.StructureSelection.unionStructure(selection);
        var props = {
            label: "".concat(params.label || 'Selection'),
            description: structure_1.Structure.elementDescription(s)
        };
        return new objects_1.PluginStateObject.Molecule.Structure(s, props);
    },
    update: function (_a) {
        var a = _a.a, b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams, cache = _a.cache;
        if (oldParams.expression !== newParams.expression)
            return mol_state_1.StateTransformer.UpdateResult.Recreate;
        var entry = cache.entry;
        if (entry.currentStructure === a.data) {
            return mol_state_1.StateTransformer.UpdateResult.Unchanged;
        }
        var selection = structure_query_1.StructureQueryHelper.updateStructure(entry, a.data);
        if (structure_1.StructureSelection.isEmpty(selection))
            return mol_state_1.StateTransformer.UpdateResult.Null;
        structure_query_1.StructureQueryHelper.updateStructureObject(b, selection, newParams.label);
        return mol_state_1.StateTransformer.UpdateResult.Updated;
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.StructureSelectionFromExpression = StructureSelectionFromExpression;
var MultiStructureSelectionFromExpression = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-multi-selection-from-expression',
    display: {
        name: 'Multi-structure Measurement Selection',
        description: 'Create selection object from multiple structures.'
    },
    from: objects_1.PluginStateObject.Root,
    to: objects_1.PluginStateObject.Molecule.Structure.Selections,
    params: function () { return ({
        selections: param_definition_1.ParamDefinition.ObjectList({
            key: param_definition_1.ParamDefinition.Text(void 0, { description: 'A unique key.' }),
            ref: param_definition_1.ParamDefinition.Text(),
            groupId: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Text()),
            expression: param_definition_1.ParamDefinition.Value(builder_1.MolScriptBuilder.struct.generator.empty)
        }, function (e) { return e.ref; }, { isHidden: true }),
        isTransitive: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Boolean(false, {
            isHidden: true,
            description: 'Remap the selections from the original structure if structurally equivalent.'
        })),
        label: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Text('', { isHidden: true }))
    }); }
})({
    apply: function (_a) {
        var params = _a.params, cache = _a.cache, dependencies = _a.dependencies;
        var entries = new Map();
        var selections = [];
        var totalSize = 0;
        for (var _i = 0, _b = params.selections; _i < _b.length; _i++) {
            var sel = _b[_i];
            var _c = structure_query_1.StructureQueryHelper.createAndRun(dependencies[sel.ref].data, sel.expression), selection = _c.selection, entry = _c.entry;
            entries.set(sel.key, entry);
            var loci = structure_1.StructureSelection.toLociWithSourceUnits(selection);
            selections.push({ key: sel.key, loci: loci, groupId: sel.groupId });
            totalSize += structure_1.StructureElement.Loci.size(loci);
        }
        ;
        cache.entries = entries;
        var props = {
            label: "".concat(params.label || 'Multi-selection'),
            description: "".concat(params.selections.length, " source(s), ").concat(totalSize, " element(s) total")
        };
        return new objects_1.PluginStateObject.Molecule.Structure.Selections(selections, props);
    },
    update: function (_a) {
        var b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams, cache = _a.cache, dependencies = _a.dependencies;
        if (!!oldParams.isTransitive !== !!newParams.isTransitive)
            return mol_state_1.StateTransformer.UpdateResult.Recreate;
        var cacheEntries = cache.entries;
        var entries = new Map();
        var current = new Map();
        for (var _i = 0, _b = b.data; _i < _b.length; _i++) {
            var e = _b[_i];
            current.set(e.key, e);
        }
        var changed = false;
        var totalSize = 0;
        var selections = [];
        for (var _c = 0, _d = newParams.selections; _c < _d.length; _c++) {
            var sel = _d[_c];
            var structure = dependencies[sel.ref].data;
            var recreate = false;
            if (cacheEntries.has(sel.key)) {
                var entry = cacheEntries.get(sel.key);
                if (structure_query_1.StructureQueryHelper.isUnchanged(entry, sel.expression, structure) &&
                    current.has(sel.key)) {
                    var loci = current.get(sel.key);
                    if (loci.groupId !== sel.groupId) {
                        loci.groupId = sel.groupId;
                        changed = true;
                    }
                    entries.set(sel.key, entry);
                    selections.push(loci);
                    totalSize += structure_1.StructureElement.Loci.size(loci.loci);
                    continue;
                }
                if (entry.expression !== sel.expression) {
                    recreate = true;
                }
                else {
                    // TODO: properly support "transitive" queries. For that Structure.areUnitAndIndicesEqual needs to be fixed;
                    var update = false;
                    if (!!newParams.isTransitive) {
                        if (structure_1.Structure.areUnitIdsAndIndicesEqual(entry.originalStructure, structure)) {
                            var selection = structure_query_1.StructureQueryHelper.run(entry, entry.originalStructure);
                            entry.currentStructure = structure;
                            entries.set(sel.key, entry);
                            var loci = structure_1.StructureElement.Loci.remap(structure_1.StructureSelection.toLociWithSourceUnits(selection), structure);
                            selections.push({ key: sel.key, loci: loci, groupId: sel.groupId });
                            totalSize += structure_1.StructureElement.Loci.size(loci);
                            changed = true;
                        }
                        else {
                            update = true;
                        }
                    }
                    else {
                        update = true;
                    }
                    if (update) {
                        changed = true;
                        var selection = structure_query_1.StructureQueryHelper.updateStructure(entry, structure);
                        entries.set(sel.key, entry);
                        var loci = structure_1.StructureSelection.toLociWithSourceUnits(selection);
                        selections.push({ key: sel.key, loci: loci, groupId: sel.groupId });
                        totalSize += structure_1.StructureElement.Loci.size(loci);
                    }
                }
            }
            else {
                recreate = true;
            }
            if (recreate) {
                changed = true;
                // create new selection
                var _e = structure_query_1.StructureQueryHelper.createAndRun(structure, sel.expression), selection = _e.selection, entry = _e.entry;
                entries.set(sel.key, entry);
                var loci = structure_1.StructureSelection.toLociWithSourceUnits(selection);
                selections.push({ key: sel.key, loci: loci });
                totalSize += structure_1.StructureElement.Loci.size(loci);
            }
        }
        if (!changed)
            return mol_state_1.StateTransformer.UpdateResult.Unchanged;
        cache.entries = entries;
        b.data = selections;
        b.label = "".concat(newParams.label || 'Multi-selection');
        b.description = "".concat(selections.length, " source(s), ").concat(totalSize, " element(s) total");
        return mol_state_1.StateTransformer.UpdateResult.Updated;
    }
});
exports.MultiStructureSelectionFromExpression = MultiStructureSelectionFromExpression;
var StructureSelectionFromScript = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-selection-from-script',
    display: {
        name: 'Selection',
        description: 'Create a molecular structure from the specified script.'
    },
    from: objects_1.PluginStateObject.Molecule.Structure,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: function () { return ({
        script: param_definition_1.ParamDefinition.Script({
            language: 'mol-script',
            expression: '(sel.atom.atom-groups :residue-test (= atom.resname ALA))'
        }),
        label: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Text(''))
    }); }
})({
    apply: function (_a) {
        var a = _a.a, params = _a.params, cache = _a.cache;
        var _b = structure_query_1.StructureQueryHelper.createAndRun(a.data, params.script), selection = _b.selection, entry = _b.entry;
        cache.entry = entry;
        var s = structure_1.StructureSelection.unionStructure(selection);
        var props = {
            label: "".concat(params.label || 'Selection'),
            description: structure_1.Structure.elementDescription(s)
        };
        return new objects_1.PluginStateObject.Molecule.Structure(s, props);
    },
    update: function (_a) {
        var a = _a.a, b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams, cache = _a.cache;
        if (!script_1.Script.areEqual(oldParams.script, newParams.script)) {
            return mol_state_1.StateTransformer.UpdateResult.Recreate;
        }
        var entry = cache.entry;
        if (entry.currentStructure === a.data) {
            return mol_state_1.StateTransformer.UpdateResult.Unchanged;
        }
        var selection = structure_query_1.StructureQueryHelper.updateStructure(entry, a.data);
        structure_query_1.StructureQueryHelper.updateStructureObject(b, selection, newParams.label);
        return mol_state_1.StateTransformer.UpdateResult.Updated;
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.StructureSelectionFromScript = StructureSelectionFromScript;
var StructureSelectionFromBundle = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-selection-from-bundle',
    display: {
        name: 'Selection',
        description: 'Create a molecular structure from the specified structure-element bundle.'
    },
    from: objects_1.PluginStateObject.Molecule.Structure,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: function () { return ({
        bundle: param_definition_1.ParamDefinition.Value(structure_1.StructureElement.Bundle.Empty, {
            isHidden: true
        }),
        label: param_definition_1.ParamDefinition.Optional(param_definition_1.ParamDefinition.Text('', { isHidden: true }))
    }); }
})({
    apply: function (_a) {
        var a = _a.a, params = _a.params, cache = _a.cache;
        if (params.bundle.hash !== a.data.hashCode) {
            return mol_state_1.StateObject.Null;
        }
        ;
        cache.source = a.data;
        var s = structure_1.StructureElement.Bundle.toStructure(params.bundle, a.data);
        if (s.elementCount === 0)
            return mol_state_1.StateObject.Null;
        var props = {
            label: "".concat(params.label || 'Selection'),
            description: structure_1.Structure.elementDescription(s)
        };
        return new objects_1.PluginStateObject.Molecule.Structure(s, props);
    },
    update: function (_a) {
        var a = _a.a, b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams, cache = _a.cache;
        if (!structure_1.StructureElement.Bundle.areEqual(oldParams.bundle, newParams.bundle)) {
            return mol_state_1.StateTransformer.UpdateResult.Recreate;
        }
        if (newParams.bundle.hash !== a.data.hashCode) {
            return mol_state_1.StateTransformer.UpdateResult.Null;
        }
        if (cache.source === a.data) {
            return mol_state_1.StateTransformer.UpdateResult.Unchanged;
        }
        ;
        cache.source = a.data;
        var s = structure_1.StructureElement.Bundle.toStructure(newParams.bundle, a.data);
        if (s.elementCount === 0)
            return mol_state_1.StateTransformer.UpdateResult.Null;
        b.label = "".concat(newParams.label || 'Selection');
        b.description = structure_1.Structure.elementDescription(s);
        b.data = s;
        return mol_state_1.StateTransformer.UpdateResult.Updated;
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.StructureSelectionFromBundle = StructureSelectionFromBundle;
exports.StructureComplexElementTypes = {
    polymer: 'polymer',
    protein: 'protein',
    nucleic: 'nucleic',
    water: 'water',
    branched: 'branched',
    ligand: 'ligand',
    'non-standard': 'non-standard',
    coarse: 'coarse',
    // Legacy
    'atomic-sequence': 'atomic-sequence',
    'atomic-het': 'atomic-het',
    spheres: 'spheres'
};
var StructureComplexElementTypeTuples = param_definition_1.ParamDefinition.objectToOptions(exports.StructureComplexElementTypes);
var StructureComplexElement = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-complex-element',
    display: {
        name: 'Complex Element',
        description: 'Create a molecular structure from the specified model.'
    },
    from: objects_1.PluginStateObject.Molecule.Structure,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: {
        type: param_definition_1.ParamDefinition.Select('atomic-sequence', StructureComplexElementTypeTuples, { isHidden: true })
    }
})({
    apply: function (_a) {
        // TODO: update function.
        var a = _a.a, params = _a.params;
        var query, label;
        switch (params.type) {
            case 'polymer':
                query = structure_selection_query_1.StructureSelectionQueries.polymer.query;
                label = 'Polymer';
                break;
            case 'protein':
                query = structure_selection_query_1.StructureSelectionQueries.protein.query;
                label = 'Protein';
                break;
            case 'nucleic':
                query = structure_selection_query_1.StructureSelectionQueries.nucleic.query;
                label = 'Nucleic';
                break;
            case 'water':
                query = structure_1.Queries.internal.water();
                label = 'Water';
                break;
            case 'branched':
                query = structure_selection_query_1.StructureSelectionQueries.branchedPlusConnected.query;
                label = 'Branched';
                break;
            case 'ligand':
                query = structure_selection_query_1.StructureSelectionQueries.ligandPlusConnected.query;
                label = 'Ligand';
                break;
            case 'non-standard':
                query = structure_selection_query_1.StructureSelectionQueries.nonStandardPolymer.query;
                label = 'Non-standard';
                break;
            case 'coarse':
                query = structure_selection_query_1.StructureSelectionQueries.coarse.query;
                label = 'Coarse';
                break;
            case 'atomic-sequence':
                query = structure_1.Queries.internal.atomicSequence();
                label = 'Sequence';
                break;
            case 'atomic-het':
                query = structure_1.Queries.internal.atomicHet();
                label = 'HET Groups/Ligands';
                break;
            case 'spheres':
                query = structure_1.Queries.internal.spheres();
                label = 'Coarse Spheres';
                break;
            default:
                throw new Error("".concat(params.type, " is a not valid complex element."));
        }
        var result = query(new structure_1.QueryContext(a.data));
        var s = structure_1.StructureSelection.unionStructure(result);
        if (s.elementCount === 0)
            return mol_state_1.StateObject.Null;
        return new objects_1.PluginStateObject.Molecule.Structure(s, {
            label: label,
            description: structure_1.Structure.elementDescription(s)
        });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.StructureComplexElement = StructureComplexElement;
var StructureComponent = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-component',
    display: {
        name: 'Component',
        description: 'A molecular structure component.'
    },
    from: objects_1.PluginStateObject.Molecule.Structure,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: structure_component_1.StructureComponentParams
})({
    apply: function (_a) {
        var a = _a.a, params = _a.params, cache = _a.cache;
        return (0, structure_component_1.createStructureComponent)(a.data, params, cache);
    },
    update: function (_a) {
        var a = _a.a, b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams, cache = _a.cache;
        return (0, structure_component_1.updateStructureComponent)(a.data, b, oldParams, newParams, cache);
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.StructureComponent = StructureComponent;
var CustomModelProperties = objects_1.PluginStateTransform.BuiltIn({
    name: 'custom-model-properties',
    display: { name: 'Custom Model Properties' },
    isDecorator: true,
    from: objects_1.PluginStateObject.Molecule.Model,
    to: objects_1.PluginStateObject.Molecule.Model,
    params: function (a, ctx) {
        return ctx.customModelProperties.getParams(a === null || a === void 0 ? void 0 : a.data);
    }
})({
    apply: function (_a, ctx) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Custom Props', function (taskCtx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, attachModelProps(a.data, ctx, taskCtx, params)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Model(a.data, {
                                label: a.label,
                                description: a.description
                            })];
                }
            });
        }); });
    },
    update: function (_a, ctx) {
        var _this = this;
        var a = _a.a, b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams;
        return mol_task_1.Task.create('Custom Props', function (taskCtx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var _i, _a, name_1, property;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        b.data = a.data;
                        b.label = a.label;
                        b.description = a.description;
                        for (_i = 0, _a = oldParams.autoAttach; _i < _a.length; _i++) {
                            name_1 = _a[_i];
                            property = ctx.customModelProperties.get(name_1);
                            if (!property)
                                continue;
                            a.data.customProperties.reference(property.descriptor, false);
                        }
                        return [4 /*yield*/, attachModelProps(a.data, ctx, taskCtx, newParams)];
                    case 1:
                        _b.sent();
                        return [2 /*return*/, mol_state_1.StateTransformer.UpdateResult.Updated];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customProperties.dispose();
    }
});
exports.CustomModelProperties = CustomModelProperties;
function attachModelProps(model, ctx, taskCtx, params) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var propertyCtx, autoAttach, properties, _i, _a, name_2, property, props, e_1;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    propertyCtx = { runtime: taskCtx, assetManager: ctx.managers.asset };
                    autoAttach = params.autoAttach, properties = params.properties;
                    _i = 0, _a = Object.keys(properties);
                    _b.label = 1;
                case 1:
                    if (!(_i < _a.length)) return [3 /*break*/, 8];
                    name_2 = _a[_i];
                    property = ctx.customModelProperties.get(name_2);
                    props = properties[name_2];
                    if (!(autoAttach.includes(name_2) || property.isHidden)) return [3 /*break*/, 6];
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, property.attach(propertyCtx, model, props, true)];
                case 3:
                    _b.sent();
                    return [3 /*break*/, 5];
                case 4:
                    e_1 = _b.sent();
                    ctx.log.warn("Error attaching model prop '".concat(name_2, "': ").concat(e_1));
                    return [3 /*break*/, 5];
                case 5: return [3 /*break*/, 7];
                case 6:
                    property.set(model, props);
                    _b.label = 7;
                case 7:
                    _i++;
                    return [3 /*break*/, 1];
                case 8: return [2 /*return*/];
            }
        });
    });
}
var CustomStructureProperties = objects_1.PluginStateTransform.BuiltIn({
    name: 'custom-structure-properties',
    display: { name: 'Custom Structure Properties' },
    isDecorator: true,
    from: objects_1.PluginStateObject.Molecule.Structure,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: function (a, ctx) {
        return ctx.customStructureProperties.getParams(a === null || a === void 0 ? void 0 : a.data.root);
    }
})({
    apply: function (_a, ctx) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Custom Props', function (taskCtx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, attachStructureProps(a.data.root, ctx, taskCtx, params)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Structure(a.data, {
                                label: a.label,
                                description: a.description
                            })];
                }
            });
        }); });
    },
    update: function (_a, ctx) {
        var _this = this;
        var a = _a.a, b = _a.b, oldParams = _a.oldParams, newParams = _a.newParams;
        if (a.data !== b.data)
            return mol_state_1.StateTransformer.UpdateResult.Recreate;
        return mol_task_1.Task.create('Custom Props', function (taskCtx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var _i, _a, name_3, property;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        b.data = a.data;
                        b.label = a.label;
                        b.description = a.description;
                        for (_i = 0, _a = oldParams.autoAttach; _i < _a.length; _i++) {
                            name_3 = _a[_i];
                            property = ctx.customStructureProperties.get(name_3);
                            if (!property)
                                continue;
                            a.data.customPropertyDescriptors.reference(property.descriptor, false);
                        }
                        return [4 /*yield*/, attachStructureProps(a.data.root, ctx, taskCtx, newParams)];
                    case 1:
                        _b.sent();
                        return [2 /*return*/, mol_state_1.StateTransformer.UpdateResult.Updated];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.CustomStructureProperties = CustomStructureProperties;
function attachStructureProps(structure, ctx, taskCtx, params) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var propertyCtx, autoAttach, properties, _i, _a, name_4, property, props, e_2;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    propertyCtx = { runtime: taskCtx, assetManager: ctx.managers.asset };
                    autoAttach = params.autoAttach, properties = params.properties;
                    _i = 0, _a = Object.keys(properties);
                    _b.label = 1;
                case 1:
                    if (!(_i < _a.length)) return [3 /*break*/, 8];
                    name_4 = _a[_i];
                    property = ctx.customStructureProperties.get(name_4);
                    props = properties[name_4];
                    if (!(autoAttach.includes(name_4) || property.isHidden)) return [3 /*break*/, 6];
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, property.attach(propertyCtx, structure, props, true)];
                case 3:
                    _b.sent();
                    return [3 /*break*/, 5];
                case 4:
                    e_2 = _b.sent();
                    ctx.log.warn("Error attaching structure prop '".concat(name_4, "': ").concat(e_2));
                    return [3 /*break*/, 5];
                case 5: return [3 /*break*/, 7];
                case 6:
                    property.set(structure, props);
                    _b.label = 7;
                case 7:
                    _i++;
                    return [3 /*break*/, 1];
                case 8: return [2 /*return*/];
            }
        });
    });
}
// type ShapeFromPly = typeof ShapeFromPly
// const ShapeFromPly = PluginStateTransform.BuiltIn({
//     name: 'shape-from-ply',
//     display: { name: 'Shape from PLY', description: 'Create Shape from PLY data' },
//     from: SO.Format.Ply,
//     to: SO.Shape.Provider,
//     params(a) {
//         return { };
//     }
// })({
//     apply({ a, params }) {
//         return Task.create('Create shape from PLY', async ctx => {
//             const shape = await shapeFromPly(a.data, params).runInContext(ctx);
//             const props = { label: 'Shape' };
//             return new SO.Shape.Provider(shape, props);
//         });
//     }
// });
//# sourceMappingURL=model.js.map