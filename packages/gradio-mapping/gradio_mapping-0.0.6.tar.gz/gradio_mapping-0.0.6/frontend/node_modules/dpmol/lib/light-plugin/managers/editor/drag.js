"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DragEditor = void 0;
var tslib_1 = require("tslib");
var index_1 = require("../../index");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var structure_1 = require("../../../mol-model/structure");
var int_1 = require("../../../mol-data/int");
var loci_1 = require("../../../mol-model/structure/structure/element/loci");
var math_1 = require("../../utils/math");
var dragInitialState = {
    interval: undefined,
    observers: undefined,
    cRef: '',
    elementId: -1,
    totalOffset: linear_algebra_1.Vec3.create(0, 0, 0)
};
var DragEditor = /** @class */ (function () {
    function DragEditor(plugin) {
        this.state = dragInitialState;
        this.intervalTime = 300;
        this.plugin = plugin;
    }
    DragEditor.prototype.start = function () {
        var _this = this;
        var _a, _b;
        this.plugin.managers.editor.disabledInteraction = ['click', 'drag'];
        this.plugin.managers.selection.structure.setGranularity(index_1.Granularity.Atom);
        this.state.observers =
            (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.interaction.drag.observers.pop();
        this.state.interval = setInterval(function () {
            if (_this.state.totalOffset.filter(function (val) { return val !== 0; }).length === 0 ||
                _this.state.elementId === -1) {
                return;
            }
            var offset = (0, tslib_1.__spreadArray)([], _this.state.totalOffset, true);
            _this.state.totalOffset = linear_algebra_1.Vec3.create(0, 0, 0);
            _this.plugin.managers.editor.executeEdit(_this.state.cRef, function (atomList, bondList) {
                var editedAtomList = (0, tslib_1.__spreadArray)([], atomList, true);
                var editedBondList = (0, tslib_1.__spreadArray)([], bondList, true);
                editedAtomList.forEach(function (atom) {
                    if (atom.elementId === _this.state.elementId) {
                        atom.x -= offset[0];
                        atom.y -= offset[1];
                        atom.z -= offset[2];
                    }
                });
                return {
                    editedAtomList: editedAtomList,
                    editedBondList: editedBondList
                };
            }, function (atomList, bondList) {
                var editedAtomList = (0, tslib_1.__spreadArray)([], atomList, true);
                var editedBondList = (0, tslib_1.__spreadArray)([], bondList, true);
                editedAtomList.forEach(function (atom) {
                    if (atom.elementId === _this.state.elementId) {
                        atom.x -= offset[0];
                        atom.y -= offset[1];
                        atom.z -= offset[2];
                    }
                });
                return {
                    editedAtomList: editedAtomList,
                    editedBondList: editedBondList
                };
            });
        }, this.intervalTime);
        // 最小拖拽距离
        (_b = this.plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.interaction.drag.subscribe(function (a) {
            var loci = a.current.loci;
            if (loci.kind === 'element-loci') {
                var indices = int_1.OrderedSet.toArray(loci.elements[0].indices);
                if (indices.length === 1) {
                    _this.plugin.cells.forEach(function (cell, ref) {
                        if (cell.model.structure &&
                            loci_1.Loci.isSubset(structure_1.Structure.toStructureElementLoci(cell.model.structure), loci)) {
                            _this.state.cRef = ref;
                        }
                    });
                    var offset = (0, math_1.getDragOffset)(_this.plugin, a.pageStart, a.pageEnd);
                    // console.log('Offset', offset)
                    linear_algebra_1.Vec3.add(_this.state.totalOffset, _this.state.totalOffset, offset);
                    _this.state.elementId = loci.elements[0].unit.elements[indices[0]];
                }
            }
        });
    };
    DragEditor.prototype.end = function () {
        var _a, _b;
        if (this.state.interval) {
            clearInterval(this.state.interval);
        }
        (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.interaction.drag.observers.pop();
        if (this.state.observers) {
            (_b = this.plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.interaction.drag.subscribe(this.state.observers);
        }
        this.state.observers = undefined;
        this.state.cRef = '';
        this.state.elementId = -1;
        this.state.totalOffset = linear_algebra_1.Vec3.create(0, 0, 0);
    };
    return DragEditor;
}());
exports.DragEditor = DragEditor;
//# sourceMappingURL=drag.js.map