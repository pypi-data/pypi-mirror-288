"use strict";
/**
 * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractionLineRepresentation = exports.InteractionLineParams = void 0;
var tslib_1 = require("tslib");
var loci_1 = require("../../../mol-model/loci");
var lines_1 = require("../../../mol-geo/geometry/lines/lines");
// import { Text } from '../../../mol-geo/geometry/text/text'
var param_definition_1 = require("../../../mol-util/param-definition");
var representation_1 = require("../representation");
var representation_2 = require("../../representation");
var shape_1 = require("../../../mol-model/shape");
var lines_builder_1 = require("../../../mol-geo/geometry/lines/lines-builder");
// import { TextBuilder } from '../../../mol-geo/geometry/text/text-builder'
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var marker_action_1 = require("../../../mol-util/marker-action");
var label_1 = require("../../../mol-theme/label");
// import { LociLabelTextParams } from './common'
var geometry_1 = require("../../../mol-math/geometry");
var color_1 = require("../../../mol-util/color");
var SharedParams = {
    unitLabel: param_definition_1.ParamDefinition.Text('\u212B', { isEssential: true })
};
var LineParams = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, lines_1.Lines.Params), SharedParams), { lineSizeAttenuation: param_definition_1.ParamDefinition.Boolean(false), linesColor: param_definition_1.ParamDefinition.Color((0, color_1.Color)(0xd6d8ef), { isEssential: true }), linesSize: param_definition_1.ParamDefinition.Numeric(0.8), 
    // alpha: PD.Numeric(0.6, { min: 0, max: 1, step: 0.01 })
    alpha: param_definition_1.ParamDefinition.Numeric(0.6, { min: 0, max: 1, step: 0.01 }, {
        label: 'Opacity',
        isEssential: true,
        description: 'How opaque/transparent the representation is rendered.'
    }) });
var InteractionLineVisuals = {
    lines: function (ctx, getParams) {
        return (0, representation_1.ShapeRepresentation)(getLinesShape, lines_1.Lines.Utils, {
            modifyState: function (s) { return ((0, tslib_1.__assign)((0, tslib_1.__assign)({}, s), { markerActions: marker_action_1.MarkerActions.Highlighting })); }
        });
    }
};
exports.InteractionLineParams = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, LineParams), { visuals: param_definition_1.ParamDefinition.MultiSelect(['lines'], param_definition_1.ParamDefinition.objectToOptions(InteractionLineVisuals)) });
//
function getInteractionLineState() {
    return {
        sphereA: (0, geometry_1.Sphere3D)(),
        sphereB: (0, geometry_1.Sphere3D)(),
        center: (0, linear_algebra_1.Vec3)(),
        distance: 0
    };
}
function setInteractionLineState(pair, state) {
    var sphereA = state.sphereA, sphereB = state.sphereB, center = state.center;
    var _a = pair.loci, lociA = _a[0], lociB = _a[1];
    loci_1.Loci.getBoundingSphere(lociA, sphereA);
    loci_1.Loci.getBoundingSphere(lociB, sphereB);
    linear_algebra_1.Vec3.add(center, sphereA.center, sphereB.center);
    linear_algebra_1.Vec3.scale(center, center, 0.5);
    state.distance = linear_algebra_1.Vec3.distance(sphereA.center, sphereB.center);
    return state;
}
var tmpState = getInteractionLineState();
function getInteractionLineName(data, unitLabel) {
    return data.pairs.length === 1
        ? "interactionLine ".concat((0, label_1.distanceLabel)(data.pairs[0], {
            unitLabel: unitLabel,
            measureOnly: true
        }))
        : "".concat(data.pairs.length, " interactionLines");
}
//
function buildLines(data, props, lines) {
    var builder = lines_builder_1.LinesBuilder.create(128, 64, lines);
    for (var i = 0, il = data.pairs.length; i < il; ++i) {
        setInteractionLineState(data.pairs[i], tmpState);
        builder.add(tmpState.sphereA.center[0], tmpState.sphereA.center[1], tmpState.sphereA.center[2], tmpState.sphereB.center[0], tmpState.sphereB.center[1], tmpState.sphereB.center[2], i);
        // builder.addFixedLengthDashes(
        //   tmpState.sphereA.center,
        //   tmpState.sphereB.center,
        //   props.dashLength,
        //   i
        // )
    }
    return builder.getLines();
}
function getLinesShape(ctx, data, props, shape) {
    var lines = buildLines(data, props, shape && shape.geometry);
    var name = getInteractionLineName(data, props.unitLabel);
    var getLabel = function (groupId) {
        return (0, label_1.distanceLabel)(data.pairs[groupId], props);
    };
    return shape_1.Shape.create(name, data, lines, function () { return props.linesColor; }, function () { return props.linesSize; }, getLabel);
}
function InteractionLineRepresentation(ctx, getParams) {
    var repr = representation_2.Representation.createMulti('interactionLine', ctx, getParams, representation_2.Representation.StateBuilder, InteractionLineVisuals);
    repr.setState({ pickable: true, markerActions: marker_action_1.MarkerActions.All });
    return repr;
}
exports.InteractionLineRepresentation = InteractionLineRepresentation;
//# sourceMappingURL=interaction-line.js.map