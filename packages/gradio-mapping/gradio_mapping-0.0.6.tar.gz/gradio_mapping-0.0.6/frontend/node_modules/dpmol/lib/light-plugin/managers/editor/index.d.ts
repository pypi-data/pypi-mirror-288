import { UUID } from '../../../mol-util';
import { LightPlugin } from '../../index';
import { CellItem, Format, RepresentationType } from '../../types';
import { AtomData, BondData } from '../../utils/writer';
import { DragEditor } from './drag';
import { DrawEditor } from './draw';
import { RotateEditor } from './rotate';
export declare enum EditorMode {
    None = 0,
    Drag = 1,
    Rotate = 2,
    Draw = 3
}
interface EditorManagerState {
    mode: EditorMode;
    editAtomDisabled: boolean;
    addBondDisabled: boolean;
    editBondDisabled: boolean;
    selectedPdb: boolean;
    isMergeNeeded: boolean;
}
export declare enum BOND_ORDER {
    SINGLE = 1,
    DOUBLE = 2,
    TRIPLE = 3,
    AROMATIC = 4,
    SINGLE_OR_DOUBLE = 5,
    SINGLE_OR_AROMATIC = 6,
    DOUBLE_OR_AROMATIC = 7,
    ANY = 8
}
export declare class EditorManager {
    plugin: LightPlugin;
    state: EditorManagerState;
    instance: {
        [EditorMode.Drag]: DragEditor;
        [EditorMode.Rotate]: RotateEditor;
        [EditorMode.Draw]: DrawEditor;
        [EditorMode.None]: undefined;
    };
    private ev;
    editStateUpdated: import("rxjs").Subject<EditorManagerState>;
    editStructureUpdated: import("rxjs").Subject<string>;
    get isEditing(): boolean;
    set isEditing(state: boolean);
    get disabledInteraction(): string[];
    set disabledInteraction(state: string[]);
    get isLockCamera(): boolean;
    set isLockCamera(state: boolean);
    get drawEditor(): DrawEditor;
    get rotateEditor(): RotateEditor;
    get dragEditor(): DragEditor;
    setState(newState: Partial<EditorManagerState>): void;
    setEditorMode(mode: boolean, isLockCamera?: boolean, disabledInteraction?: string[]): void;
    getEditState(): {
        editAtomDisabled: boolean;
        addBondDisabled: boolean;
        editBondDisabled: boolean;
        selectedPdb: boolean;
        isMergeNeeded: boolean;
    };
    executeEdit(ref: UUID, editMolFunc?: (atomList: AtomData[], bondList: BondData[]) => {
        editedAtomList: AtomData[];
        editedBondList: BondData[];
        affectedAtomIds?: number[];
    }, editPDBFunc?: (atomList: AtomData[], bondList: BondData[]) => {
        editedAtomList: AtomData[];
        editedBondList: BondData[];
        affectedAtomIds?: number[];
    }, forceKind?: string): Promise<void>;
    coverSourceData(ref: string, format: Format, data: string | File, resetReprType?: RepresentationType): Promise<void>;
    edit(func: (ref: UUID, elementIds: number[]) => Promise<any>, items?: CellItem[]): Promise<void>;
    deleteAtoms(items?: CellItem[]): Promise<{
        [key: number]: number;
    }>;
    editAtomCharge(charge: number, items?: CellItem[]): Promise<void>;
    editAtomType(elementType?: string, items?: CellItem[]): Promise<void>;
    editBondOrder(offset: number, items?: CellItem[]): Promise<void>;
    addOrDelBond(isAdd: boolean, items?: CellItem[]): Promise<void> | undefined;
    changeEditorMode(mode: EditorMode): void;
    constructor(plugin: LightPlugin);
    start(): void;
}
export {};
