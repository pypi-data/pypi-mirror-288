"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraManager = void 0;
var tslib_1 = require("tslib");
var types_1 = require("../types");
var _3d_1 = require("../../mol-math/linear-algebra/3d");
var boundary_helper_1 = require("../../mol-math/geometry/boundary-helper");
var element_1 = require("../../mol-model/structure/structure/element");
var utils_1 = require("../utils");
var DefaultCameraFocusOptions = {
    minRadius: 5,
    extraRadius: 4,
    durationMs: 250
};
var boundaryHelper = new boundary_helper_1.BoundaryHelper('98');
var CameraManager = /** @class */ (function () {
    function CameraManager(plugin) {
        this.boundaryHelper = new boundary_helper_1.BoundaryHelper('98');
        this.plugin = plugin;
    }
    CameraManager.prototype.focus = function (items) {
        var _a;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var changed, structureSelection, shapeSelection, min, max, boundaries, _i, structureSelection_1, item, cell, structure, loci, i, il, _b, box, sphere, i, il, sphere;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        changed = false;
                        structureSelection = [];
                        shapeSelection = [];
                        if (items) {
                            items.forEach(function (item) {
                                var cell = _this.plugin.cells.get(item.ref);
                                if (!cell)
                                    return;
                                if (Array.from(cell.representations.keys()).some(function (type) { return types_1.MeasurementType.has(type) || types_1.OtherReprType.has(type); })) {
                                    shapeSelection.push(item);
                                    return;
                                }
                                structureSelection.push(item);
                            });
                        }
                        else {
                            shapeSelection.push.apply(shapeSelection, Array.from(this.plugin.managers.selection.shape.selection.values()).map(function (ref) { return ({ ref: ref }); }));
                            structureSelection.push.apply(structureSelection, (this.plugin.managers.selection.structure.getSelectionCellItems().length ?
                                this.plugin.managers.selection.structure.getSelectionCellItems() :
                                shapeSelection.length ? [] : this.plugin.managers.cell.getAllDisplayedCellsRef().map(function (ref) { return ({ ref: ref }); })));
                        }
                        if (!structureSelection.length && !shapeSelection.length)
                            return [2 /*return*/];
                        min = _3d_1.Vec3.create(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                        max = _3d_1.Vec3.create(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                        boundaryHelper.reset();
                        boundaries = [];
                        shapeSelection.forEach(function (item) {
                            var cell = _this.plugin.cells.get(item.ref);
                            if (!cell)
                                return;
                            if (cell.representations.has(types_1.RepresentationType.Surface)) {
                                structureSelection.push(cell.model.other);
                                return;
                            }
                            if (cell.representations.has(types_1.RepresentationType.Pharmacophore)) {
                                var _a = cell.model.other, center = _a.center, normal = _a.normal, radius = _a.radius;
                                if (!normal) {
                                    _3d_1.Vec3.min(min, min, _3d_1.Vec3.create(center[0] - radius, center[1] - radius, center[2] - radius));
                                    _3d_1.Vec3.max(max, max, _3d_1.Vec3.create(center[0] + radius, center[1] + radius, center[2] + radius));
                                    changed = true;
                                    return;
                                }
                                var newCenter = _3d_1.Vec3.create((center[0] + normal[0]) / 2, (center[1] + normal[1]) / 2, (center[2] + normal[2]) / 2);
                                var newRadius = (_3d_1.Vec3.distance(normal, center) + radius) / 2;
                                _3d_1.Vec3.min(min, min, _3d_1.Vec3.create(newCenter[0] - newRadius, newCenter[1] - newRadius, newCenter[2] - newRadius));
                                _3d_1.Vec3.max(max, max, _3d_1.Vec3.create(newCenter[0] + newRadius, newCenter[1] + newRadius, newCenter[2] + newRadius));
                                changed = true;
                                return;
                            }
                            if (cell.representations.has(types_1.RepresentationType.Pocket)) {
                                var _b = cell.model.other, center = _b.center, size = _b.size;
                                var pocketMax = [(center[0] * 2 + size[0]) / 2, (center[1] * 2 + size[1]) / 2, (center[2] * 2 + size[2]) / 2];
                                var pocketMin = [(center[0] * 2 - size[0]) / 2, (center[1] * 2 - size[1]) / 2, (center[2] * 2 - size[2]) / 2];
                                var box = { min: _3d_1.Vec3.fromArray(_3d_1.Vec3.zero(), pocketMin, 0), max: _3d_1.Vec3.fromArray(_3d_1.Vec3.zero(), pocketMax, 0) };
                                _3d_1.Vec3.min(min, min, box.min);
                                _3d_1.Vec3.max(max, max, box.max);
                                changed = true;
                                return;
                            }
                            structureSelection.push.apply(structureSelection, cell.dependency.on);
                        });
                        _i = 0, structureSelection_1 = structureSelection;
                        _c.label = 1;
                    case 1:
                        if (!(_i < structureSelection_1.length)) return [3 /*break*/, 4];
                        item = structureSelection_1[_i];
                        cell = this.plugin.cells.get(item.ref);
                        if (!cell)
                            return [2 /*return*/];
                        return [4 /*yield*/, this.plugin.managers.cell.getStructure(item.ref)];
                    case 2:
                        structure = _c.sent();
                        if (!structure)
                            return [2 /*return*/];
                        loci = (0, utils_1.getLoci)(structure, item.elementIds);
                        if (!element_1.StructureElement.Loci.isEmpty(loci) || ((_a = loci === null || loci === void 0 ? void 0 : loci.elements) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                            boundaries.push(element_1.StructureElement.Loci.getBoundary(loci));
                        }
                        _c.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        if (!boundaries.length) {
                            if (changed) {
                                this.focusSphere({
                                    center: _3d_1.Vec3.create((max[0] + min[0]) / 2, (max[1] + min[1]) / 2, (max[2] + min[2]) / 2),
                                    radius: _3d_1.Vec3.distance(max, min) / 2,
                                });
                            }
                            return [2 /*return*/];
                        }
                        for (i = 0, il = boundaries.length; i < il; ++i) {
                            _b = boundaries[i], box = _b.box, sphere = _b.sphere;
                            _3d_1.Vec3.min(min, min, box.min);
                            _3d_1.Vec3.max(max, max, box.max);
                            boundaryHelper.includePositionRadius(sphere.center, sphere.radius);
                        }
                        boundaryHelper.finishedIncludeStep();
                        for (i = 0, il = boundaries.length; i < il; ++i) {
                            sphere = boundaries[i].sphere;
                            boundaryHelper.radiusPositionRadius(sphere.center, sphere.radius);
                        }
                        this.focusSphere(boundaryHelper.getSphere());
                        return [2 /*return*/];
                }
            });
        });
    };
    CameraManager.prototype.focusSphere = function (sphere, options) {
        var _a, _b;
        var _c = (0, tslib_1.__assign)({ minRadius: 5, extraRadius: 4, durationMs: 250 }, options), extraRadius = _c.extraRadius, minRadius = _c.minRadius, durationMs = _c.durationMs;
        var radius = Math.max(sphere.radius + extraRadius, minRadius);
        var snapshot = (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.camera.getFocus(sphere.center, radius);
        (_b = this.plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.requestCameraReset({ durationMs: durationMs, snapshot: snapshot });
    };
    CameraManager.prototype.reset = function () {
        var _a;
        (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.requestCameraReset({
            durationMs: 200
        });
    };
    CameraManager.prototype.zoomIn = function () {
        var _a, _b;
        var snapshot = (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.camera.getSnapshot();
        if (!snapshot)
            return;
        var pos = zoom(snapshot, 1);
        if (_3d_1.Vec3.distance(snapshot.target, pos) < 10)
            return;
        snapshot.position = pos;
        (_b = this.plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.camera.setState(snapshot, 200);
    };
    CameraManager.prototype.zoomOut = function () {
        var _a, _b;
        var snapshot = (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.camera.getSnapshot();
        if (!snapshot)
            return;
        var pos = zoom(snapshot, -1);
        snapshot.position = pos;
        (_b = this.plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.camera.setState(snapshot, 200);
    };
    return CameraManager;
}());
exports.CameraManager = CameraManager;
function zoom(snapshot, direction) {
    var vec = (0, _3d_1.Vec3)();
    _3d_1.Vec3.sub(vec, snapshot.target, snapshot.position);
    _3d_1.Vec3.normalize(vec, vec);
    _3d_1.Vec3.scale(vec, vec, 5 * direction);
    var pos = snapshot.position;
    _3d_1.Vec3.add(pos, pos, vec);
    return pos;
}
//# sourceMappingURL=camera.js.map