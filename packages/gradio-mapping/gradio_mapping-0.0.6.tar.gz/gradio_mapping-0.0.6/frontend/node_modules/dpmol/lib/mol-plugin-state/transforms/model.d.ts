/**
 * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
import { StructureElement } from '../../mol-model/structure';
import { Expression } from '../../mol-script/language/expression';
import { Script } from '../../mol-script/script';
import { StateTransformer } from '../../mol-state';
import { ParamDefinition as PD } from '../../mol-util/param-definition';
import { PluginStateObject as SO } from '../objects';
export { CoordinatesFromXtc };
export { TrajectoryFromModelAndCoordinates };
export { TrajectoryFromBlob };
export { TrajectoryFromMmCif };
export { TrajectoryFromPDB };
export { TrajectoryFromGRO };
export { TrajectoryFromMOL };
export { TrajectoryFromSDF };
export { TrajectoryFromMOL2 };
export { ModelFromTrajectory };
export { StructureFromTrajectory };
export { StructureFromModel };
export { TransformStructureConformation };
export { StructureSelectionFromExpression };
export { MultiStructureSelectionFromExpression };
export { StructureSelectionFromScript };
export { StructureSelectionFromBundle };
export { StructureComplexElement };
export { StructureComponent };
export { CustomModelProperties };
export { CustomStructureProperties };
declare type CoordinatesFromXtc = typeof CoordinatesFromXtc;
declare const CoordinatesFromXtc: StateTransformer<SO.Data.Binary, SO.Molecule.Coordinates, PD.Normalize<{}>>;
declare type TrajectoryFromModelAndCoordinates = typeof TrajectoryFromModelAndCoordinates;
declare const TrajectoryFromModelAndCoordinates: StateTransformer<SO.Root, SO.Molecule.Trajectory, PD.Normalize<{
    modelRef: string;
    coordinatesRef: string;
}>>;
declare type TrajectoryFromBlob = typeof TrajectoryFromBlob;
declare const TrajectoryFromBlob: StateTransformer<SO.Format.Blob, SO.Molecule.Trajectory, PD.Normalize<{}>>;
declare type TrajectoryFromMmCif = typeof TrajectoryFromMmCif;
declare const TrajectoryFromMmCif: StateTransformer<SO.Format.Cif, SO.Molecule.Trajectory, PD.Normalize<{
    blockHeader: string | undefined;
}>>;
declare type TrajectoryFromPDB = typeof TrajectoryFromPDB;
declare const TrajectoryFromPDB: StateTransformer<SO.Data.String, SO.Molecule.Trajectory, PD.Normalize<{
    isPdbqt: boolean;
}>>;
declare type TrajectoryFromGRO = typeof TrajectoryFromGRO;
declare const TrajectoryFromGRO: StateTransformer<SO.Data.String, SO.Molecule.Trajectory, PD.Normalize<{}>>;
declare type TrajectoryFromMOL = typeof TrajectoryFromMOL;
declare const TrajectoryFromMOL: StateTransformer<SO.Data.String, SO.Molecule.Trajectory, PD.Normalize<{}>>;
declare type TrajectoryFromSDF = typeof TrajectoryFromSDF;
declare const TrajectoryFromSDF: StateTransformer<SO.Data.String, SO.Molecule.Trajectory, PD.Normalize<{}>>;
declare type TrajectoryFromMOL2 = typeof TrajectoryFromMOL;
declare const TrajectoryFromMOL2: StateTransformer<SO.Data.String, SO.Molecule.Trajectory, PD.Normalize<{}>>;
declare type ModelFromTrajectory = typeof ModelFromTrajectory;
declare const ModelFromTrajectory: StateTransformer<SO.Molecule.Trajectory, SO.Molecule.Model, PD.Normalize<{
    modelIndex: number;
}>>;
declare type StructureFromTrajectory = typeof StructureFromTrajectory;
declare const StructureFromTrajectory: StateTransformer<SO.Molecule.Trajectory, SO.Molecule.Structure, PD.Normalize<{}>>;
declare type StructureFromModel = typeof StructureFromModel;
declare const StructureFromModel: StateTransformer<SO.Molecule.Model, SO.Molecule.Structure, PD.Normalize<{
    type: PD.NamedParams<PD.Normalize<{
        dynamicBonds: any;
    }>, "auto"> | PD.NamedParams<PD.Normalize<{
        dynamicBonds: any;
        id: any;
    }>, "assembly"> | PD.NamedParams<PD.Normalize<{
        dynamicBonds: any;
        ijkMin: any;
        ijkMax: any;
    }>, "symmetry"> | PD.NamedParams<PD.Normalize<{
        dynamicBonds: any;
    }>, "model"> | PD.NamedParams<PD.Normalize<{
        dynamicBonds: any;
        radius: any;
    }>, "symmetry-mates"> | PD.NamedParams<PD.Normalize<{
        dynamicBonds: any;
        generators: any;
    }>, "symmetry-assembly">;
}>>;
declare type TransformStructureConformation = typeof TransformStructureConformation;
declare const TransformStructureConformation: StateTransformer<SO.Molecule.Structure, SO.Molecule.Structure, PD.Normalize<{
    transform: PD.NamedParams<PD.Normalize<{
        data: any;
        transpose: any;
    }>, "matrix"> | PD.NamedParams<PD.Normalize<{
        axis: any;
        angle: any;
        translation: any;
    }>, "components">;
}>>;
declare type StructureSelectionFromExpression = typeof StructureSelectionFromExpression;
declare const StructureSelectionFromExpression: StateTransformer<SO.Molecule.Structure, SO.Molecule.Structure, PD.Normalize<{
    expression: Expression;
    label: string | undefined;
}>>;
declare type MultiStructureSelectionFromExpression = typeof MultiStructureSelectionFromExpression;
declare const MultiStructureSelectionFromExpression: StateTransformer<SO.Root, SO.Molecule.Structure.Selections, PD.Normalize<{
    selections: PD.Normalize<{
        key: any;
        ref: any;
        groupId: any;
        expression: any;
    }>[];
    isTransitive: boolean | undefined;
    label: string | undefined;
}>>;
declare type StructureSelectionFromScript = typeof StructureSelectionFromScript;
declare const StructureSelectionFromScript: StateTransformer<SO.Molecule.Structure, SO.Molecule.Structure, PD.Normalize<{
    script: Script;
    label: string | undefined;
}>>;
declare type StructureSelectionFromBundle = typeof StructureSelectionFromBundle;
declare const StructureSelectionFromBundle: StateTransformer<SO.Molecule.Structure, SO.Molecule.Structure, PD.Normalize<{
    bundle: StructureElement.Bundle;
    label: string | undefined;
}>>;
export declare const StructureComplexElementTypes: {
    readonly polymer: "polymer";
    readonly protein: "protein";
    readonly nucleic: "nucleic";
    readonly water: "water";
    readonly branched: "branched";
    readonly ligand: "ligand";
    readonly 'non-standard': "non-standard";
    readonly coarse: "coarse";
    readonly 'atomic-sequence': "atomic-sequence";
    readonly 'atomic-het': "atomic-het";
    readonly spheres: "spheres";
};
export declare type StructureComplexElementTypes = keyof typeof StructureComplexElementTypes;
declare type StructureComplexElement = typeof StructureComplexElement;
declare const StructureComplexElement: StateTransformer<SO.Molecule.Structure, SO.Molecule.Structure, PD.Normalize<{
    type: "spheres" | "polymer" | "water" | "branched" | "ligand" | "coarse" | "protein" | "nucleic" | "non-standard" | "atomic-sequence" | "atomic-het";
}>>;
declare type StructureComponent = typeof StructureComponent;
declare const StructureComponent: StateTransformer<SO.Molecule.Structure, SO.Molecule.Structure, PD.Normalize<{
    type: PD.NamedParams<"all" | "polymer" | "water" | "branched" | "ligand" | "ion" | "lipid" | "coarse" | "protein" | "nucleic" | "non-standard", "static"> | PD.NamedParams<Script, "script"> | PD.NamedParams<StructureElement.Bundle, "bundle"> | PD.NamedParams<Expression, "expression">;
    nullIfEmpty: boolean | undefined;
    label: string;
}>>;
declare type CustomModelProperties = typeof CustomModelProperties;
declare const CustomModelProperties: StateTransformer<SO.Molecule.Model, SO.Molecule.Model, PD.Normalize<{
    autoAttach: string[];
    properties: PD.Normalize<{
        [x: string]: any;
    }>;
}>>;
declare type CustomStructureProperties = typeof CustomStructureProperties;
declare const CustomStructureProperties: StateTransformer<SO.Molecule.Structure, SO.Molecule.Structure, PD.Normalize<{
    autoAttach: string[];
    properties: PD.Normalize<{
        [x: string]: any;
    }>;
}>>;
