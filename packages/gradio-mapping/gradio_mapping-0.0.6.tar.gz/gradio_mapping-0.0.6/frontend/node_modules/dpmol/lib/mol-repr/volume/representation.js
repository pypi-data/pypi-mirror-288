"use strict";
/**
 * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VolumeRepresentation = exports.VolumeParams = exports.VolumeRepresentationProvider = exports.VolumeVisual = void 0;
var tslib_1 = require("tslib");
var param_definition_1 = require("../../mol-util/param-definition");
var visual_1 = require("../visual");
var volume_1 = require("../../mol-model/volume");
var geometry_1 = require("../../mol-geo/geometry/geometry");
var theme_1 = require("../../mol-theme/theme");
var transform_data_1 = require("../../mol-geo/geometry/transform-data");
var render_object_1 = require("../../mol-gl/render-object");
var loci_1 = require("../../mol-model/loci");
var int_1 = require("../../mol-data/int");
var util_1 = require("../util");
var color_1 = require("../../mol-theme/color");
var mol_util_1 = require("../../mol-util");
var size_data_1 = require("../../mol-geo/geometry/size-data");
var color_data_1 = require("../../mol-geo/geometry/color-data");
var representation_1 = require("../representation");
var base_1 = require("../../mol-geo/geometry/base");
var rxjs_1 = require("rxjs");
var mol_task_1 = require("../../mol-task");
var type_helpers_1 = require("../../mol-util/type-helpers");
function createVolumeRenderObject(volume, geometry, locationIt, theme, props, materialId) {
    var _a = geometry_1.Geometry.getUtils(geometry), createValues = _a.createValues, createRenderableState = _a.createRenderableState;
    var transform = (0, transform_data_1.createIdentityTransform)();
    var values = createValues(geometry, transform, locationIt, theme, props);
    var state = createRenderableState(props);
    return (0, render_object_1.createRenderObject)(geometry.kind, values, state, materialId);
}
function VolumeVisual(builder, materialId) {
    var defaultProps = builder.defaultProps, createGeometry = builder.createGeometry, createLocationIterator = builder.createLocationIterator, getLoci = builder.getLoci, eachLocation = builder.eachLocation, setUpdateState = builder.setUpdateState, mustRecreate = builder.mustRecreate, dispose = builder.dispose;
    var _a = builder.geometryUtils, updateValues = _a.updateValues, updateBoundingSphere = _a.updateBoundingSphere, updateRenderableState = _a.updateRenderableState, createPositionIterator = _a.createPositionIterator;
    var updateState = util_1.VisualUpdateState.create();
    var renderObject;
    var newProps;
    var newTheme;
    var newVolume;
    var currentProps = Object.assign({}, defaultProps);
    var currentTheme = theme_1.Theme.createEmpty();
    var currentVolume;
    var geometry;
    var geometryVersion = -1;
    var locationIt;
    var positionIt;
    function prepareUpdate(theme, props, volume) {
        if (!volume && !currentVolume) {
            throw new Error('missing volume');
        }
        newProps = Object.assign({}, currentProps, props);
        newTheme = theme;
        newVolume = volume;
        util_1.VisualUpdateState.reset(updateState);
        if (!renderObject) {
            updateState.createNew = true;
        }
        else if (!currentVolume ||
            !volume_1.Volume.areEquivalent(newVolume, currentVolume)) {
            updateState.createNew = true;
        }
        if (updateState.createNew) {
            updateState.createGeometry = true;
            return;
        }
        setUpdateState(updateState, volume, newProps, currentProps, newTheme, currentTheme);
        if (!color_1.ColorTheme.areEqual(theme.color, currentTheme.color))
            updateState.updateColor = true;
        if (updateState.createGeometry) {
            updateState.updateColor = true;
        }
    }
    function update(newGeometry) {
        if (updateState.createNew) {
            locationIt = createLocationIterator(newVolume);
            if (newGeometry) {
                renderObject = createVolumeRenderObject(newVolume, newGeometry, locationIt, newTheme, newProps, materialId);
                positionIt = createPositionIterator(newGeometry, renderObject.values);
            }
            else {
                throw new Error('expected geometry to be given');
            }
        }
        else {
            if (!renderObject) {
                throw new Error('expected renderObject to be available');
            }
            locationIt.reset();
            if (updateState.createGeometry) {
                if (newGeometry) {
                    mol_util_1.ValueCell.updateIfChanged(renderObject.values.drawCount, geometry_1.Geometry.getDrawCount(newGeometry));
                    mol_util_1.ValueCell.updateIfChanged(renderObject.values.uVertexCount, geometry_1.Geometry.getVertexCount(newGeometry));
                }
                else {
                    throw new Error('expected geometry to be given');
                }
            }
            if (updateState.updateTransform || updateState.createGeometry) {
                updateBoundingSphere(renderObject.values, newGeometry || geometry);
                positionIt = createPositionIterator(newGeometry || geometry, renderObject.values);
            }
            if (updateState.updateSize) {
                // not all geometries have size data, so check here
                if ('uSize' in renderObject.values) {
                    (0, size_data_1.createSizes)(locationIt, newTheme.size, renderObject.values);
                }
            }
            if (updateState.updateColor) {
                (0, color_data_1.createColors)(locationIt, positionIt, newTheme.color, renderObject.values);
            }
            updateValues(renderObject.values, newProps);
            updateRenderableState(renderObject.state, newProps);
        }
        currentProps = newProps;
        currentTheme = newTheme;
        currentVolume = newVolume;
        if (newGeometry) {
            geometry = newGeometry;
            geometryVersion += 1;
        }
    }
    function lociApply(loci, apply) {
        if ((0, loci_1.isEveryLoci)(loci)) {
            return apply(int_1.Interval.ofBounds(0, locationIt.groupCount * locationIt.instanceCount));
        }
        else {
            return eachLocation(loci, currentVolume, currentProps, apply);
        }
    }
    return {
        get groupCount() {
            return locationIt ? locationIt.count : 0;
        },
        get renderObject() {
            return renderObject;
        },
        get geometryVersion() {
            return geometryVersion;
        },
        createOrUpdate: function (ctx, theme, props, volume) {
            if (props === void 0) { props = {}; }
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
                var newGeometry;
                return (0, tslib_1.__generator)(this, function (_a) {
                    prepareUpdate(theme, props, volume || currentVolume);
                    if (updateState.createGeometry) {
                        newGeometry = createGeometry(ctx, newVolume, newTheme, newProps, geometry);
                        return [2 /*return*/, (0, type_helpers_1.isPromiseLike)(newGeometry)
                                ? newGeometry.then(update)
                                : update(newGeometry)];
                    }
                    else {
                        update();
                    }
                    return [2 /*return*/];
                });
            });
        },
        getLoci: function (pickingId) {
            return renderObject
                ? getLoci(pickingId, currentVolume, currentProps, renderObject.id)
                : loci_1.EmptyLoci;
        },
        mark: function (loci, action) {
            return visual_1.Visual.mark(renderObject, loci, action, lociApply);
        },
        setVisibility: function (visible) {
            visual_1.Visual.setVisibility(renderObject, visible);
        },
        setAlphaFactor: function (alphaFactor) {
            visual_1.Visual.setAlphaFactor(renderObject, alphaFactor);
        },
        setPickable: function (pickable) {
            visual_1.Visual.setPickable(renderObject, pickable);
        },
        setColorOnly: function (colorOnly) {
            visual_1.Visual.setColorOnly(renderObject, colorOnly);
        },
        setTransform: function (matrix, instanceMatrices) {
            visual_1.Visual.setTransform(renderObject, matrix, instanceMatrices);
        },
        setOverpaint: function (overpaint) {
            return visual_1.Visual.setOverpaint(renderObject, overpaint, lociApply, true);
        },
        setTransparency: function (transparency) {
            return visual_1.Visual.setTransparency(renderObject, transparency, lociApply, true);
        },
        setSubstance: function (substance) {
            return visual_1.Visual.setSubstance(renderObject, substance, lociApply, true);
        },
        setClipping: function (clipping) {
            return visual_1.Visual.setClipping(renderObject, clipping, lociApply, true);
        },
        destroy: function () {
            dispose === null || dispose === void 0 ? void 0 : dispose(geometry);
            if (renderObject) {
                renderObject.state.disposed = true;
                renderObject = undefined;
            }
        },
        mustRecreate: mustRecreate
    };
}
exports.VolumeVisual = VolumeVisual;
function VolumeRepresentationProvider(p) {
    return p;
}
exports.VolumeRepresentationProvider = VolumeRepresentationProvider;
//
exports.VolumeParams = (0, tslib_1.__assign)({}, base_1.BaseGeometry.Params);
function VolumeRepresentation(label, ctx, getParams, visualCtor, getLoci) {
    var version = 0;
    var webgl = ctx.webgl;
    var updated = new rxjs_1.Subject();
    var geometryState = new representation_1.Representation.GeometryState();
    var materialId = (0, render_object_1.getNextMaterialId)();
    var renderObjects = [];
    var _state = representation_1.Representation.createState();
    var visual;
    var _volume;
    var _params;
    var _props;
    var _theme = theme_1.Theme.createEmpty();
    function createOrUpdate(props, volume) {
        var _this = this;
        if (props === void 0) { props = {}; }
        if (volume && volume !== _volume) {
            _params = getParams(ctx, volume);
            _volume = volume;
            if (!_props)
                _props = param_definition_1.ParamDefinition.getDefaultValues(_params);
        }
        var qualityProps = (0, util_1.getQualityProps)(Object.assign({}, _props, props), _volume);
        Object.assign(_props, props, qualityProps);
        return mol_task_1.Task.create('Creating or updating VolumeRepresentation', function (runtime) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var promise;
            var _a;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!visual) {
                            visual = visualCtor(materialId, _volume, _props, webgl);
                        }
                        else if ((_a = visual.mustRecreate) === null || _a === void 0 ? void 0 : _a.call(visual, _volume, _props, webgl)) {
                            visual.destroy();
                            visual = visualCtor(materialId, _volume, _props, webgl);
                        }
                        promise = visual.createOrUpdate({ webgl: webgl, runtime: runtime }, _theme, _props, volume);
                        if (!promise) return [3 /*break*/, 2];
                        return [4 /*yield*/, promise
                            // update list of renderObjects
                        ];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2:
                        // update list of renderObjects
                        renderObjects.length = 0;
                        if (visual && visual.renderObject) {
                            renderObjects.push(visual.renderObject);
                            geometryState.add(visual.renderObject.id, visual.geometryVersion);
                        }
                        geometryState.snapshot();
                        // increment version
                        updated.next(version++);
                        return [2 /*return*/];
                }
            });
        }); });
    }
    function mark(loci, action) {
        return visual ? visual.mark(loci, action) : false;
    }
    function setState(state) {
        if (state.visible !== undefined && visual)
            visual.setVisibility(state.visible);
        if (state.alphaFactor !== undefined && visual)
            visual.setAlphaFactor(state.alphaFactor);
        if (state.pickable !== undefined && visual)
            visual.setPickable(state.pickable);
        if (state.overpaint !== undefined && visual)
            visual.setOverpaint(state.overpaint);
        if (state.transparency !== undefined && visual)
            visual.setTransparency(state.transparency);
        if (state.transform !== undefined && visual)
            visual.setTransform(state.transform);
        representation_1.Representation.updateState(_state, state);
    }
    function setTheme(theme) {
        _theme = theme;
    }
    function destroy() {
        if (visual)
            visual.destroy();
    }
    return {
        label: label,
        get groupCount() {
            return visual ? visual.groupCount : 0;
        },
        get props() {
            return _props;
        },
        get params() {
            return _params;
        },
        get state() {
            return _state;
        },
        get theme() {
            return _theme;
        },
        get geometryVersion() {
            return geometryState.version;
        },
        renderObjects: renderObjects,
        updated: updated,
        createOrUpdate: createOrUpdate,
        setState: setState,
        setTheme: setTheme,
        getLoci: function (pickingId) {
            if (pickingId === undefined)
                return getLoci(_volume, _props);
            return visual ? visual.getLoci(pickingId) : loci_1.EmptyLoci;
        },
        mark: mark,
        destroy: destroy
    };
}
exports.VolumeRepresentation = VolumeRepresentation;
//# sourceMappingURL=representation.js.map