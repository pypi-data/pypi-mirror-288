"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RotateEditor = void 0;
var tslib_1 = require("tslib");
var int_1 = require("../../../mol-data/int");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var color_1 = require("../../../mol-util/color");
var types_1 = require("../../types");
var math_1 = require("../../utils/math");
var rotateInitialState = {
    interval: undefined,
    dragObserver: undefined,
    cRef: '',
    elementIds: [],
    unit: undefined,
    rotateOffset: linear_algebra_1.Vec3.create(0, 0, 0),
    rotateAtoms: [],
    arrowCRef: undefined,
    invert: false,
    pointA: linear_algebra_1.Vec3.create(0, 0, 0),
    pointB: linear_algebra_1.Vec3.create(0, 0, 0)
};
var RotateEditor = /** @class */ (function () {
    function RotateEditor(plugin) {
        this.state = rotateInitialState;
        this.intervalTime = 300;
        this.plugin = plugin;
    }
    RotateEditor.prototype.start = function () {
        var _a, _b, _c;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var getRotateAtoms;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        this.plugin.managers.editor.disabledInteraction = ['drag'];
                        this.plugin.managers.selection.structure.setGranularity(types_1.Granularity.Atom);
                        this.state.dragObserver =
                            (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.interaction.drag.observers.pop();
                        getRotateAtoms = function () { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                            var selection, selectionElements, elementId_1, structure, unit, _a, bonds, conformation, rings, elements, bondMap, index, i, l, i_1, l_1, source_1, target_1, _b, atoms, checkedAtoms_1, atomId;
                            var _c;
                            var _d;
                            return (0, tslib_1.__generator)(this, function (_e) {
                                switch (_e.label) {
                                    case 0:
                                        if (this.state.arrowCRef) {
                                            this.plugin.managers.cell.remove([{ ref: this.state.arrowCRef }]);
                                            this.state.arrowCRef = undefined;
                                        }
                                        selection = this.plugin.managers.selection.structure.selection;
                                        this.state.cRef = '';
                                        this.state.elementIds = [];
                                        this.state.unit = undefined;
                                        selectionElements = Array.from(selection.entries()).filter(function (_a) {
                                            var ref = _a[0], elements = _a[1];
                                            return elements.length > 0;
                                        });
                                        if (!(selectionElements.length === 1)) return [3 /*break*/, 2];
                                        elementId_1 = selectionElements[0][1];
                                        if (!(elementId_1.length === 2)) return [3 /*break*/, 2];
                                        this.state.cRef = selectionElements[0][0];
                                        this.state.elementIds = (0, tslib_1.__spreadArray)([], elementId_1, true);
                                        structure = (_d = this.plugin.cells.get(selectionElements[0][0])) === null || _d === void 0 ? void 0 : _d.model.structure;
                                        if (!structure)
                                            return [2 /*return*/];
                                        unit = structure.units.find(function (unit) {
                                            return int_1.SortedArray.has(unit.elements, elementId_1[0]) &&
                                                int_1.SortedArray.has(unit.elements, elementId_1[1]);
                                        });
                                        this.state.unit = unit;
                                        _a = unit, bonds = _a.bonds, conformation = _a.conformation, rings = _a.rings, elements = _a.elements;
                                        bondMap = new Map();
                                        index = -1;
                                        for (i = 0, l = bonds.a.length; i < l; i++) {
                                            if (index === -1 &&
                                                ((elements[bonds.a[i]] === elementId_1[0] &&
                                                    elements[bonds.b[i]] === elementId_1[1] &&
                                                    bonds.edgeProps.order[i] === 1) ||
                                                    (elements[bonds.a[i]] === elementId_1[1] &&
                                                        elements[bonds.b[i]] === elementId_1[0] &&
                                                        bonds.edgeProps.order[i] === 1))) {
                                                // 环上的单键不能转
                                                for (i_1 = 0, l_1 = rings.all.length; i_1 < l_1; i_1++) {
                                                    if (rings.all[i_1].includes(elementId_1[0]) &&
                                                        rings.all[i_1].includes(elementId_1[1])) {
                                                        return [2 /*return*/];
                                                    }
                                                }
                                                index = i;
                                            }
                                            if (!bondMap.has(elements[bonds.a[i]])) {
                                                bondMap.set(elements[bonds.a[i]], [elements[bonds.b[i]]]);
                                            }
                                            else {
                                                bondMap.set(elements[bonds.a[i]], (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], bondMap.get(elements[bonds.a[i]]), true), [elements[bonds.b[i]]], false));
                                            }
                                        }
                                        if (!(index !== -1 &&
                                            bondMap.get(elementId_1[0]).length > 1 &&
                                            bondMap.get(elementId_1[1]).length > 1)) return [3 /*break*/, 2];
                                        source_1 = this.state.invert ? 1 : 0;
                                        target_1 = this.state.invert ? 0 : 1;
                                        this.state.pointA = linear_algebra_1.Vec3.create(conformation.x(elementId_1[target_1]), conformation.y(elementId_1[target_1]), conformation.z(elementId_1[target_1]));
                                        this.state.pointB = linear_algebra_1.Vec3.create(conformation.x(elementId_1[source_1]), conformation.y(elementId_1[source_1]), conformation.z(elementId_1[source_1]));
                                        _b = this.state;
                                        return [4 /*yield*/, this.plugin.managers.representation.createOther({
                                                data: {
                                                    center: this.state.pointA,
                                                    vec: linear_algebra_1.Vec3.create(this.state.pointB[0] - this.state.pointA[0], this.state.pointB[1] - this.state.pointA[1], this.state.pointB[2] - this.state.pointA[2]),
                                                    color: color_1.Color.fromRgb(255, 196, 36),
                                                    alpha: 0.9
                                                },
                                                type: types_1.RepresentationType.RotateArrow
                                            })];
                                    case 1:
                                        _b.arrowCRef =
                                            _e.sent();
                                        atoms = (0, tslib_1.__spreadArray)([], bondMap
                                            .get(elementId_1[source_1])
                                            .filter(function (item) {
                                            return item !== elementId_1[target_1] && item !== elementId_1[source_1];
                                        }), true);
                                        checkedAtoms_1 = [elementId_1[source_1]];
                                        this.state.rotateAtoms = (0, tslib_1.__spreadArray)([], atoms, true);
                                        while (atoms.length) {
                                            atomId = atoms.shift();
                                            (_c = this.state.rotateAtoms).push.apply(_c, bondMap.get(atomId));
                                            checkedAtoms_1.push(atomId);
                                            atoms.push.apply(atoms, bondMap
                                                .get(atomId)
                                                .filter(function (item) { return !checkedAtoms_1.includes(item); }));
                                        }
                                        this.state.rotateAtoms = Array.from(new Set(this.state.rotateAtoms.filter(function (item) {
                                            return item !== elementId_1[target_1] && item !== elementId_1[source_1];
                                        })));
                                        _e.label = 2;
                                    case 2: return [2 /*return*/];
                                }
                            });
                        }); };
                        return [4 /*yield*/, getRotateAtoms()];
                    case 1:
                        _d.sent();
                        this.plugin.managers.selection.structure.event.add.subscribe(function () {
                            _this.state.invert = false;
                            _this.state.rotateOffset = linear_algebra_1.Vec3.create(0, 0, 0);
                            _this.state.rotateAtoms = [];
                            _this.state.cRef = '';
                            _this.state.elementIds = [];
                            _this.state.unit = undefined;
                            getRotateAtoms();
                        });
                        this.plugin.managers.selection.structure.event.remove.subscribe(function () {
                            _this.state.invert = false;
                            _this.state.rotateOffset = linear_algebra_1.Vec3.create(0, 0, 0);
                            _this.state.rotateAtoms = [];
                            _this.state.cRef = '';
                            _this.state.elementIds = [];
                            _this.state.unit = undefined;
                            getRotateAtoms();
                        });
                        this.plugin.managers.selection.structure.event.clear.subscribe(function () {
                            _this.state.invert = false;
                            _this.state.rotateOffset = linear_algebra_1.Vec3.create(0, 0, 0);
                            _this.state.rotateAtoms = [];
                            _this.state.cRef = '';
                            _this.state.elementIds = [];
                            _this.state.unit = undefined;
                            if (_this.state.arrowCRef) {
                                _this.plugin.managers.cell.remove([{ ref: _this.state.arrowCRef }]);
                            }
                        });
                        // 换方向直接取非
                        (_b = this.plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.interaction.click.subscribe(function (a) {
                            if (a.current.loci.kind === 'group-loci' &&
                                (a.current.repr
                                    ? a.current.repr.label === 'RotateArrow'
                                    : a.current.loci.shape.name.split('-').shift() === 'RotateArrow')) {
                                _this.state.invert = !_this.state.invert;
                                getRotateAtoms();
                            }
                        });
                        this.state.interval = setInterval(function () {
                            if (_this.state.rotateOffset.filter(function (val) { return val !== 0; }).length === 0 ||
                                !_this.state.cRef ||
                                _this.state.elementIds.length !== 2 ||
                                _this.state.rotateAtoms.length === 0) {
                                return;
                            }
                            var elementId = _this.state.elementIds;
                            var conformation = _this.state.unit.conformation;
                            var a = linear_algebra_1.Vec3.angle(linear_algebra_1.Vec3.sub(linear_algebra_1.Vec3.create(0, 0, 0), _this.state.pointA, _this.state.pointB), linear_algebra_1.Vec3.create(_this.state.rotateOffset[0], _this.state.rotateOffset[1], _this.state.rotateOffset[2]));
                            var cross = linear_algebra_1.Vec3.cross(linear_algebra_1.Vec3.create(0, 0, 0), linear_algebra_1.Vec3.sub(linear_algebra_1.Vec3.create(0, 0, 0), _this.state.pointA, _this.state.pointB), linear_algebra_1.Vec3.create(_this.state.rotateOffset[0], _this.state.rotateOffset[1], _this.state.rotateOffset[2]));
                            if (cross[2] < 0) {
                                a = Math.PI * 2 - a;
                            }
                            var angle = linear_algebra_1.Vec3.distance(linear_algebra_1.Vec3.create(0, 0, 0), linear_algebra_1.Vec3.create(_this.state.rotateOffset[0], _this.state.rotateOffset[1], _this.state.rotateOffset[2])) *
                                5 *
                                (a < Math.PI && a > 0 ? -1 : 1);
                            _this.state.rotateOffset = linear_algebra_1.Vec3.create(0, 0, 0);
                            _this.plugin.managers.editor.executeEdit(_this.state.cRef, function (atomList, bondList) {
                                var editedAtomList = (0, tslib_1.__spreadArray)([], atomList, true);
                                var editedBondList = (0, tslib_1.__spreadArray)([], bondList, true);
                                editedAtomList.forEach(function (atom) {
                                    if (_this.state.rotateAtoms.includes(atom.elementId)) {
                                        var newPoint = (0, math_1.rotateArbitraryLine)([
                                            conformation.x(elementId[1]),
                                            conformation.y(elementId[1]),
                                            conformation.z(elementId[1])
                                        ], [
                                            conformation.x(elementId[0]),
                                            conformation.y(elementId[0]),
                                            conformation.z(elementId[0])
                                        ], angle, [atom.x, atom.y, atom.z]);
                                        atom.x = newPoint[0], atom.y = newPoint[1], atom.z = newPoint[2];
                                    }
                                });
                                return {
                                    editedAtomList: editedAtomList,
                                    editedBondList: editedBondList
                                };
                            }, function (atomList, bondList) {
                                var editedAtomList = (0, tslib_1.__spreadArray)([], atomList, true);
                                var editedBondList = (0, tslib_1.__spreadArray)([], bondList, true);
                                editedAtomList.forEach(function (atom) {
                                    if (_this.state.rotateAtoms.includes(atom.elementId)) {
                                        var newPoint = (0, math_1.rotateArbitraryLine)([
                                            conformation.x(elementId[1]),
                                            conformation.y(elementId[1]),
                                            conformation.z(elementId[1])
                                        ], [
                                            conformation.x(elementId[0]),
                                            conformation.y(elementId[0]),
                                            conformation.z(elementId[0])
                                        ], angle, [atom.x, atom.y, atom.z]);
                                        atom.x = newPoint[0], atom.y = newPoint[1], atom.z = newPoint[2];
                                    }
                                });
                                return {
                                    editedAtomList: editedAtomList,
                                    editedBondList: editedBondList
                                };
                            });
                        }, this.intervalTime);
                        (_c = this.plugin.canvas3d) === null || _c === void 0 ? void 0 : _c.interaction.drag.subscribe(function (a) {
                            if (_this.state.rotateAtoms.length) {
                                var offset = (0, math_1.getDragOffset)(_this.plugin, a.pageStart, a.pageEnd);
                                _this.state.rotateOffset[0] += offset[0];
                                _this.state.rotateOffset[1] += offset[1];
                                _this.state.rotateOffset[2] += offset[2];
                            }
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    RotateEditor.prototype.end = function () {
        var _a, _b, _c;
        if (this.state.arrowCRef) {
            this.plugin.managers.cell.remove([{ ref: this.state.arrowCRef }]);
            this.state.arrowCRef = undefined;
        }
        if (this.state.interval) {
            clearInterval(this.state.interval);
        }
        // changePickMode(this.plugin, PICK_MODE.Residue);
        (_a = this.plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.interaction.drag.observers.pop();
        if (this.state.dragObserver) {
            (_b = this.plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.interaction.drag.subscribe(this.state.dragObserver);
        }
        this.state.invert = false;
        this.state.dragObserver = undefined;
        this.state.rotateOffset = linear_algebra_1.Vec3.create(0, 0, 0);
        this.state.rotateAtoms = [];
        this.state.elementIds = [];
        this.state.unit = undefined;
        this.plugin.managers.selection.structure.event.add.observers.pop();
        this.plugin.managers.selection.structure.event.remove.observers.pop();
        this.plugin.managers.selection.structure.event.clear.observers.pop();
        (_c = this.plugin.canvas3d) === null || _c === void 0 ? void 0 : _c.interaction.click.observers.pop();
    };
    return RotateEditor;
}());
exports.RotateEditor = RotateEditor;
//# sourceMappingURL=rotate.js.map