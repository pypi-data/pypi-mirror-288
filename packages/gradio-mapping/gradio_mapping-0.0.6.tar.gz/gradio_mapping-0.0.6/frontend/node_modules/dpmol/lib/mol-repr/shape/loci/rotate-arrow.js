"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RotateArrowRepresentation = exports.getRotateArrowParams = exports.RotateArrowArrowHeadParams = exports.RotateArrowCylinderParams = exports.RotateArrowParams = void 0;
var tslib_1 = require("tslib");
var cylinders_1 = require("../../../mol-geo/geometry/cylinders/cylinders");
var cylinders_builder_1 = require("../../../mol-geo/geometry/cylinders/cylinders-builder");
var lines_1 = require("../../../mol-geo/geometry/lines/lines");
var mesh_1 = require("../../../mol-geo/geometry/mesh/mesh");
var mesh_builder_1 = require("../../../mol-geo/geometry/mesh/mesh-builder");
var pyramid_1 = require("../../../mol-geo/primitive/pyramid");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var shape_1 = require("../../../mol-model/shape");
var color_1 = require("../../../mol-util/color");
var names_1 = require("../../../mol-util/color/names");
var marker_action_1 = require("../../../mol-util/marker-action");
var param_definition_1 = require("../../../mol-util/param-definition");
var representation_1 = require("../../representation");
var representation_2 = require("../../structure/representation");
var representation_3 = require("../representation");
var SharedParams = {
    center: param_definition_1.ParamDefinition.Vec3((0, linear_algebra_1.Vec3)()),
    vec: param_definition_1.ParamDefinition.Vec3((0, linear_algebra_1.Vec3)()),
    color: param_definition_1.ParamDefinition.Color(color_1.Color.fromRgb(255, 196, 36)),
    alpha: param_definition_1.ParamDefinition.Numeric(0.9, { min: 0, max: 1, step: 0.1 }),
};
var RotateArrowVisuals = {
    'rotate-arrow-cylinder': function (ctx, getParams) { return (0, representation_3.ShapeRepresentation)(getArrowCylinder, cylinders_1.Cylinders.Utils, { modifyState: function (s) { return ((0, tslib_1.__assign)((0, tslib_1.__assign)({}, s), { markerActions: marker_action_1.MarkerActions.All })); } }); },
    'rotate-arrow-arrowhead': function (ctx, getParams) { return (0, representation_3.ShapeRepresentation)(getArrowHead, mesh_1.Mesh.Utils); }
};
exports.RotateArrowParams = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, lines_1.Lines.Params), SharedParams), { visuals: param_definition_1.ParamDefinition.MultiSelect(['rotate-arrow-cylinder', 'rotate-arrow-arrowhead'], param_definition_1.ParamDefinition.objectToOptions(RotateArrowVisuals)) });
exports.RotateArrowCylinderParams = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, cylinders_1.Cylinders.Params), SharedParams), { color: param_definition_1.ParamDefinition.Color(color_1.Color.fromRgb(255, 196, 36)), sizeFactor: param_definition_1.ParamDefinition.Numeric(0.1, { min: 0, max: 10, step: 0.1 }) });
exports.RotateArrowArrowHeadParams = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, mesh_1.Mesh.Params), SharedParams), { color: param_definition_1.ParamDefinition.Color(names_1.ColorNames.brown) });
function getArrowCylinder(ctx, _, props, shape) {
    var center = props.center, vec = props.vec;
    // 单位向量
    var unitVec = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.normalize(unitVec, vec);
    var gap = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.scale(gap, unitVec, 0.25);
    var moveVec = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.sub(moveVec, vec, gap);
    var newCenter = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.add(newCenter, center, moveVec);
    var moveVec1 = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.scale(moveVec1, unitVec, 0.45);
    linear_algebra_1.Vec3.sub(newCenter, newCenter, moveVec1);
    var builder = cylinders_builder_1.CylindersBuilder.create(128, 64);
    builder.add(center[0], center[1], center[2], newCenter[0], newCenter[1], newCenter[2], 0.05, true, true, 2);
    return shape_1.Shape.create('RotateArrow-cylinder', props, builder.getCylinders(), function () { return props.color; }, function () { return props.sizeFactor; }, function () { return 'RotateArrow'; });
}
function getArrowHead(ctx, _, props, mesh) {
    var builderState = mesh_builder_1.MeshBuilder.createState(256, 128);
    var octagonalPyramid = (0, pyramid_1.OctagonalPyramid)();
    var center = props.center, vec = props.vec; // 单位向量
    var unitVec = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.normalize(unitVec, vec);
    var gap = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.scale(gap, unitVec, 0.1);
    var moveVec11 = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.sub(moveVec11, vec, gap);
    var newCenter = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.add(newCenter, center, moveVec11);
    // 底部三角形中心
    var triangleCenter = linear_algebra_1.Vec3.create(0, 0, 0);
    var moveVec1 = linear_algebra_1.Vec3.create(0, 0, 0);
    linear_algebra_1.Vec3.scale(moveVec1, unitVec, 0.35);
    linear_algebra_1.Vec3.sub(triangleCenter, newCenter, moveVec1);
    var side = 0.4;
    var t = linear_algebra_1.Mat4.identity();
    var pd = (0, linear_algebra_1.Vec3)();
    linear_algebra_1.Vec3.add(pd, triangleCenter, vec);
    linear_algebra_1.Mat4.targetTo(t, pd, triangleCenter, linear_algebra_1.Vec3.create(1, 0, 0));
    linear_algebra_1.Mat4.setTranslation(t, triangleCenter);
    builderState.currentGroup = 0;
    linear_algebra_1.Mat4.scaleUniformly(t, t, side * 1.5);
    mesh_builder_1.MeshBuilder.addPrimitive(builderState, t, octagonalPyramid);
    return shape_1.Shape.create('axes', props, mesh_builder_1.MeshBuilder.getMesh(builderState), function () { return props.color; }, function () { return 0.05; }, function () { return ''; });
}
function getRotateArrowParams(ctx) {
    return param_definition_1.ParamDefinition.clone(exports.RotateArrowParams);
}
exports.getRotateArrowParams = getRotateArrowParams;
function RotateArrowRepresentation(ctx, getParams) {
    var res = representation_1.Representation.createMulti('RotateArrow', ctx, getParams, representation_2.StructureRepresentationStateBuilder, RotateArrowVisuals);
    res.setState({ markerActions: marker_action_1.MarkerActions.All });
    return res;
}
exports.RotateArrowRepresentation = RotateArrowRepresentation;
//# sourceMappingURL=rotate-arrow.js.map