"use strict";
/**
 * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author Fred Ludlow <Fred.Ludlow@astx.com>
 *
 * based in part on NGL (https://github.com/arose/ngl)
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HalogenBondsProvider = exports.HalogenAcceptorProvider = exports.HalogenDonorProvider = exports.DefaultHalogenBondParams = void 0;
var param_definition_1 = require("../../../mol-util/param-definition");
var geometry_1 = require("../chemistry/geometry");
var features_1 = require("./features");
var util_1 = require("../chemistry/util");
var misc_1 = require("../../../mol-math/misc");
var common_1 = require("./common");
var valence_model_1 = require("../valence-model");
var HalogenBondsParams = {
    distanceMax: param_definition_1.ParamDefinition.Numeric(3.5, { min: 1, max: 5, step: 0.1 }),
    // 薛定谔的参数中，donor和acceptor可以分别定义，donor为40（180 - 140），acceptor为60（180 - 120），目前这里取最大值60
    angleMax: param_definition_1.ParamDefinition.Numeric(60, { min: 0, max: 60, step: 1 })
};
exports.DefaultHalogenBondParams = param_definition_1.ParamDefinition.getDefaultValues(HalogenBondsParams);
var halBondElements = [
    "CL" /* CL */,
    "BR" /* BR */,
    "I" /* I */,
    "AT" /* AT */
];
function getUnitValenceModel(structure, unit) {
    var valenceModel = valence_model_1.ValenceModelProvider.get(structure).value;
    if (!valenceModel)
        throw Error('expected valence model to be available');
    var unitValenceModel = valenceModel.get(unit.id);
    if (!unitValenceModel)
        throw Error('expected valence model for unit to be available');
    return unitValenceModel;
}
/**
 * Halogen bond donors (X-C, with X one of Cl, Br, I or At) not F!
 */
function addUnitHalogenDonors(structure, unit, builder) {
    var elements = unit.elements;
    var _a = unit.model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;
    for (var i = 0, il = elements.length; i < il; ++i) {
        var element = (0, util_1.typeSymbol)(unit, i);
        if (halBondElements.includes(element)) {
            builder.add(6 /* HalogenDonor */, 0 /* None */, x[elements[i]], y[elements[i]], z[elements[i]], i);
        }
    }
}
/**
 * Halogen bond acceptors (Y-{O|N|S}, with Y=C,P,N,S)
 */
function addUnitHalogenAcceptors(structure, unit, builder) {
    var _a = getUnitValenceModel(structure, unit), charge = _a.charge, implicitH = _a.implicitH, idealGeometry = _a.idealGeometry;
    var elements = unit.elements;
    var _b = unit.model.atomicConformation, x = _b.x, y = _b.y, z = _b.z;
    var add = function (i) {
        builder.add(7 /* HalogenAcceptor */, 0 /* None */, x[elements[i]], y[elements[i]], z[elements[i]], i);
    };
    for (var i = 0, il = elements.length; i < il; ++i) {
        var element = (0, util_1.typeSymbol)(unit, i);
        if (element === "O" /* O */) {
            // Basically assume all oxygen atoms are acceptors!
            add(i);
        }
        else if (element === "N" /* N */) {
            if (charge[i] < 1) {
                // Neutral nitrogen might be an acceptor
                // It must have at least one lone pair not conjugated
                var totalBonds = (0, util_1.bondCount)(structure, unit, i) + implicitH[i];
                var ig = idealGeometry[i];
                if ((ig === 4 /* Tetrahedral */ && totalBonds < 4) ||
                    (ig === 3 /* Trigonal */ && totalBonds < 3) ||
                    (ig === 2 /* Linear */ && totalBonds < 2)) {
                    add(i);
                }
            }
        }
        else if (element === "S" /* S */) {
            if ((0, util_1.formalCharge)(unit, i) === -1) {
                add(i);
            }
        }
        else if (element === "F" /* F */) {
            add(i);
        }
    }
    for (var _i = 0, _c = unit.rings.aromaticRings; _i < _c.length; _i++) {
        var ringIndex = _c[_i];
        var ring = unit.rings.all[ringIndex];
        builder.startState();
        for (var i = 0, il = ring.length; i < il; ++i) {
            var j = ring[i];
            builder.pushMember(x[elements[j]], y[elements[j]], z[elements[j]], j);
        }
        builder.finishState(7 /* HalogenAcceptor */, 0 /* None */);
    }
}
function isHalogenBond(ti, tj) {
    return ((ti === 7 /* HalogenAcceptor */ && tj === 6 /* HalogenDonor */) ||
        (ti === 6 /* HalogenDonor */ && tj === 7 /* HalogenAcceptor */));
}
// http://www.pnas.org/content/101/48/16789.full
var OptimalHalogenAngle = (0, misc_1.degToRad)(180); // adjusted from 165 to account for spherical statistics
var OptimalAcceptorAngle = (0, misc_1.degToRad)(120);
function getOptions(props) {
    return {
        angleMax: (0, misc_1.degToRad)(props.angleMax)
    };
}
function testHalogenBond(structure, infoA, infoB, opts) {
    var typeA = infoA.types[infoA.feature];
    var typeB = infoB.types[infoB.feature];
    if (!isHalogenBond(typeA, typeB))
        return;
    var _a = typeA === 6 /* HalogenDonor */ ? [infoA, infoB] : [infoB, infoA], don = _a[0], acc = _a[1];
    var donIndex = don.members[don.offsets[don.feature]];
    var accIndex = acc.members[acc.offsets[acc.feature]];
    var halogenAngles = (0, geometry_1.calcAngles)(structure, don.unit, donIndex, acc.unit, accIndex);
    // Singly bonded halogen only (not bromide ion for example)
    if (halogenAngles.length !== 1)
        return;
    if (OptimalHalogenAngle - halogenAngles[0] > opts.angleMax)
        return;
    var acceptorAngles = (0, geometry_1.calcAngles)(structure, acc.unit, accIndex, don.unit, donIndex);
    // Angle must be defined. Excludes water as acceptor. Debatable
    if (acceptorAngles.length === 0)
        return;
    if (acceptorAngles.some(function (acceptorAngle) { return OptimalAcceptorAngle - acceptorAngle > opts.angleMax; }))
        return;
    return common_1.InteractionType.HalogenBond;
}
//
exports.HalogenDonorProvider = features_1.Features.Provider([6 /* HalogenDonor */], addUnitHalogenDonors);
exports.HalogenAcceptorProvider = features_1.Features.Provider([7 /* HalogenAcceptor */], addUnitHalogenAcceptors);
exports.HalogenBondsProvider = {
    name: 'halogen-bonds',
    params: HalogenBondsParams,
    createTester: function (props) {
        var opts = getOptions(props);
        return {
            maxDistance: props.distanceMax,
            requiredFeatures: new Set([
                6 /* HalogenDonor */,
                7 /* HalogenAcceptor */
            ]),
            getType: function (structure, infoA, infoB) {
                return testHalogenBond(structure, infoA, infoB, opts);
            }
        };
    }
};
//# sourceMappingURL=halogen-bonds.js.map