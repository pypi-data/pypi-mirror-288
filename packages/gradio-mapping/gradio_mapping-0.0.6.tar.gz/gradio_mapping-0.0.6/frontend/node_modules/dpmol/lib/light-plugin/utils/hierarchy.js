"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGranularityProps = exports.getGranularityUniqueId = exports.getSequence = exports.getHierarchy = exports.setHierarchyData = exports.atomHierarchyToAtomData = exports.SolventNameSet = exports.MetalNameSet = void 0;
var tslib_1 = require("tslib");
var types_1 = require("../../mol-model/structure/model/types");
var ions_1 = require("../../mol-model/structure/model/types/ions");
var types_2 = require("../types");
var sequence_1 = require("./sequence");
var structure_1 = require("./structure");
var MetalNames = [
    'LI',
    'NA',
    'K',
    'RB',
    'CS',
    'FR',
    'BE',
    'MG',
    'CA',
    'SR',
    'BA',
    'RA',
    'AL',
    'GA',
    'IN',
    'SN',
    'TL',
    'PB',
    'BI',
    'SC',
    'TI',
    'V',
    'CR',
    'MN',
    'FE',
    'CO',
    'NI',
    'CU',
    'ZN',
    'Y',
    'ZR',
    'NB',
    'MO',
    'TC',
    'RU',
    'RH',
    'PD',
    'AG',
    'CD',
    'LA',
    'HF',
    'TA',
    'W',
    'RE',
    'OS',
    'IR',
    'PT',
    'AU',
    'HG',
    'AC',
    'RF',
    'DB',
    'SG',
    'BH',
    'HS',
    'MT',
    'CE',
    'PR',
    'ND',
    'PM',
    'SM',
    'EU',
    'GD',
    'TB',
    'DY',
    'HO',
    'ER',
    'TM',
    'YB',
    'LU',
    'TH',
    'PA',
    'U',
    'NP',
    'PU',
    'AM',
    'CM',
    'BK',
    'CF',
    'ES',
    'FM',
    'MD',
    'NO',
    'LR'
];
var SolventNames = [
    'EOH',
    'GOL',
    'DMS',
    'PEG',
    'POL',
    'IOH',
    'DIO',
    'ACN',
    'SBT',
    '1BO',
    'CCN',
    'DMS',
    'GBL',
    'P2K',
    'MPD',
    'PGQ',
    'SEO'
];
exports.MetalNameSet = new Set(MetalNames);
exports.SolventNameSet = new Set(SolventNames);
var atomHierarchyToAtomData = function (atom) {
    var _a, _b;
    return {
        elementId: atom.elementId,
        group_PDB: atom.groupPDB,
        atom_id: "".concat(atom.atomId),
        auth_atom_id: atom.atomName,
        label_alt_id: atom.altId,
        auth_comp_id: atom.residueName,
        auth_asym_id: atom.chainId,
        auth_seq_id: "".concat(atom.residueId),
        pdbx_PDB_ins_code: atom.insertCode,
        x: atom.x,
        y: atom.y,
        z: atom.z,
        occupancy: (_a = atom.occupancy) !== null && _a !== void 0 ? _a : '',
        B_iso_or_equiv: "".concat((_b = atom.bfactor) !== null && _b !== void 0 ? _b : ''),
        type_symbol: atom.typeSymbol,
        charge: atom.charge
    };
};
exports.atomHierarchyToAtomData = atomHierarchyToAtomData;
var setHierarchyData = function (obj, data, insertCode) {
    if (insertCode === void 0) { insertCode = false; }
    var residueKey = insertCode ? "".concat(data.residueId, "_").concat(data.insertCode) : data.residueId;
    if (obj[data.chainId]) {
        obj[data.chainId][residueKey] = (obj[data.chainId][residueKey] ? obj[data.chainId][residueKey] : []).concat(data);
    }
    else {
        obj[data.chainId] = {};
        obj[data.chainId][residueKey] = [data];
    }
};
exports.setHierarchyData = setHierarchyData;
var getHierarchy = function (structure) {
    var polymerElements = {};
    var waterElements = {};
    var solventElements = {};
    var metalElements = {};
    var ionElements = {};
    var eutecticMoleculeElements = {};
    var otherElements = {};
    var ligandElements = {};
    var polymerElementIds = new Set();
    var eutecticMoleculeAtomsMap = new Map();
    var bondMap = new Map();
    structure.units.forEach(function (unit) {
        var _a;
        unit.elements.forEach(function (element) {
            var data = (0, structure_1.getAtomHierarchyByUnit)(unit, element);
            if (types_1.WaterNames.has(data.residueName.toUpperCase())) {
                (0, exports.setHierarchyData)(waterElements, data);
                return;
            }
            if (exports.MetalNameSet.has(data.typeSymbol.toUpperCase())) {
                (0, exports.setHierarchyData)(metalElements, data);
                return;
            }
            if (exports.SolventNameSet.has(data.residueName.toUpperCase())) {
                (0, exports.setHierarchyData)(solventElements, data);
                return;
            }
            if (ions_1.IonNames.has(data.residueName.toUpperCase())) {
                (0, exports.setHierarchyData)(ionElements, data);
                return;
            }
            if (data.groupPDB === 'ATOM' && !['UNK', 'MOL'].includes(data.residueName)) {
                (0, exports.setHierarchyData)(polymerElements, data, true);
                polymerElementIds.add(data.elementId);
                return;
            }
            if (data.groupPDB === 'HETATM' || ['UNK', 'MOL'].includes(data.residueName)) {
                var key = "".concat(data.chainId, "_").concat(data.residueId);
                eutecticMoleculeAtomsMap.set(key, eutecticMoleculeAtomsMap.has(key)
                    ? (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], eutecticMoleculeAtomsMap.get(key), true), [data], false) : [data]);
                return;
            }
            (0, exports.setHierarchyData)(otherElements, data);
        });
        for (var i = 0, l = unit.bonds.a.length; i < l; i++) {
            var a = unit.elements[unit.bonds.a[i]];
            var b = unit.elements[unit.bonds.b[i]];
            if (!bondMap.has(a)) {
                bondMap.set(a, new Set([b]));
            }
            else {
                (_a = bondMap.get(a)) === null || _a === void 0 ? void 0 : _a.add(b);
            }
        }
    });
    eutecticMoleculeAtomsMap.forEach(function (val) {
        var isEutectic = false;
        var elementIds = new Set(val.map(function (item) { return item.elementId; }));
        elementIds.forEach(function (elementIdA) {
            if (bondMap.has(elementIdA)) {
                var connect = bondMap.get(elementIdA);
                connect === null || connect === void 0 ? void 0 : connect.forEach(function (elementIdB) {
                    if (polymerElementIds.has(elementIdB)) {
                        isEutectic = true;
                    }
                });
            }
        });
        val.forEach(function (data) {
            if (isEutectic) {
                Object.assign(data, { isEutectic: true });
                (0, exports.setHierarchyData)(eutecticMoleculeElements, data);
            }
            else {
                (0, exports.setHierarchyData)(otherElements, data);
            }
        });
    });
    var otherElementsEnd = {};
    Object.keys(otherElements).forEach(function (chainId) {
        var chain = otherElements[chainId];
        Object.keys(chain).forEach(function (residueId) {
            var residue = chain[residueId];
            var heavyAtoms = residue.filter(function (item) { return item.typeSymbol !== 'H'; });
            if (heavyAtoms.length > 10 && heavyAtoms.length < 150) {
                if (!ligandElements[chainId]) {
                    ligandElements[chainId] = {};
                }
                ligandElements[chainId][residueId] = residue;
            }
            else {
                if (!otherElementsEnd[chainId]) {
                    otherElementsEnd[chainId] = {};
                }
                otherElementsEnd[chainId][residueId] = residue;
            }
        });
    });
    var sequenceData = {};
    Object.keys(polymerElements).forEach(function (chainId) {
        var _a;
        if (!sequenceData[chainId])
            sequenceData[chainId] = [];
        (_a = sequenceData[chainId]).push.apply(_a, Object.values(polymerElements[chainId]));
    });
    Object.keys(eutecticMoleculeElements).forEach(function (chainId) {
        var chain = eutecticMoleculeElements[chainId];
        Object.keys(chain).forEach(function (residueId) {
            var residue = chain[residueId];
            if (!otherElementsEnd[chainId]) {
                otherElementsEnd[chainId] = {};
            }
            if (!sequenceData[chainId])
                sequenceData[chainId] = [];
            sequenceData[chainId].push(residue);
            otherElementsEnd[chainId][residueId] = residue;
        });
    });
    var index = 0;
    var sequenceDataRes = {};
    Object.keys(sequenceData).forEach(function (chainId) {
        sequenceDataRes[chainId] = {};
        sequenceData[chainId]
            .sort(function (a, b) { return a[0].residueId !== b[0].residueId ? a[0].residueId - b[0].residueId : a[0].insertCode.localeCompare(b[0].insertCode); })
            .forEach(function (item) {
            sequenceDataRes[item[0].chainId]["".concat(item[0].residueId, "_").concat(item[0].insertCode)] = (0, sequence_1.getSequenceDataOfResidue)(structure, item, index++);
        });
    });
    var hierarchyData;
    hierarchyData = {
        // structureRef: ref,
        data: {
            polymer: polymerElements,
            water: waterElements,
            otherSolvent: solventElements,
            metal: metalElements,
            ion: ionElements,
            ligand: ligandElements,
            other: otherElementsEnd
        },
        extraData: {
            // label: labelInfo,
            // surface: surfaceInfo,
            sequenceData: sequenceDataRes,
        },
    };
    return hierarchyData;
};
exports.getHierarchy = getHierarchy;
var getSequence = function (structure) {
    var polymerElements = {};
    var eutecticMoleculeElements = {};
    var otherElements = {};
    var polymerElementIds = new Set();
    var eutecticMoleculeAtomsMap = new Map();
    var bondMap = new Map();
    structure.units.forEach(function (unit) {
        var _a;
        unit.elements.forEach(function (element) {
            var data = (0, structure_1.getAtomHierarchyByUnit)(unit, element);
            if (types_1.WaterNames.has(data.residueName.toUpperCase())) {
                return;
            }
            if (exports.MetalNameSet.has(data.typeSymbol.toUpperCase())) {
                return;
            }
            if (exports.SolventNameSet.has(data.residueName.toUpperCase())) {
                return;
            }
            if (ions_1.IonNames.has(data.residueName.toUpperCase())) {
                return;
            }
            if (data.groupPDB === 'ATOM' && !['UNK', 'MOL'].includes(data.residueName)) {
                (0, exports.setHierarchyData)(polymerElements, data, true);
                polymerElementIds.add(data.elementId);
                return;
            }
            if (data.groupPDB === 'HETATM' || ['UNK', 'MOL'].includes(data.residueName)) {
                var key = "".concat(data.chainId, "_").concat(data.residueId);
                eutecticMoleculeAtomsMap.set(key, eutecticMoleculeAtomsMap.has(key)
                    ? (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], eutecticMoleculeAtomsMap.get(key), true), [data], false) : [data]);
                return;
            }
            (0, exports.setHierarchyData)(otherElements, data);
        });
        for (var i = 0, l = unit.bonds.a.length; i < l; i++) {
            var a = unit.elements[unit.bonds.a[i]];
            var b = unit.elements[unit.bonds.b[i]];
            if (!bondMap.has(a)) {
                bondMap.set(a, new Set([b]));
            }
            else {
                (_a = bondMap.get(a)) === null || _a === void 0 ? void 0 : _a.add(b);
            }
        }
    });
    eutecticMoleculeAtomsMap.forEach(function (val) {
        var isEutectic = false;
        var elementIds = new Set(val.map(function (item) { return item.elementId; }));
        elementIds.forEach(function (elementIdA) {
            if (bondMap.has(elementIdA)) {
                var connect = bondMap.get(elementIdA);
                connect === null || connect === void 0 ? void 0 : connect.forEach(function (elementIdB) {
                    if (polymerElementIds.has(elementIdB)) {
                        isEutectic = true;
                    }
                });
            }
        });
        val.forEach(function (data) {
            if (isEutectic) {
                Object.assign(data, { isEutectic: true });
                (0, exports.setHierarchyData)(eutecticMoleculeElements, data);
            }
            else {
                (0, exports.setHierarchyData)(otherElements, data);
            }
        });
    });
    var otherElementsEnd = {};
    Object.keys(otherElements).forEach(function (chainId) {
        var chain = otherElements[chainId];
        Object.keys(chain).forEach(function (residueId) {
            var residue = chain[residueId];
            var heavyAtoms = residue.filter(function (item) { return item.typeSymbol !== 'H'; });
            if (heavyAtoms.length <= 10 && heavyAtoms.length < 150) {
                if (!otherElementsEnd[chainId]) {
                    otherElementsEnd[chainId] = {};
                }
                otherElementsEnd[chainId][residueId] = residue;
            }
        });
    });
    var sequenceData = {};
    Object.keys(polymerElements).forEach(function (chainId) {
        var _a;
        if (!sequenceData[chainId])
            sequenceData[chainId] = [];
        (_a = sequenceData[chainId]).push.apply(_a, Object.values(polymerElements[chainId]));
    });
    Object.keys(eutecticMoleculeElements).forEach(function (chainId) {
        var chain = eutecticMoleculeElements[chainId];
        Object.keys(chain).forEach(function (residueId) {
            var residue = chain[residueId];
            if (!otherElementsEnd[chainId]) {
                otherElementsEnd[chainId] = {};
            }
            if (!sequenceData[chainId])
                sequenceData[chainId] = [];
            sequenceData[chainId].push(residue);
            otherElementsEnd[chainId][residueId] = residue;
        });
    });
    var index = 0;
    var sequenceDataRes = {};
    Object.keys(sequenceData).forEach(function (chainId) {
        sequenceDataRes[chainId] = {};
        sequenceData[chainId]
            .sort(function (a, b) { return a[0].residueId !== b[0].residueId ? a[0].residueId - b[0].residueId : a[0].insertCode.localeCompare(b[0].insertCode); })
            .forEach(function (item) {
            sequenceDataRes[item[0].chainId]["".concat(item[0].residueId, "_").concat(item[0].insertCode)] = (0, sequence_1.getSequenceDataOfResidue)(structure, item, index++);
        });
    });
    return sequenceDataRes;
};
exports.getSequence = getSequence;
var getGranularityUniqueId = function (data, granularity) {
    switch (granularity) {
        case types_2.Granularity.Atom:
            return "".concat(data.elementId);
        case types_2.Granularity.Residue:
            return "".concat(data.chainId, "_").concat(data.residueName, "_").concat(data.residueId);
        case types_2.Granularity.Chain:
            return "".concat(data.chainId);
        case types_2.Granularity.Molecular:
            return "".concat(data.unitId);
        default:
    }
    return '';
};
exports.getGranularityUniqueId = getGranularityUniqueId;
var getGranularityProps = function (data, granularity) {
    switch (granularity) {
        case types_2.Granularity.Atom:
            return data;
        case types_2.Granularity.Residue:
            return {
                unitId: data.unitId,
                chainId: data.chainId,
                groupPDB: data.groupPDB,
                residueId: data.residueId,
                residueName: data.residueName,
            };
        case types_2.Granularity.Chain:
            return {
                unitId: data.unitId,
                chainId: data.chainId,
            };
        case types_2.Granularity.Molecular:
            return {
                unitId: data.unitId
            };
        default:
    }
    return {};
};
exports.getGranularityProps = getGranularityProps;
//# sourceMappingURL=hierarchy.js.map